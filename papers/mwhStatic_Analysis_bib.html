<h1>mwhStatic_Analysis.bib</h1><pre>
@comment{{This file has been generated by bib2bib 1.99}}
</pre>

<pre>
@comment{{Command line: bib2bib -c 'category : "Static_Analysis" & $type = "TECHREPORT" & !(? omitfromweb)' -oc tmp/keys16852 -ob tmp/mwhStatic_Analysis.bib ../mwh.bib}}
</pre>

<a name="turpie11multiotter"></a><pre>
@techreport{<a href="mwhStatic_Analysis.html#turpie11multiotter">turpie11multiotter</a>,
  title = {MultiOtter: Multiprocess Symbolic Execution},
  author = {Jonathan Turpie and Elnatan Reisner and Jeffrey S. Foster and Michael Hicks},
  number = {CS-TR-4982},
  institution = {University of Maryland Department of Computer Science},
  year = 2011,
  month = aug,
  abstract = {
  Symbolic execution can be an effective technique for exploring large numbers
  of program paths, but it has generally been applied to programs running in
  isolation, whose inputs are files or command-line arguments. Programs that
  take inputs from other programs---servers, for example---have been
  beyond the reach of symbolic execution. To address this, we developed a
  multiprocess symbolic
  executor called MultiOtter, along with an implementation of many of the POSIX functions, such as
  \texttt{socket} and \texttt{select}, that interactive programs usually rely on.
  However, that is just a first step. Next, we must determine what symbolic inputs
  to feed to an interactive program to make multiprocess symbolic execution effective.
  Providing completely unconstrained symbolic values causes symbolic execution
  to spend too much time exploring uninteresting paths, such as paths to handle
  invalid inputs. MultiOtter allows us to generate inputs that conform to a
  context-free grammar, similar to previous work, but it also enables new input
  generation capabilities because we can now run arbitrary programs concurrently
  with the program being studied. As examples, we symbolically executed a
  key-value store server, redis, and an FTP server, vsftpd, each with a variety
  of inputs, including symbolic versions of tests from redis's test suite
  and wget as a client for vsftpd. We report the coverage provided by symbolic
  execution with various forms of symbolic input, showing that different testing
  goals require different degrees of symbolic inputs.
  },
  category = {Static_Analysis},
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/multiotter.pdf">http://www.cs.umd.edu/~mwh/papers/multiotter.pdf</a>}
}
</pre>

<a name="ma11directedTR"></a><pre>
@techreport{<a href="mwhStatic_Analysis.html#ma11directedTR">ma11directedTR</a>,
  title = {Directed Symbolic Execution},
  author = {Kin-Keung Ma and Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks},
  abstract = {
In this paper, we study the problem of automatically finding program
executions that reach a particular target line. This problem arises
in many debugging scenarios; for example, a developer may want to confirm
that a bug reported by a static analysis tool on a particular line is
a true positive. 
We propose two new \emph{directed} 
symbolic execution strategies that aim to solve this problem:
\emph{shortest-distance symbolic execution (SDSE)} uses a distance metric in
an interprocedural control flow graph to guide symbolic execution toward a
particular target; and \emph{call-chain-backward symbolic execution (CCBSE)}
iteratively runs forward symbolic execution, starting in the function
containing the target line, and then jumping backward up the call chain
until it finds a feasible path from the start of the program. 
We also propose a hybrid strategy, Mix-CCBSE, which alternates CCBSE with
another (forward) search strategy.  We compare these three with several
existing strategies from the literature on a suite of six GNU
coreutils programs. 
We find that SDSE performs extremely well in many cases
but may fail badly. CCBSE also performs quite well, but imposes
additional overhead that sometimes makes it slower than SDSE.  Considering
all our benchmarks together, Mix-CCBSE performed best on average,
combining to good effect the features of its constituent components.
},
  month = apr,
  category = {Static_Analysis},
  year = 2011,
  number = {CS-TR-4979},
  institution = {University of Maryland Department of Computer Science},
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/directedSE-TR.pdf">http://www.cs.umd.edu/~mwh/papers/directedSE-TR.pdf</a>},
  note = {Extended version contains refinements and further experimental analysis}
}
</pre>

<a name="swamy11monadTR"></a><pre>
@techreport{<a href="mwhStatic_Analysis.html#swamy11monadTR">swamy11monadTR</a>,
  title = {Lightweight Monadic Programming in {ML}},
  author = {Nikhil Swamy and Nataliya Guts and Daan Leijen and Michael Hicks},
  number = {MSR-TR-2011-039},
  institution = {Microsoft Research},
  abstract = {
  Many useful programming constructions can be expressed as monads.
  Examples include probabilistic computations,
  time-varying expressions, parsers, and information flow tracking,
  not to mention effectful features like state and I/O.  In this
  paper, we present a type-based rewriting algorithm to make
  programming with arbitrary monads as easy as using ML's built-in
  support for state and I/O.  Developers write programs using monadic
  values of type $M~t$ as if they were of type $t$, and our algorithm
  inserts the necessary binds, units, and monad-to-monad morphisms so
  that the program typechecks.  Our algorithm is based on Jones'
  qualified types and enjoys three useful properties: (1) principal
  types, i.e., the rewriting we perform is the most general; (2)
  coherence, i.e., thanks to the monad and morphism laws, all
  instances of the principal rewriting have the same semantics; (3)
  decidability; i.e., the solver for generated constraints will always
  terminate.  Throughout the paper we present simple examples from the
  domains listed above.  Our most complete example, which illustrates
  the expressive power of our system, proves that ML programs
  rewritten by our algorithm to use the information flow monad are
  equivalent to programs in FlowCaml, a domain-specific information
  flow tracking language.
  },
  category = {Static_Analysis},
  year = 2011,
  month = may,
  http = {<a href="http://research.microsoft.com/en-us/projects/coco/">http://research.microsoft.com/en-us/projects/coco/</a>},
  url = {<a href="http://research.microsoft.com/pubs/147003/monadic.pdf">http://research.microsoft.com/pubs/147003/monadic.pdf</a>}
}
</pre>

<a name="an10rubydustTR"></a><pre>
@techreport{<a href="mwhStatic_Analysis.html#an10rubydustTR">an10rubydustTR</a>,
  author = {Jong-hoon (David) An and Avik Chaudhuri and Jeffrey S. Foster and Michael Hicks},
  title = {Dynamic Inference of Static Types for Ruby},
  institution = {University of Maryland Department of Computer Science},
  number = {CS-TR-4965},
  abstract = {
  There have been several efforts to bring static type
  inference to object-oriented dynamic languages such as Ruby, Python,
  and Perl.  In our experience, however, such type inference systems
  are extremely difficult to develop, because dynamic languages are
  typically complex, poorly specified, and include
  features, such as \texttt{eval} and reflection, that are hard to
  analyze.  In this paper, we introduce 
  \emph{constraint-based dynamic type inference}, a technique that
  infers static types based on dynamic program executions.  In our approach,
  we wrap each run-time value to associate it with a type variable,
  and the wrapper generates constraints on this type variable when
  the wrapped value is used.  This technique avoids many of the often
  overly conservative approximations of static tools,
  as constraints
  are generated based on how values are used during actual program runs.
  Using wrappers is also easy to implement, since we need only
  write a constraint resolution algorithm and a transformation to
  introduce the wrappers.
  The best part is that we can eat our
  cake, too: our algorithm will infer \emph{sound} types as long as it
  observes every 
  path through each method body---note that the number of such paths
  may be dramatically smaller than the number of paths through the
  program as a whole.  We have developed Rubydust, an implementation of
  our algorithm for Ruby.  Rubydust takes advantage of Ruby's dynamic
  features to implement wrappers as a language library.  We applied
  Rubydust to a number of small programs.  We found it to be
  lightweight and useful: Rubydust discovered 1 real type error,
  and all other inferred types were correct, and readable.
 },
  month = jul,
  url = {<a href="http://www.lib.umd.edu/drum/bitstream/1903/10599/1/CS-TR-4965.pdf">http://www.lib.umd.edu/drum/bitstream/1903/10599/1/CS-TR-4965.pdf</a>},
  year = 2010,
  note = {Extended version contains proofs of theorems},
  category = {Static_Analysis}
}
</pre>

<a name="pratikakis05existstr"></a><pre>
@techreport{<a href="mwhStatic_Analysis.html#pratikakis05existstr">pratikakis05existstr</a>,
  author = {Polyvios Pratikakis and Michael Hicks and Jeffrey S. Foster},
  title = {Existential Label Flow Inference via {CFL} Reachability (Extended Version)},
  institution = {Department of Computer Science, University of Maryland},
  number = {CS-TR-4700},
  year = 2005,
  month = jul,
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/existsflow-tr.pdf">http://www.cs.umd.edu/~mwh/papers/existsflow-tr.pdf</a>},
  abstract = {
  Label flow analysis is a fundamental static analysis problem with a
  wide variety of applications.  Previous work by Mossin developed a
  polynomial time subtyping-based label flow inference that supports
  Hindley-Milner style polymorphism with polymorphic recursion.  Rehof
  et al have developed an efficient $O(n^3)$ inference algorithm for
  Mossin's system based on context-free language (CFL) reachability.
  In this paper, we extend these results to a system that also
  supports existential polymorphism, which is important for precisely
  describing correlations among members of a structured type, even
  when values of that type are part of dynamic data structures.  We
  first develop a provably sound checking system based on
  polymorphically-constrained types.  As usual, we restrict universal
  quantification to the top level of a type, but existential
  quantification is first class, with subtyping allowed between
  existentials with the same binding structure.  We then develop a
  CFL-based inference system.  Programmers specify which positions in
  a type are existentially quantified, and the algorithm infers the
  constraints bound in the type, or rejects a program if the
  annotations are inconsistent.
},
  category = {Static_Analysis}
}
</pre>

<hr><p><em>This file was generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.99.</em></p>
