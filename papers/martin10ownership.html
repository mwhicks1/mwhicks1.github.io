<font size="+1"><b>Dynamically Checking Ownership Policies in Concurrent C/C++ Programs</b>.
 Jean-Philippe Martin, Michael Hicks, Manuel Costa, Periklis
  Akritidis, and Miguel Castro.
 In <em>Proceedings of the ACM Conference on Principles of
  Programming Languages (POPL)</em>, pages 457--470, January 2010.
 Full version.</font><p>
Concurrent programming errors arise when threads share data
incorrectly. Programmers often avoid these errors by using
synchronization to enforce a simple ownership policy: data is either
<em>owned exclusively</em> by a thread that can read or write the data,
or it is <em>read owned</em> by a set of threads that can read but
not write the data.  Unfortunately, incorrect synchronization often
fails to enforce these policies and memory errors in languages like C
and C++ can violate these policies even when synchronization is
correct.<p>
In this paper, we present a dynamic analysis for checking ownership
policies in concurrent C and C++ programs despite memory errors. The
analysis can be used to find errors in commodity multi-threaded
programs and to prevent attacks that exploit these errors.  We require
programmers to write ownership assertions that describe the sharing
policies used by different parts of the program.  These policies may
change over time, as may the policies' means of enforcement, whether
it be locks, barriers, thread joins, etc. Our compiler inserts checks
in the program that signal an error if these policies are violated at
runtime.  We evaluated our tool on several benchmark programs.  The
run-time overhead was reasonable: between 0 and 49% with an average
of 26%.  We also found the tool easy to use: the total number of
ownership assertions is small, and the asserted specification and
implementation can be debugged together by running the instrumented
program and addressing the errors that arise.  Our approach enjoys a
pleasing modular soundness property: if a thread executes a sequence
of statements on variables it owns, the statements are serializable
within a valid execution, and thus their effects can be reasoned about
in isolation from other threads in the program.
<p>[&nbsp;<a href="http://www.cs.umd.edu/~mwh/papers/conccheck-full.pdf">.pdf</a>&nbsp;]
<a name="martin10ownership"></a><pre>
@inproceedings{martin10ownership,
  author = {Jean-Philippe Martin and Michael Hicks and Manuel Costa and Periklis Akritidis and Miguel Castro},
  title = {Dynamically Checking Ownership Policies in Concurrent {C/C++}
  Programs},
  booktitle = {Proceedings of the {ACM} Conference on Principles of Programming Languages (POPL)},
  pages = {457--470},
  month = jan,
  year = 2010,
  note = {Full version}
}
</pre>

<hr><p><em>This file was generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.99.</em></p>
