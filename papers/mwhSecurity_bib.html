<h1>mwhSecurity.bib</h1><pre>
@comment{{This file has been generated by bib2bib 1.99}}
</pre>

<pre>
@comment{{Command line: bib2bib -c 'category : "Security" & $type = "TECHREPORT" & !(? omitfromweb)' -oc tmp/keys16722 -ob tmp/mwhSecurity.bib ../mwh.bib}}
</pre>

<a name="darais19obliv"></a><pre>
@techreport{<a href="mwhSecurity.html#darais19obliv">darais19obliv</a>,
  title = {A Language for Probabilistically Oblivious Computation},
  author = {David Darais and Ian Sweet and Chang Liu and Michael Hicks},
  abstract = {
  An oblivious computation is one that is free of direct and indirect
  information leaks, e.g., due to observable differences in timing and
  memory access patterns.  This paper presents
  $\lambda_{obliv}$, a core language whose type system enforces obliviousness.
  Prior work on type-enforced oblivious computation has focused on
  deterministic programs. $\lambda_{obliv}$ is new in its consideration of
  programs that implement \emph{probabilistic} algorithms, such as
  those involved in cryptography. $\lambda_{obliv}$ employs a substructural type
  system and a novel notion of \emph{probability region} to ensure that
  information is not leaked via the distribution of visible
  events. The use of regions was motivated by a source of unsoundness
  that we discovered in the type system of ObliVM, a language for implementing
  state of the art oblivious algorithms and data structures. We prove
  that $\lambda_{obliv}$'s type system enforces obliviousness and show that it is
  expressive enough to typecheck advanced tree-based oblivious RAMs.
},
  institution = {CoRR},
  number = {abs/1711.09305},
  year = {2019},
  url = {https://arxiv.org/abs/1711.09305},
  archiveprefix = {arXiv},
  eprint = {1711.09305},
  month = jul,
  category = {Security}
}
</pre>

<a name="rastogi16wysstar"></a><pre>
@techreport{<a href="mwhSecurity.html#rastogi16wysstar">rastogi16wysstar</a>,
  author = {Aseem Rastogi and Nikhil Swamy and Michael Hicks},
  title = {Wys$^*$: A Verified Language Extension for Secure Multi-Party Computations},
  abstract = {
  Secure multi-party computation (MPC) enables a set of mutually
distrusting parties to cooperatively compute, using a cryptographic
protocol, a function over their private data.
This paper presents Wys$^*$, a new domain-specific language (DSL)
implementation for
writing MPC{s}. Wys$^*$ is a
\emph{Verified, Domain-Specific Integrated Language Extension}
(VDSILE), a new kind of embedded DSL hosted in F$^*$, a
full-featured, verification-oriented programming language.
Wys$^*$ source programs are
essentially F$^*$ programs written against an MPC library, meaning
that the programmers can use F$^*$'s logic to verify the correctness
and security properties of their programs. To reason about the
distributed semantics of these programs, we formalize a deep
embedding of Wys$^*$, also in F$^*$. We mechanize the necessary
metatheory to prove that the properties verified for the Wys$^*$
source programs carry over to the distributed, multi-party
semantics. Finally, we use F$^*$'s extraction mechanism to
extract an interpreter that we have proved matches this semantics,
yielding a verified implementation. Indeed, Wys$^*$ is the first
DSL to enable formal verification of source MPC programs, and also the
first MPC DSL to provide a verified implementation.
With Wys$^*$ we have implemented several MPC protocols, including
private set intersection, joint median, and an MPC-based card dealing
application, and have verified their security and correctness.
},
  institution = {CoRR},
  number = {abs/1711.06467},
  year = {2017},
  url = {https://arxiv.org/abs/1711.06467},
  archiveprefix = {arXiv},
  eprint = {1711.06467},
  month = nov,
  category = {Security}
}
</pre>

<a name="mardziel14timeTR"></a><pre>
@techreport{<a href="mwhSecurity.html#mardziel14timeTR">mardziel14timeTR</a>,
  author = {Piotr Mardziel and Mario Alvim and Michael Hicks and Michael Clarkson},
  title = {Quantifying Information Flow for Dynamic Secrets (extended version)},
  abstract = {
  A metric is proposed for quantifying leakage of information about
  secrets and about how secrets change over time.
  The metric is used with a model of information flow for
  probabilistic, interactive systems with adaptive adversaries.
  The model and metric are implemented in a probabilistic programming
  language and used to analyze several examples. 
  The analysis demonstrates that adaptivity increases the amount of
  information that adversaries learn.
  },
  institution = {Department of Computer Science, the University of Maryland, College Park},
  number = {CS-TR-5035},
  category = {Security},
  month = may,
  year = 2014,
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/qif-dynamic-secrets-tr.pdf">http://www.cs.umd.edu/~mwh/papers/qif-dynamic-secrets-tr.pdf</a>}
}
</pre>

<a name="rastogi14wysteriaTR"></a><pre>
@techreport{<a href="mwhSecurity.html#rastogi14wysteriaTR">rastogi14wysteriaTR</a>,
  author = {Aseem Rastogi and Matthew A. Hammer and Michael Hicks},
  title = {Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty Computations (extended version)},
  institution = {Department of Computer Science, the University of Maryland, College Park},
  number = {CS-TR-5034},
  abstract = {
In a Secure Multiparty Computation (SMC), mutually distrusting parties use cryptographic techniques to cooperatively compute over their private data; in the process each party learns only explicitly revealed outputs. In this paper, we present Wysteria, a high-level programming language for writing SMCs. As with past languages, like Fairplay, Wysteria compiles secure computations to circuits that are executed by an underlying engine. Unlike past work, Wysteria provides support for mixed-mode programs, which combine local, private computations with synchronous SMCs. Wysteria complements a standard feature set with built-in support for secret shares and with wire bundles, a new abstraction that supports generic n-party computations. We have formalized Wysteria, its refinement type system, and its operational semantics. We show that Wysteria programs have an easy-to-understand single-threaded interpretation and prove that this view corresponds to the actual multi-threaded semantics. We also prove type soundness, a property we show has security ramifications, namely that information about one party's data can only be revealed to another via (agreed upon) secure computations. We have implemented Wysteria, and used it to program a variety of interesting SMC protocols from the literature, as well as several new ones. We find that Wysteria's performance is competitive with prior approaches while making programming far easier, and more trustworthy.
  },
  month = may,
  year = 2014,
  category = {Security},
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/wysteria-tr.pdf">http://www.cs.umd.edu/~mwh/papers/wysteria-tr.pdf</a>}
}
</pre>

<a name="mardziel11beliefTR"></a><pre>
@techreport{<a href="mwhSecurity.html#mardziel11beliefTR">mardziel11beliefTR</a>,
  title = {Dynamic Enforcement of Knowledge-based Security Policies},
  author = {Piotr Mardziel and Stephen Magill and Michael Hicks and Mudhakar Srivatsa},
  number = {CS-TR-4978},
  institution = {University of Maryland Department of Computer Science},
  abstract = {
  This paper explores the idea of \emph{knowledge-based security
    policies}, which are used to decide whether to answer queries over
  secret data based on an estimation of the querier's (possibly
  increased) knowledge given the results.  Limiting knowledge is the
  goal of existing information release policies that employ mechanisms
  such as noising, anonymization, and redaction.  Knowledge-based
  policies are more general: they increase flexibility by not fixing
  the means to restrict information flow.  We enforce a
  knowledge-based policy by explicitly tracking a model of a querier's
  belief about secret data, represented as a probability distribution,
  and denying any query that could increase knowledge above a given
  threshold.  We implement query analysis and belief tracking via
  abstract interpretation using a novel 
  \emph{probabilistic polyhedral} domain, whose design permits trading off
  precision with performance while ensuring estimates of a querier's
  knowledge are sound.  Experiments with our implementation show that
  several useful queries can be handled efficiently, and performance
  scales far better than would more standard implementations of
  probabilistic computation based on sampling.
  },
  year = 2011,
  month = jul,
  note = {Extended version with proofs and additional benchmarks},
  category = {Security},
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/beliefpolTR.pdf">http://www.cs.umd.edu/~mwh/papers/beliefpolTR.pdf</a>}
}
</pre>

<a name="swamy07fableTR"></a><pre>
@techreport{<a href="mwhSecurity.html#swamy07fableTR">swamy07fableTR</a>,
  author = {Nikhil Swamy and Brian J. Corcoran and Michael Hicks},
  institution = {University of Maryland, Department of Computer Science},
  number = {CS-TR-4895},
  title = {Fable: A Language for Enforcing User-defined Security Policies},
  year = 2007,
  month = nov,
  abstract = {
This paper presents Fable, a core formalism for a programming language
in which programmers may specify security policies and reason that
these policies are properly enforced. In Fable,
security policies can be expressed by associating \emph{security
labels} with the data or actions they protect. Programmers define the
semantics of labels in a separate part of the program called the
\emph{enforcement policy}. Fable prevents a policy from being circumvented
by allowing labeled terms to be manipulated only within the enforcement
policy; application code must treat labeled values abstractly.
Together, these features
facilitate straightforward proofs that programs implementing a
particular policy achieve their high-level security goals.  Fable is
flexible enough to implement a wide variety of security policies,
including access control, information flow, provenance, and security
automata. We have implemented Fable as part of the Links web
programming language; we call the resulting language SELinks.  We
report on our experience using SElinks to build two substantial
applications, a wiki and an on-line store, equipped with a combination of
access control and provenance policies.
 To our knowledge, no existing framework enables
the enforcement of such a wide variety of security policies with an
equally high level of assurance.
        },
  note = {Full version of Oakland 08 paper},
  url = {<a href="http://www.cs.umd.edu/~nswamy/papers/fable-tr.pdf">http://www.cs.umd.edu/~nswamy/papers/fable-tr.pdf</a>},
  category = {Security}
}
</pre>

<a name="swamy08airTR"></a><pre>
@techreport{<a href="mwhSecurity.html#swamy08airTR">swamy08airTR</a>,
  author = {Nikhil Swamy and Michael Hicks},
  institution = {University of Maryland, Department of Computer Science},
  number = {CS-TR-4906},
  title = {Verified Enforcement of Automaton-based Information Release Policies},
  mon = jun,
  abstract = {
  Many organizations specify \emph{information release} policies to
  describe the terms under which sensitive information may be released
  to other organizations.  This paper presents a new approach for
  ensuring that security-critical software correctly enforces its
  information release policy.  Our approach has two parts.  First, an
  information release policy is specified as a security automaton
  written in a new language called AIR.  Second, we enforce an AIR
  policy by translating it into an API for programs written in Lair,
  a core formalism for a functional programming language. Lair uses
  a novel combination of dependent, affine, and singleton types to
  ensure that the API is used correctly. As a consequence we can
  certify that programs written in Lair meet the requirements of
  the original AIR policy specification.
  },
  year = 2008,
  note = {Full version of PLAS 08 paper},
  url = {<a href="http://www.cs.umd.edu/~nswamy/papers/lair-tr.pdf">http://www.cs.umd.edu/~nswamy/papers/lair-tr.pdf</a>},
  category = {Security}
}
</pre>

<a name="petroni07sbcfitr"></a><pre>
@techreport{<a href="mwhSecurity.html#petroni07sbcfitr">petroni07sbcfitr</a>,
  author = {Petroni, Jr., Nick L. and Michael Hicks},
  title = {Automated Detection of Persistent Kernel Control-Flow Attacks},
  institution = {Department of Computer Science, University of Maryland},
  number = {CS-TR-4880},
  month = oct,
  abstract = {
This paper presents a new approach to dynamically monitoring operating
system kernel integrity, based on a property called \emph{state-based
control-flow integrity} (SBCFI).  Violations of SBCFI signal a
persistent, unexpected modification of the kernel's control-flow
graph.  We performed a thorough analysis of 25 Linux rootkits and
found that 24 (96\%) employ persistent control-flow modifications; an
informal study of Windows rootkits yielded similar results.  We have
implemented SBCFI enforcement as part of the Xen and VMware virtual
machine monitors.  Our implementation detected all the control-flow
modifying rootkits we could install, while imposing negligible
overhead for both a typical web server workload and CPU-intensive
workloads when operating at 1 second intervals on a multi-core machine.
},
  note = {Extends the CCS 2007 paper with more thorough performance results},
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/CS-TR-4880.pdf">http://www.cs.umd.edu/~mwh/papers/CS-TR-4880.pdf</a>},
  year = 2007,
  category = {Security}
}
</pre>

<a name="hicks07xdomtr"></a><pre>
@techreport{<a href="mwhSecurity.html#hicks07xdomtr">hicks07xdomtr</a>,
  author = {Michael Hicks and Nikhil Swamy and Simon Tsang},
  title = {Toward Specifying and Validating Cross-Domain Policies},
  institution = {Department of Computer Science, University of Maryland},
  number = {CS-TR-4870},
  year = 2007,
  month = apr,
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/xdom-tr.pdf">http://www.cs.umd.edu/~mwh/papers/xdom-tr.pdf</a>},
  abstract = {
Formal security policies are extremely useful for two related reasons.
First, they allow a policy to be considered in isolation, separate
from programs under the purview of the policy and separate from the
implementation of the policy's enforcement.  Second, policies can be
checked for compliance against higher-level security goals by using
automated analyses.  By contrast, ad hoc enforcement mechanisms (for
which no separate policies are specified) enjoy neither benefit, and
non-formal policies enjoy the first but not the second.

We would like to understand how best to define
(and enforce) multi-level security policies when information must be
shared across domains that have varying levels of trust (the so-called
``cross domain'' problem).  Because we wish to show such policies meet
higher-level security goals with high assurance, we are interested in
specifying cross domain policies formally, and then reasoning about
them using automated tools.  In this report, we briefly survey
work that presents formal security policies with cross-domain
concerns, in particular with respect to the problem of
\emph{downgrading}.  We also describe correctness properties for such
policies, all based on \emph{noninterference}.  Finally, we briefly
discuss recently-developed tools for analyzing formal security
policies; though no existing tools focus on the analysis of
downgrading-oriented policies, existing research points the way
to providing such support.
},
  category = {Security}
}
</pre>

<a name="hicks06trustedtr"></a><pre>
@techreport{<a href="mwhSecurity.html#hicks06trustedtr">hicks06trustedtr</a>,
  title = {Trusted Declassification: high-level policy for a security-typed language (Extended version)},
  author = {Boniface Hicks and Dave King and Patrick McDaniel and Michael Hicks},
  abstract = {
  Security-typed languages promise to be a powerful tool with which
  provably secure software applications may be developed.  Programs
  written in these languages enforce a strong, global policy of
  \emph{noninterference} which ensures that high-security data will
  not be observable on low-security channels.  Because noninterference
  is typically too strong a property, most programs use some form of
  \emph{declassification} to selectively leak high security information,
  e.g. when performing a password check or data encryption.
  Unfortunately, such a declassification is often expressed as an
  operation within a given program, rather than as part of a global
  policy, making reasoning about the security implications of a policy
  more difficult.

  In this paper, we propose a simple idea we call \textit{trusted
  declassification} in which special \emph{declassifier} functions are
  specified as part of the global policy.  In particular, individual
  principals declaratively specify which declassifiers they trust so
  that all information flows implied by the policy can be reasoned
  about in absence of a particular program.  We formalize our approach
  for a Java-like language and prove a modified form of
  noninterference which we call \emph{noninterference modulo trusted methods}.  We have implemented
  our approach as an extension to Jif and provide some of our
  experience using it to build a secure e-mail client.
},
  institution = {Department of Computer Science and Engineering, the Pennsylvania State University},
  number = {NAS-TR-033-2006},
  note = {Extended version of the PLAS 2006 paper with full formal development},
  month = {June},
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/plas06-tr.pdf">http://www.cs.umd.edu/~mwh/papers/plas06-tr.pdf</a>},
  category = {Security},
  year = 2006
}
</pre>

<a name="swamy06rxtr"></a><pre>
@techreport{<a href="mwhSecurity.html#swamy06rxtr">swamy06rxtr</a>,
  title = {Managing Policy Updates in Security-Typed Languages (Extended version)},
  author = {Nikhil Swamy and Michael Hicks and Stephen Tse and Steve Zdancewic},
  abstract = {
This paper presents RX, a new security-typed
programming language with features intended to make the management of
information-flow policies more practical.  Security labels in RX,
in contrast to prior approaches, are defined in terms of \emph{owned
roles}, as found in the RT role-based trust-management framework.
Role-based security policies allows flexible delegation, and our
language RX provides constructs through which programs can robustly
update policies and react to policy updates dynamically.  Our dynamic
semantics use statically verified \emph{transactions} to eliminate
illegal information flows across updates, which we call
\emph{transitive flow}.  Because policy updates can be observed
through dynamic queries, policy updates can potentially reveal
sensitive information.  As such, RX considers policy statements
themselves to be potentially confidential information and subject to
information-flow \emph{metapolicies}.
},
  institution = {Department of Computer Science, University of Maryland},
  number = {CS-TR-4793},
  month = {August},
  year = 2006,
  note = {Extends CSFW version to include full proofs and additional
discussion about metapolicies},
  url = {<a href="http://www.cs.umd.edu/~mwh/papers/rx-tr.pdf">http://www.cs.umd.edu/~mwh/papers/rx-tr.pdf</a>},
  http = {<a href="http://www.cs.umd.edu/projects/PL/rx/">http://www.cs.umd.edu/projects/PL/rx/</a>},
  category = {Security}
}
</pre>

<a name="Hicks98"></a><pre>
@techreport{<a href="mwhSecurity.html#Hicks98">Hicks98</a>,
  author = {Michael Hicks},
  title = {{PLAN} System Security},
  institution = {Department of Computer and Information Science, University of Pennsylvania},
  type = {Technical Report},
  number = {MS-CIS-98-25},
  month = {April},
  year = {1998},
  url = {<a href="http://www.cis.upenn.edu/~switchware/papers/plan_security.ps">http://www.cis.upenn.edu/~switchware/papers/plan_security.ps</a>},
  category = {Security}
}
</pre>

<hr><p><em>This file was generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.99.</em></p>
