<font size="+1"><b>The SwitchWare Active Network Architecture</b>.
  D.&nbsp;Scott Alexander, William&nbsp;A. Arbaugh, Michael Hicks, Pankaj Kakkar,
  Angelos Keromytis, Jonathan&nbsp;T. Moore, Carl&nbsp;A. Gunter, Scott&nbsp;M. Nettles, and
  Jonathan&nbsp;M. Smith.
  <i>IEEE Network Magazine</i>, 12(3):29-36, 1998.
  Special issue on Active and Controllable Networks.</font><p><p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/switchware.ps">.ps</a> ]
<a name="AlexanderAHKKMGNS98"></a><pre>
@ARTICLE{AlexanderAHKKMGNS98,
  AUTHOR = {D. Scott Alexander and William A. Arbaugh and Michael Hicks and Pankaj Kakkar and Angelos Keromytis and Jonathan T. Moore and Carl A. Gunter and Scott M. Nettles and Jonathan M. Smith},
  TITLE = {The {SwitchWare} Active Network Architecture},
  JOURNAL = {{IEEE Network Magazine}},
  VOLUME = 12,
  NUMBER = 3,
  YEAR = 1998,
  PAGES = {29-36},
  NOTE = {{Special issue on Active and Controllable Networks}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>The SwitchWare Active Network Implementation</b>.
  D.&nbsp;Scott Alexander, Michael&nbsp;W. Hicks, Pankaj Kakkar, Angelos&nbsp;D.
  Keromytis, Marianne Shaw, Jonathan&nbsp;T. Moore, Carl&nbsp;A. Gunter, Trevor Jim,
  Scott&nbsp;M. Nettles, and Jonathan&nbsp;M. Smith.
  In <i>Notes of the ACM SIGPLAN Workshop on ML</i>, pages 67-76,
  September 1998.</font><p><p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/ml.ps">.ps</a> ]
<a name="AlexanderHKKSMGJNS98"></a><pre>
@INPROCEEDINGS{AlexanderHKKSMGJNS98,
  AUTHOR = {D. Scott Alexander and Michael W. Hicks and Pankaj
		  Kakkar and Angelos D. Keromytis and Marianne Shaw
		  and Jonathan T. Moore and Carl A. Gunter and Trevor
		  Jim and Scott M. Nettles and Jonathan M. Smith},
  TITLE = {{The SwitchWare Active Network Implementation}},
  BOOKTITLE = {Notes of the {ACM} {SIGPLAN} Workshop on {ML}},
  MONTH = {September},
  YEAR = 1998,
  PAGES = {67--76}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Scalable Resource Control in Active Networks</b>.
  Kostas&nbsp;G. Anagnostakis, Michael&nbsp;W. Hicks, Sotiris Ioannidis,
  Angelos&nbsp;D. Keromytis, and Jonathan&nbsp;M. Smith.
  In Hiroshi Yashuda, editor, <i>Proceedings of the Second
  International Working Conference on Active Networks (IWAN)</i>, volume 1942 of
  <i>Lecture Notes in Computer Science</i>, pages 343-358. Springer-Verlag,
  October 2000.</font><p>
The increased complexity of the service model relative to store-and-forward
routers, has made resource management one of the paramount concerns in
active networking research and engineering. Previous work investigated
methods for controlling access to resources by restricting namespaces
or providing limited functionality in a domain-specific language.
Combinations of these methods and scheduling technologies have also been used
to demonstrate a resource-managed node architecture. In this paper, we address
Two major challenges in scaling resource management to many-node active
networks.  The first is the use of market mechanisms and trading amongst nodes
and programs with varying degrees of competition and cooperation to provide a
scalable approach to managing active network resources. The second is the use
of a trust-management architecture to ensure that the participants in the
resource management marketplace have a policy-driven ``rule of law''
in which marketplace decisions can be made and relied upon. We have used
lottery scheduling and the Keynote trust-management system for our
implementation, for which we provide some initial performance indications.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/keynote-market.ps">.ps</a> ]
<a name="AnagnostakisHIKS00"></a><pre>
@INPROCEEDINGS{AnagnostakisHIKS00,
  AUTHOR = {Kostas G. Anagnostakis and Michael W. Hicks and Sotiris Ioannidis and Angelos D. Keromytis and Jonathan M. Smith},
  TITLE = {Scalable Resource Control in Active Networks},
  BOOKTITLE = {Proceedings of the Second International Working Conference on
Active Networks (IWAN)},
  MONTH = {October},
  YEAR = 2000,
  PUBLISHER = {Springer-Verlag},
  EDITOR = {Hiroshi Yashuda},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = 1942,
  PAGES = {343--358}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Formalizing Dynamic Software Updating</b>.
  Gavin Bierman, Michael Hicks, Peter Sewell, and Gareth Stoyle.
  In <i>On-line Proceedings of the Second International Workshop on
  Unanticipated Software Evolution (USE)</i>, April 2003.
 
  <A HREF="http://www.informatik.uni-bonn.de/~gk/use/2003/Papers/papers.html">http://www.informatik.uni-bonn.de/~gk/use/2003/Papers/papers.html</A>.</font><p>
Dynamic software updating (DSU) enables running programs to be updated with
new code and data without interrupting their execution.  A number of DSU
systems have been designed, but there is still little rigorous understanding
of how to use DSU technology so that updates are safe.  As a first step in
this direction, we introduce a small <em>update calculus</em> with a precise
mathematical semantics.  The calculus is formulated as an extension of a
typed lambda calculus, and supports updating technology similar to
that of the programming language Erlang.  Our goal
is to provide a simple yet expressive foundation for reasoning about
dynamically updateable software.  In this paper, we present the details of
the calculus, give some examples of its expressive power, and discuss how
it might be used or extended to guarantee safety properties.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/formalUpdate.pdf">.pdf</a> ]
<a name="BiermanHSS03"></a><pre>
@INPROCEEDINGS{BiermanHSS03,
  AUTHOR = {Gavin Bierman and Michael Hicks and Peter Sewell and Gareth Stoyle},
  TITLE = {Formalizing Dynamic Software Updating},
  BOOKTITLE = {On-line Proceedings of the Second International Workshop on Unanticipated Software Evolution (USE)},
  MONTH = {April},
  YEAR = {2003},
  NOTE = {\url{http://www.informatik.uni-bonn.de/~gk/use/2003/Papers/papers.html}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Rebinding for Marshalling and Update with Destruct-time
  <EM>lambda</EM></b>.
  Gavin Bierman, Michael Hicks, Peter Sewell, Gareth Stoyle, and Keith
  Wansbrough.
  In <i>Proceedings of the ACM International Conference on
  Functional Programming (ICFP)</i>, pages 99-110, August 2003.</font><p>
Most programming languages adopt static binding, but for distributed
programming an exclusive reliance on static binding is too
restrictive: dynamic binding is required in various guises.  Typically
it is provided only by ad-hoc mechanisms that lack clean semantics.
In this paper we adopt a more foundational approach, showing how core
dynamic rebinding mechanisms can be added to a CBV <EM>lambda</EM>-calculus.
To do so we first develop two refinements of the CBV reduction
strategy with delayed instantiation, the <em>redex-time</em> and
<em>destruct-time</em> semantics.  Delayed instantiation ensures we
obtain the most recent version of a definition following a rebinding.
The destruct-time semantics gives the basis for a <EM>lambda</EM>_marsh calculus
that supports dynamic rebinding, with primitives to package values and
<em>marks</em> to control which identifiers are dynamically rebound when
they are unpackaged.  We extend <EM>lambda</EM>_marsh with concurrency and
communication, giving examples showing how wrappers for encapsulating
untrusted code can be expressed, and discuss the extent to which it
can be statically typed.  Finally, we use the destruct-time semantics
also as a basis for a <EM>lambda</EM>_update calculus with simple primitives to
provide type-safe, dynamic updating of code.  We thereby put a variety
of real-world mechanisms on a common semantic foundation.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dynbind2-short.pdf">.pdf</a> ]
<a name="BiermanHSSW03"></a><pre>
@INPROCEEDINGS{BiermanHSSW03,
  AUTHOR = {Gavin Bierman and Michael Hicks and Peter Sewell and Gareth Stoyle and Keith Wansbrough},
  TITLE = {Dynamic Rebinding for Marshalling and Update with Destruct-time $\lambda$},
  BOOKTITLE = {Proceedings of the {ACM} International Conference on Functional Programming (ICFP)},
  MONTH = {August},
  YEAR = {2003},
  PAGES = {99--110},
  WHERE = {Uppsala, Sweden}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Safe and Flexible Dynamic Linking of Native Code</b>.
  Michael Hicks, Stephanie Weirich, and Karl Crary.
  In Robert Harper, editor, <i>Proceedings of the ACM SIGPLAN
  Workshop on Types in Compilation (TIC)</i>, volume 2071 of <i>Lecture Notes in
  Computer Science</i>. Springer-Verlag, September 2000.</font><p>
  We present the design and implementation of the first complete framework
  for flexible and safe dynamic linking of native code.  Our approach
  extends Typed Assembly Language with a primitive for loading and
  typechecking code, which is flexible enough to support a variety of
  linking strategies, but simple enough that it does not significantly
  expand the trusted computing base.  Using this primitive, along with the
  ability to compute with types, we show that we can <i>program</i> many
  existing dynamic linking approaches.  As a concrete demonstration, we have
  used our framework to implement dynamic linking for a type-safe dialect of
  C, closely modeled after the standard linking facility for Unix C
  programs.  Aside from the unavoidable cost of verification, our
  implementation performs comparably with the standard, untyped approach.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/taldynlink.pdf">.pdf</a> ]
<a name="CraryHW00"></a><pre>
@INPROCEEDINGS{CraryHW00,
  AUTHOR = {Michael Hicks and Stephanie Weirich and Karl Crary},
  TITLE = {Safe and Flexible Dynamic Linking of Native Code},
  MONTH = {September},
  YEAR = 2000,
  BOOKTITLE = {Proceedings of the {ACM} {SIGPLAN} Workshop on Types in Compilation (TIC)},
  VOLUME = {2071},
  PUBLISHER = {Springer-Verlag},
  EDITOR = {Robert Harper},
  SERIES = {Lecture Notes in Computer Science}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Region-based Memory Management in Cyclone</b>.
  Dan Grossman, Greg Morrisett, Trevor Jim, Michael Hicks, Yanling
  Wang, and James Cheney.
  In <i>Proceedings of the ACM Conference on Programming Language
  Design and Implementation (PLDI)</i>, pages 282-293. ACM, June 2002.</font><p>
  Cyclone is a polymorphic, type-safe programming language derived
  from C.  The primary design goals of Cyclone are to let
  programmers control data representations and memory management
  without sacrificing type-safety.  In this paper, we focus on the
  region-based memory management of Cyclone and its static typing
  discipline.  The design incorporates several advancements, including
  support for region subtyping and a coherent integration with stack
  allocation and a garbage collector.  To support separate
  compilation, Cyclone requires programmers to write some explicit
  region annotations, but uses a combination of default annotations,
  local type inference, and a novel treatment of region effects to
  reduce this burden.  As a result, we integrate C idioms in a
  region-based framework.  In our experience, porting legacy C to
  Cyclone has required altering about 8% of the code; of the
  changes, only 6% (of the 8%) were region annotations.
  <p>[ <a href="http://cyclone.thelanguage.org">http</a> | 
<a href="http://www.cs.cornell.edu/projects/cyclone/papers/cyclone-regions.pdf">.pdf</a> ]
<a name="GrossmanMJHWC02"></a><pre>
@INPROCEEDINGS{GrossmanMJHWC02,
  AUTHOR = {Dan Grossman and Greg Morrisett and Trevor Jim and Michael Hicks and Yanling Wang and James Cheney},
  TITLE = {Region-based Memory Management in {C}yclone},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Programming Language Design and Implementation (PLDI)},
  MONTH = {June},
  WHERE = {Berlin, Germany},
  PAGES = {282--293},
  PUBLISHER = {{ACM}},
  YEAR = 2002,
  HTTP = {<a href="http://cyclone.thelanguage.org">http://cyclone.thelanguage.org</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Formal Type Soundness for Cyclone's Region System</b>.
  Dan Grossman, Greg Morrisett, Trevor Jim, Michael Hicks, Yanling
  Wang, and James Cheney.
  Technical Report CS 2001-1856, Cornell University, November 2001.</font><p><p>[ <a href="http://www.cs.umd.edu/~mwh/papers/cyclone_regions_tr.pdf">.pdf</a> ]
<a name="GrossmanMJHWC02tr"></a><pre>
@TECHREPORT{GrossmanMJHWC02tr,
  AUTHOR = {Dan Grossman and Greg Morrisett and Trevor Jim and Michael Hicks and Yanling Wang and James Cheney},
  TITLE = {Formal Type Soundness for {Cyclone}'s Region System},
  NUMBER = {CS 2001-1856},
  MONTH = NOV,
  YEAR = 2001,
  INSTITUTION = {Cornell University}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Software Updating</b>.
  Michael Hicks.
  PhD thesis, Department of Computer and Information Science,
  University of Pennsylvania, August 2001.
  Winner of the 2002 ACM SIGPLAN Doctoral Dissertation award.</font><p><p>[ <a href="http://www.cs.umd.edu/~mwh/papers/thesis.pdf">.pdf</a> ]
<a name="Hicks01"></a><pre>
@PHDTHESIS{Hicks01,
  AUTHOR = {Michael Hicks},
  TITLE = {Dynamic Software Updating},
  YEAR = 2001,
  MONTH = {August},
  SCHOOL = {Department of Computer and Information Science, University of Pennsylvania},
  NOTE = {Winner of the 2002 {ACM SIGPLAN Doctoral Dissertation} award}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>PLAN System Security</b>.
  Michael Hicks.
  Technical Report MS-CIS-98-25, Department of Computer and Information
  Science, University of Pennsylvania, April 1998.</font><p><p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/plan_security.ps">.ps</a> ]
<a name="Hicks98"></a><pre>
@TECHREPORT{Hicks98,
  AUTHOR = {Michael Hicks},
  TITLE = {{PLAN} System Security},
  INSTITUTION = {Department of Computer and Information Science, University of Pennsylvania},
  TYPE = {Technical Report},
  NUMBER = {MS-CIS-98-25},
  MONTH = {April},
  YEAR = {1998}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Types and Intermediate Representations</b>.
  Michael Hicks.
  Technical Report MS-CIS-98-05, Department of Computer and Information
  Science, University of Pennsylvania, April 1998.</font><p>The design objectives and the mechanisms for achieving those
objectives are considered for each of three systems, Java, Erlang, and
TIL. In particular, I examine the use of types and intermediate
representations in the system implementation. In addition, the systems
are compared to examine how one system's mechanisms may (or may not)
be applied to another.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/typedIR.ps">.ps</a> ]
<a name="Hicks98A"></a><pre>
@TECHREPORT{Hicks98A,
  AUTHOR = {Michael Hicks},
  TITLE = {{Types and Intermediate Representations}},
  INSTITUTION = {Department of Computer and Information Science, University of Pennsylvania},
  TYPE = {Technical Report},
  NUMBER = {MS-CIS-98-05},
  MONTH = {April},
  YEAR = {1998}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A Study of Large Object Spaces</b>.
  Michael Hicks, Luke Hornof, Jonathan&nbsp;T. Moore, and Scott Nettles.
  In <i>Proceedings of the ACM International Symposium on Memory
  Management (ISMM)</i>, pages 138-145. ACM, October 1998.</font><p>
This paper examines the design space for copying garbage collectors
(GCs) in which ``large objects'' are managed in a separate,
non-copy-collected space. We focus on two main issues:
<p><ol>
<li> how to set the policy for classifying objects as ``large''
<li> how to manage the large object space
</ol>
We explore these issues experimentally using the Oscar GC testbed. In
particular, we vary the threshold size of large objects and also
whether the objects may contain pointers. Furthermore, we compare the
performance of treadmill collection to that of mark-and-sweep
collection for managing the large object space.<P>
We find that for some heaps there is a minimum cutoff size below which
adding objects to the large object space does not result in a
performance improvement, while for others no such cutoff exists.  In
general, including pointer-containing objects in the large object
space seems beneficial.  Finally, the exact method used to collect the
large object space does not significantly influence overall
performance.
<p>[ <a href="http://www.cis.upenn.edu/~oscar/ismm98.ps">.ps</a> ]
<a name="HicksHMN98"></a><pre>
@INPROCEEDINGS{HicksHMN98,
  AUTHOR = {Michael Hicks and Luke Hornof and Jonathan T. Moore
  and Scott Nettles},
  TITLE = {A Study of Large Object Spaces},
  BOOKTITLE = {Proceedings of the {ACM} International Symposium on Memory Management (ISMM)},
  PAGES = {138--145},
  YEAR = 1998,
  PUBLISHER = {{ACM}},
  MONTH = {October}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Transparent Communication for Distributed Objects in Java</b>.
  Michael Hicks, Suresh Jagannathan, Richard Kelsey, Jonathan&nbsp;T. Moore,
  and Cristian Ungureanu.
  In <i>Proceedings of the ACM SIGPLAN Java Grande Conference</i>,
  pages 160-170. ACM, June 1999.</font><p>
We describe a native-code implementation of Java that supports distributed
objects. In order to foster the correctness of distributed programs, remote
access is syntactically and semantically indistinguishable from local
access. This transparency is provided by the runtime system through the
implicit generation of remote references to an object when it is passed as
an argument or returned from a remote method call. Consistency is achieved
through the use of a distributed (and thus scalable) global addressing
scheme.  Experiments show that application performance is a function of data
layout, access algorithm, and local workload. For distributed applications,
such as distributed databases, these factors may not be known statically,
suggesting the importance of runtime support.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/java99.ps">.ps</a> ]
<a name="HicksJKMU99"></a><pre>
@INPROCEEDINGS{HicksJKMU99,
  AUTHOR = {Michael Hicks and Suresh Jagannathan and Richard
		  Kelsey and Jonathan T. Moore and Cristian Ungureanu},
  TITLE = {Transparent Communication for Distributed Objects in {Java}},
  BOOKTITLE = {Proceedings of the {ACM} {SIGPLAN} Java Grande Conference},
  MONTH = {June},
  YEAR = 1999,
  PUBLISHER = {ACM},
  PAGES = {160--170}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A Secure PLAN</b>.
  Michael Hicks and Angelos&nbsp;D. Keromytis.
  In Stefan Covaci, editor, <i>Proceedings of the First International
  Working Conference on Active Networks (IWAN)</i>, volume 1653 of <i>Lecture
  Notes in Computer Science</i>, pages 307-314. Springer-Verlag, June 1999.
  Reprinted with extensions in DARPA Active Networks Conference and
  Exposition (DANCE) and IEEE Transactions on Systems, Man, and Cybernetics,
  Part C.</font><p>
Active Networks promise greater flexibility than current networks, but
threaten safety and security by virtue of their programmability. In this
paper, we describe the design and implementation of a security architecture
for the active network <i>PLANet</i>.  Security is obtained
with a two-level architecture that combines a functionally restricted packet
language, PLAN, with an environment of general-purpose
service routines governed by <i>trust management</i>.  In
particular, we employ a technique which expands or contracts a packet's
service environment based on its level of privilege, termed <i>
namespace-based security</i>.  As an application of our security architecture,
we present the design and implementation of an active-network firewall. We
find that the addition of the firewall imposes around a 30 percent latency
overhead, and as little as a 6.7 percent space overhead to incoming packets.
  <p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/iwan99.ps">.ps</a> ]
<a name="HicksK99"></a><pre>
@INPROCEEDINGS{HicksK99,
  AUTHOR = {Michael Hicks and Angelos D. Keromytis},
  TITLE = {A Secure {PLAN}},
  BOOKTITLE = {Proceedings of the First International Working Conference on
		  Active Networks (IWAN)},
  MONTH = {June},
  YEAR = 1999,
  PUBLISHER = {Springer-Verlag},
  EDITOR = {Stefan Covaci},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = 1653,
  PAGES = {307--314},
  NOTE = {Reprinted with extensions in {DARPA} Active Networks Conference and Exposition (DANCE) and IEEE Transactions on Systems, Man, and Cybernetics, Part C}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>PLAN: A Packet Language for Active Networks (Extended version)</b>.
  Michael&nbsp;W. Hicks, Pankaj Kakkar, Jonathan&nbsp;T. Moore, Carl&nbsp;A. Gunter,
  and Scott&nbsp;M. Nettles.
  Unpublished manuscript. Consolidates ICFP 98, IPL 98, Allterton 99
  papers, May 2006.</font><p>
The Internet protocols were designed to emphasize simple rout-
ing elements and intelligent hosts. However, there are applications
that benefit from allowing hosts to customize or program routers, a
concept known as active networking. Since routers are shared, this
raises challenges with delivering sufficient flexibility while preserving
or improving performance, security, and safety. PLAN (Packet Lan-
guage for Active Networks) is a language designed for the SwitchWare
active network architecture. This architecture comprises active pack-
ets containing PLAN programs that invoke service routines over an
active OS. PLAN is based on the polymorphic lambda calculus and
provides a restricted set of primitives and datatypes that enables rea-
soning about its impact on network resources based on features of the
language design. This paper focuses on the PLAN language with the
aim of consolidating a variety of studies that were carried out in the
years after its introduction in 1998. These studies include the require-
ments for PLAN, its design, programming in PLAN, the specification
and theory of PLAN, and its use in networking applications.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/plan-extended.pdf">.pdf</a> ]
<a name="HicksKMGN06"></a><pre>
@UNPUBLISHED{HicksKMGN06,
  AUTHOR = {Michael W. Hicks and Pankaj Kakkar and Jonathan T. Moore and Carl A. Gunter and Scott M. Nettles},
  TITLE = {{PLAN}: A Packet Language for Active Networks (Extended version)},
  MONTH = {May},
  YEAR = 2006,
  NOTE = {Unpublished manuscript.  Consolidates ICFP 98, IPL 98, Allterton 99 papers}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>PLAN: A Packet Language for Active Networks</b>.
  Michael Hicks, Pankaj Kakkar, Jonathan&nbsp;T. Moore, Carl&nbsp;A. Gunter, and
  Scott Nettles.
  In <i>Proceedings of the Third ACM SIGPLAN International
  Conference on Functional Programming Languages (ICFP)</i>, pages 86-93. ACM,
  September 1998.</font><p>
PLAN (Packet Language for Active Networks) is a new language for
programs that form the packets of a programmable network.  These
programs replace the packet headers (which can be viewed as very
rudimentary programs) used in current networks.  As such, PLAN
programs are lightweight and of restricted functionality.  These
limitations are mitigated by allowing PLAN code to call node-resident
<i>service routines</i> written in other, more powerful languages.
This two-level architecture, in which PLAN serves as a scripting or
`glue' language for more general services, is the primary contribution
of this paper. We have successfully applied the PLAN programming
environment to implement an IP-free internetwork.<P>
PLAN is based on the simply typed lambda calculus and provides a
restricted set of primitives and datatypes.  PLAN defines a special
construct called a <i>chunk</i> used to describe the remote execution
of PLAN programs on other nodes. Primitive operations on chunks are
used to provide basic data transport in the network and to support
layering of protocols.  Remote execution can make debugging difficult,
so PLAN provides strong static guarantees to the programmer, such as
type safety.  A more novel property aimed at protecting network
availability is a guarantee that PLAN programs use a bounded amount of
network resources.<p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/plan.ps">.ps</a> ]
<a name="HicksKMGN98"></a><pre>
@INPROCEEDINGS{HicksKMGN98,
  AUTHOR = {Michael Hicks and Pankaj Kakkar and Jonathan T. Moore
  and Carl A. Gunter and Scott Nettles},
  TITLE = {{PLAN}: A Packet Language for Active Networks},
  BOOKTITLE = {Proceedings of the Third {ACM} {SIGPLAN} International Conference on Functional Programming Languages (ICFP)},
  MONTH = {September},
  YEAR = 1998,
  PAGES = {86--93},
  PUBLISHER = {ACM}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Network Programming Using PLAN</b>.
  Michael Hicks, Pankaj Kakkar, Jonathan&nbsp;T. Moore, Carl&nbsp;A. Gunter, and
  Scott Nettles.
  In Luca Cardelli, editor, <i>Proceedings of the IEEE Workshop on
  Internet Programming Languages</i>, volume 1686 of <i>Lecture Notes in
  Computer Science</i>, pages 127-143. Springer-Verlag, May 1998.</font><p>
We present here a methodology for programming active networks in the
environment defined by our new language PLAN (Packet Language for
Active Networks). This environment presumes a two-level architecture
consisting of:
<p><ol>
<li> <i>active packets</i> carrying PLAN code; and
<li> downloadable, node-resident <i>services</i> written in more
general-purpose languages.
</ol>
We present several examples which illustrate how these two features
can be combined to implement various network functions.<p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/progplan.ps">.ps</a> ]
<a name="HicksKMGN98ipl"></a><pre>
@INPROCEEDINGS{HicksKMGN98ipl,
  AUTHOR = {Michael Hicks and Pankaj Kakkar and Jonathan T. Moore
  and Carl A. Gunter and Scott Nettles},
  TITLE = {Network Programming Using {PLAN}},
  BOOKTITLE = {Proceedings of the {IEEE} Workshop on Internet Programming Languages},
  YEAR = 1998,
  MONTH = MAY,
  PUBLISHER = {Springer-Verlag},
  EDITOR = {Luca Cardelli},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = 1686,
  PAGES = {127--143}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A Secure PLAN</b>.
  Michael Hicks, Angelos&nbsp;D. Keromytis, and Jonathan&nbsp;M. Smith.
  <i>IEEE Transactions on Systems, Man, and Cybernetics, Part C</i>,
  33(3):413-426, August 2003.
  Special Issue on Technologies Promoting Computational Intelligence,
  Openness and Programmability in Networks and Internet Services, Part I.</font><p>
Active Networks, being programmable,
promise greater flexibility than current networks.
Programmability, however, may
introduce safety and security risks.
This paper describes the design and implementation of a security
architecture for the active network PLANet.
Security is obtained with a two-level architecture that combines a
functionally restricted packet language, PLAN, with
an environment of general-purpose service routines governed by trust
management.  In particular, a technique is used 
which expands or contracts a packet's service environment based on its
level of privilege, termed <i>namespace-based security</i>.
The design and implementation of an active-network firewall and virtual
private network is used as an application of the security architecture.
Measurements of the system show that the addition of the firewall imposes an
approximately 34% latency overhead and as little as a 6.7% space overhead
to incoming packets.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/plansecurity.pdf">.pdf</a> ]
<a name="HicksKS03"></a><pre>
@ARTICLE{HicksKS03,
  AUTHOR = {Michael Hicks and Angelos D. Keromytis and Jonathan M. Smith},
  TITLE = {A Secure {PLAN}},
  JOURNAL = {{IEEE Transactions on Systems, Man, and Cybernetics, Part C}},
  MONTH = {August},
  VOLUME = 33,
  NUMBER = 3,
  PAGES = {413--426},
  YEAR = 2003,
  NOTE = {Special Issue on Technologies Promoting Computational Intelligence, Openness and Programmability in Networks and {I}nternet Services, Part {I}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>PLANet: An Active Internetwork</b>.
  Michael Hicks, Jonathan&nbsp;T. Moore, D.&nbsp;Scott Alexander, Carl&nbsp;A. Gunter,
  and Scott Nettles.
  In <i>Proceedings of the Eighteenth IEEE Computer and
  Communication Society INFOCOM Conference</i>, pages 1124-1133. IEEE, March
  1999.</font><p>
We present <i>PLANet</i>: an active network architecture and
implementation.  In addition to a standard suite of Internet-like
services, PLANet has two key programmability features:
<p><ol>
<li> all packets contain programs
<li> router functionality may be extended dynamically
</ol>
Packet programs are written in our special purpose programming
language PLAN, the Packet Language for Active Networks, while dynamic
router extensions are written in OCaml, a dialect of ML.<P>
Currently, PLANet routers run as byte-code-interpreted Linux
user-space applications, and support Ethernet and IP as link layers.
PLANet achieves respectable performance on standard networking
operations: on 300&nbsp;MHz Pentium-II's attached to 100&nbsp;Mbps Ethernet,
PLANet can route 48&nbsp;Mbps and switch over 5000 packets per second.  We
demonstrate the utility of PLANet's activeness by showing
experimentally how it can non-trivially improve application and
aggregate network performance in congested conditions.<p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/planet.ps">.ps</a> ]
<a name="HicksMAGN99"></a><pre>
@INPROCEEDINGS{HicksMAGN99,
  AUTHOR = {Michael Hicks and Jonathan T. Moore and D. Scott Alexander
  and Carl A. Gunter and Scott Nettles},
  TITLE = {{PLANet}: An Active Internetwork},
  BOOKTITLE = {Proceedings of the Eighteenth {IEEE} Computer and
		  Communication Society {INFOCOM} Conference},
  MONTH = {March},
  YEAR = 1999,
  PUBLISHER = {{IEEE}},
  PAGES = {1124--1133}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Software Updating</b>.
  Michael Hicks, Jonathan&nbsp;T. Moore, and Scott Nettles.
  In <i>Proceedings of the ACM Conference on Programming Language
  Design and Implementation (PLDI)</i>, pages 13-23. ACM, June 2001.</font><p>
Many important applications must run continuously and without interruption,
yet must be changed to fix bugs or upgrade functionality.  No
prior general-purpose methodology for dynamic updating achieves a practical
balance between flexibility, robustness, low overhead, and ease of use.<P>
We present a new approach for C-like languages that provides type-safe
dynamic updating of native code in an extremely flexible manner (code, data,
and types may be updated, at programmer-determined times) and permits the
use of automated tools to aid the programmer in the updating process.  Our
system is based on <em>dynamic patches</em> that both contain the updated code
and the code needed to transition from the old version to the new.  A novel
aspect of our patches is that they consist of <em>verifiable native code</em>
(<em>e.g.</em> Proof-Carrying Code or Typed Assembly
Language, which is native code accompanied by
annotations that allow on-line verification of the code's safety.  We
discuss how patches are generated mostly automatically, how they are applied
using dynamic-linking technology, and how code is compiled to make it
updateable.<P>
To concretely illustrate our system, we have implemented a
dynamically-updateable web server, FlashEd.  We discuss our experience
building and maintaining FlashEd.  Performance experiments show that for
FlashEd, the overhead due to updating is typically less than 1 percent.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dyn_update.pdf">.pdf</a> ]
<a name="HicksMN01a"></a><pre>
@INPROCEEDINGS{HicksMN01a,
  AUTHOR = {Michael Hicks and Jonathan T. Moore and Scott Nettles},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Programming Language Design and Implementation (PLDI)},
  TITLE = {Dynamic Software Updating},
  MONTH = {June},
  YEAR = 2001,
  PAGES = {13--23},
  PUBLISHER = {{ACM}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Compiling PLAN to SNAP</b>.
  Michael Hicks, Jonathan&nbsp;T. Moore, and Scott Nettles.
  In Ian&nbsp;W. Marshall, Scott Nettles, and Naoki Wakamiya, editors, <i>
  Proceedings of the Third International Working Conference on Active Networks
  (IWAN)</i>, volume 2207 of <i>Lecture Notes in Computer Science</i>, pages
  134-151. Springer-Verlag, October 2001.</font><p>
PLAN (Packet Language for Active Networks) is a highly flexible
and usable active packet language, whereas SNAP (Safe and Nimble
Active Packets)  offers significant resource usage safety and
achieves much higher performance compared to PLAN, but at the cost
of flexibility and usability.  Ideally, we would like to combine
the good properties of PLAN with those of SNAP. We have achieved
this end by developing a compiler that translates PLAN
into SNAP. The compiler allows us to achieve the
flexibility and usability of PLAN, but with the safety and
efficiency of SNAP. In this paper, we describe both languages,
highlighting the features that require special compilation
techniques. We then present the details of our compiler and
experimental results to evaluate our compiler with respect to code
size.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/plansnap.ps">.ps</a> ]
<a name="HicksMN01b"></a><pre>
@INPROCEEDINGS{HicksMN01b,
  AUTHOR = {Michael Hicks and Jonathan T. Moore and Scott Nettles},
  TITLE = {Compiling {PLAN} to {SNAP}},
  BOOKTITLE = {Proceedings of the Third International Working Conference on Active Networks (IWAN)},
  PUBLISHER = {Springer-Verlag},
  EDITOR = {Ian W. Marshall and Scott Nettles and Naoki Wakamiya},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = 2207,
  PAGES = {134--151},
  YEAR = 2001,
  MONTH = {October}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>The Measured Cost of Copying Garbage Collection Mechanisms</b>.
  Michael&nbsp;W. Hicks, Jonathan&nbsp;T. Moore, and Scott&nbsp;M. Nettles.
  In <i>Proceedings of the ACM SIGPLAN Conference on Functional
  Programming (ICFP)</i>, pages 292-305. ACM, June 1997.</font><p>
We examine the costs and benefits of a variety of copying garbage
collection (GC) mechanisms across multiple architectures and
programming languages. Our study covers both low-level object
representation and copying issues as well as the mechanisms needed to
support more advanced techniques such as generational collection,
large object spaces, and type-segregated areas.<P>
Our experiments are made possible by a novel performance analysis
tool, <i>Oscar.</i> Oscar allows us to capture snapshots of programming
language heaps that may then be used to replay garbage
collections. The replay program is self-contained and written in C,
which makes it easy to port to other architectures and to analyze with
standard performance analysis tools. Furthermore, it is possible to
study additional programming languages simply by instrumenting
existing implementations to capture heap snapshots.<P>
In general, we found that careful implementation of GC mechanisms can
have a significant benefit. For a simple collector, we measured
improvements of as much as 95 percent. We then found that while the addition
of advanced features can have a sizeable overhead (up to 15 percent), the
net benefit is quite positive, resulting in additional gains of up to
42 percent. We also found that results varied depending upon the platform
and language. Machine characteristics such as cache arrangements,
instruction set (RISC/CISC), and register pool were important. For
different languages, average object size seemed to be most important.<P>
The results of our experiments demonstrate the usefulness of a tool
like Oscar for studying GC performance. Without much overhead, we can
easily identify areas where programming language implementors could
collaborate with GC implementors to improve GC performance.<p>[ <a href="http://www.cis.upenn.edu/~oscar/icfp97.ps">.ps</a> ]
<a name="HicksMN97"></a><pre>
@INPROCEEDINGS{HicksMN97,
  AUTHOR = {Michael W. Hicks and Jonathan T. Moore
                 and Scott M. Nettles},
  TITLE = {The Measured Cost of Copying Garbage Collection Mechanisms},
  BOOKTITLE = {Proceedings of the {ACM} {SIGPLAN} Conference on
		 Functional Programming (ICFP)},
  YEAR = 1997,
  PUBLISHER = {{ACM}},
  PAGES = {292--305},
  MONTH = {June}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Experiences with Capsule-based Active Networking</b>.
  Michael Hicks, Jonathan&nbsp;T. Moore, David Wetherall, and Scott Nettles.
  In <i>Proceedings of the DARPA Active Networks Conference and
  Exposition (DANCE)</i>, pages 16-24. IEEE, May 2002.</font><p>
Active Networking adds programmability to the elements
of the network, most aggressively by using programmable packets,
or <i>capsules</i>. ANTS and
PLANet are the most mature examples of
capsule-based systems, both having been publicly available for
several years. This paper presents our experience with these
systems and the lessons they hold for the future of capsule-based
Active Networking.<P>
The paper focuses on four key issues: flexibility, performance,
security, and usability.  We consider how ANTS and PLANet address
these issues, noting that despite substantial surface differences,
both systems identify similar key problems and use closely related
solutions.  Based on our experience with these systems we conclude
that capsule-based systems can achieve useful levels of
flexibility, performance, and usability.  Many aspects of security
can also be adequately addressed, but some important problems
related to denial of service remain as open problems.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/planants.ps">.ps</a> ]
<a name="HicksMNW02"></a><pre>
@INPROCEEDINGS{HicksMNW02,
  AUTHOR = {Michael Hicks and Jonathan T. Moore and David Wetherall and Scott Nettles},
  TITLE = {Experiences with Capsule-based Active Networking},
  BOOKTITLE = {Proceedings of the {DARPA} Active Networks Conference and Exposition (DANCE)},
  MONTH = {May},
  WHERE = {San Francisco, CA},
  YEAR = 2002,
  PAGES = {16--24},
  PUBLISHER = {{IEEE}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Active Networking means Evolution (or Enhanced Extensibility Required)</b>.
  Michael Hicks and Scott Nettles.
  In Hiroshi Yashuda, editor, <i>Proceedings of the Second
  International Working Conference on Active Networks (IWAN)</i>, volume 1942 of
  <i>Lecture Notes in Computer Science</i>, pages 16-32. Springer-Verlag,
  October 2000.</font><p>
The primary goal of active networking is to increase the pace of
network evolution.  The approach to achieving this goal, as well
as the goal of enhancing customizability, is to allow network
nodes to be extended by dynamically loaded code. Most active
network implementations employ <i>plug-in extensibility</i>, a
technique for loading code characterized by a concrete,
pre-defined abstraction of future change.  After giving examples
of plug-in extensibility, we argue that while it is flexible and
convenient, it is not sufficient to facilitate true evolution of
the network. To remedy this problem, we propose the use of <i>
dynamic software updating</i>.  Dynamic software updating reduces the
<i>a priori</i> assumptions of plug-in extensibility, improving
flexibility and eliminating the need to pre-plan extensions.
However, this additional flexibility results in additional
complexity and creates issues involving validity and security. We
discuss these issues, and describe the state-of-the-art in systems
that support dynamic software updating, thus framing the problem
for  researchers developing next-generation active networks.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/an_evolution.pdf">.pdf</a> ]
<a name="HicksN00"></a><pre>
@INPROCEEDINGS{HicksN00,
  AUTHOR = {Michael Hicks and Scott Nettles},
  TITLE = {Active Networking means Evolution (or Enhanced Extensibility
                  Required)},
  BOOKTITLE = {Proceedings of the Second International Working Conference on Active Networks (IWAN)},
  MONTH = {October},
  YEAR = 2000,
  PUBLISHER = {Springer-Verlag},
  EDITOR = {Hiroshi Yashuda},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = 1942,
  PAGES = {16--32}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Software Updating</b>.
  Michael Hicks and Scott&nbsp;M. Nettles.
  <i>ACM Transactions on Programming Languages and Systems
  (TOPLAS)</i>, 27(6):1049-1096, November 2005.</font><p>
Many important applications must run continuously and without interruption,
yet must be changed to fix bugs or upgrade functionality.  No
prior general-purpose methodology for dynamic updating achieves a practical
balance between flexibility, robustness, low overhead, and ease of use.<P>
We present an approach for C-like languages that provides type-safe dynamic
updating of native code in an extremely flexible manner (code, data, and
types may be updated, at programmer-determined times) and permits the use of
automated tools to aid the programmer in the updating process.  Our system
is based on dynamic patches that contain both the updated code and the code
needed to transition from the old version to the new.  A novel aspect of our
patches is that they consist of verifiable native code (e.g. Proof-Carrying
Code or Typed Assembly Language), which is native code accompanied by
annotations that allow on-line verification of the code's safety.  We
discuss how patches are generated mostly automatically, how they are applied
using dynamic-linking technology, and how code is compiled to make it
updateable.<P>
To concretely illustrate our system, we have implemented a
dynamically-updateable web server, FlashEd.  We discuss our experience
building and maintaining FlashEd, and generalize to present observations
about updateable software development.  Performance experiments show that
for FlashEd, the overhead due to updating is low: typically less than 1
percent.
<p>[ <a href="http://doi.acm.org/10.1145/1108970.1108971">http</a> ]
<a name="HicksNettles03"></a><pre>
@ARTICLE{HicksNettles03,
  AUTHOR = {Michael Hicks and Scott M. Nettles},
  TITLE = {Dynamic Software Updating},
  JOURNAL = {{ACM} Transactions on Programming Languages and Systems (TOPLAS)},
  YEAR = 2005,
  MONTH = {November},
  VOLUME = {27},
  NUMBER = {6},
  PAGES = {1049--1096}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>User-Specified Adaptive Scheduling in a Streaming Media Network</b>.
  Michael Hicks, Adithya Nagarajan, and Robbert van Renesse.
  In <i>Proceedings of the IEEE Conference on Open Architectures
  (OPENARCH)</i>, pages 87-96, April 2003.</font><p>
In disaster and combat situations, mobile cameras and other sensors
transmit real-time data, used by many operators or analysis tools.
Unfortunately, in the face of limited, unreliable resources, and varying
demands, not all users may be able to get the fidelity they require.  This
paper describes <em>MediaNet</em>, a distributed stream processing system
designed with the above scenarios in mind.
Unlike past approaches, MediaNet's users can intuitively specify
how the system should adapt based on their
individual needs.
MediaNet uses both local and on-line global resource
scheduling to improve user performance and network utilization, and
adapts without requiring underlying support for
resource reservations.  Performance experiments show that our scheduling
algorithm is reasonably fast, and that user performance and network
utilization are both significantly improved.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/medianet.pdf">.pdf</a> ]
<a name="HicksNvR03"></a><pre>
@INPROCEEDINGS{HicksNvR03,
  AUTHOR = {Michael Hicks and Adithya Nagarajan and Robbert van Renesse},
  TITLE = {User-Specified Adaptive Scheduling in a Streaming Media Network},
  BOOKTITLE = {Proceedings of the IEEE Conference on Open Architectures (OPENARCH)},
  YEAR = 2003,
  MONTH = APR,
  WHERE = {San Francisco, CA},
  PAGES = {87--96}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A Calculus for Dynamic Loading</b>.
  Michael Hicks and Stephanie Weirich.
  Technical Report MS-CIS-00-07, University of Pennsylvania, April
  2000.</font><p><p>[ <a href="http://www.cs.umd.edu/~mwh/papers/loadcalc.pdf">.pdf</a> ]
<a name="HicksW00type-loading-tr"></a><pre>
@TECHREPORT{HicksW00type-loading-tr,
  AUTHOR = {Michael Hicks and Stephanie Weirich},
  TITLE = {A Calculus for Dynamic Loading},
  INSTITUTION = {University of Pennsylvania},
  YEAR = {2000},
  NUMBER = {MS-CIS-00-07},
  MONTH = {April}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Cyclone: A Safe Dialect of C</b>.
  Trevor Jim, Greg Morrisett, Dan Grossman, Michael Hicks, James
  Cheney, and Yanling Wang.
  In <i>Proceedings of the USENIX Annual Technical Conference</i>,
  pages 275-288. USENIX, June 2002.</font><p>
  Cyclone is a safe dialect of C.  It has been designed from the
  ground up to prevent the buffer overflows, format string attacks,
  and memory management errors that are common in C programs, while
  retaining C's syntax and semantics.  This paper examines safety
  violations enabled by C's design, and shows how Cyclone avoids them,
  without giving up C's hallmark control over low-level details such
  as data representation and memory management.
  <p>[ <a href="http://cyclone.thelanguage.org">http</a> | 
<a href="http://www.cs.cornell.edu/projects/cyclone/papers/cyclone-safety.pdf">.pdf</a> ]
<a name="JimMGHCW02"></a><pre>
@INPROCEEDINGS{JimMGHCW02,
  AUTHOR = {Trevor Jim and Greg Morrisett and Dan Grossman and Michael Hicks and James Cheney and Yanling Wang},
  TITLE = {{C}yclone: A Safe Dialect of {C}},
  BOOKTITLE = {Proceedings of the {USENIX} Annual Technical Conference},
  MONTH = {June},
  WHERE = {Monterey, CA},
  PAGES = {275--288},
  YEAR = 2002,
  PUBLISHER = {{USENIX}},
  HTTP = {<a href="http://cyclone.thelanguage.org">http://cyclone.thelanguage.org</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Specifying the PLAN Network Programming Language</b>.
  Pankaj Kakkar, Michael Hicks, Jonathan&nbsp;T. Moore, and Carl&nbsp;A. Gunter.
  In <i>Higher Order Operational Techniques in Semantics (HOOTS)</i>,
  volume&nbsp;26 of <i>Electronic Notes in Theoretical Computer Science</i>, pages
  87-104. Elsevier, September 1999.</font><p><p>[ <a href="http://www.cis.upenn.edu/~switchware/PLAN/spec/spec-experience.ps">.ps</a> ]
<a name="KakkarHMG99"></a><pre>
@INPROCEEDINGS{KakkarHMG99,
  AUTHOR = {Pankaj Kakkar and Michael Hicks and Jonathan T. Moore and
                 Carl A. Gunter},
  TITLE = {Specifying the {PLAN} Network Programming Language},
  YEAR = 1999,
  VOLUME = 26,
  SERIES = {Electronic Notes in Theoretical Computer Science},
  BOOKTITLE = {Higher Order Operational Techniques in Semantics (HOOTS)},
  PAGES = {87--104},
  PUBLISHER = {Elsevier},
  MONTH = {September}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Contextual Effects for Version-Consistent Dynamic Software Updating and
  Safe Concurrent Programming (extended version)</b>.
  Iulian Neamtiu, Michael Hicks, Jeffrey&nbsp;S. Foster, and Polyvios
  Pratikakis.
  Technical Report CS-TR-4875, University of Maryland, Department of
  Computer Science, July 2007.</font><p>
This paper presents a generalization of standard effect systems that
we call <em>contextual effects</em>.  A traditional effect system
computes the effect of an expression <EM>e</EM>.  Our system additionally
computes the effects of the computational context in which <EM>e</EM> occurs:
both the effect of the computation that has already occurred
(<em>prior effects</em>) and the effect of the computation yet to take
place (<em>future effects</em>).<P>
Contextual effects can be used in any application in which the past or
future computation of the program is relevant at various program points.  We
present two substantial examples.  First, we show how prior and future
effects can be used to enforce <em>transactional version consistency</em>
(TVC), a novel correctness property for dynamic software updates. TVC
ensures that programmer-designated transactional code blocks appear to
execute entirely at the same code version, even if a dynamic update occurs
in the middle of the block.  Second, we show how future effects can be used
in the analysis of multi-threaded programs to find thread-shared locations.
This is an essential step in applications such as data race detection.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/ctxeffs-tr.pdf">.pdf</a> ]
<a name="MT-TR"></a><pre>
@TECHREPORT{MT-TR,
  AUTHOR = {Iulian Neamtiu and Michael Hicks and Jeffrey S. Foster and Polyvios Pratikakis},
  TITLE = {Contextual Effects for Version-Consistent Dynamic Software Updating
  and Safe Concurrent Programming (extended version)},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  NUMBER = {CS-TR-4875},
  YEAR = 2007,
  MONTH = JUL
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Practical Programmable Packets</b>.
  Jonathan&nbsp;T. Moore, Michael Hicks, and Scott Nettles.
  In <i>Proceedings of the Twentieth IEEE Computer and
  Communication Society INFOCOM Conference</i>, pages 41-50. IEEE, April
  2001.</font><p>
We present SNAP (Safe and Nimble Active Packets), a new scheme for
programmable (or <i>active</i>) packets centered around a new low-level
packet language. Unlike previous active packet approaches, SNAP is <i>
practical</i>: namely, adding significant <i>flexibility</i> over IP without
compromising <i>safety and security</i> or <i>efficiency</i>. In this work we
compare SNAP's flexibility to other active packet systems, give proof
sketches of its novel approach to resource control, and present experimental
data showing SNAP attains performance extremely close to that of a software
IP router.
  <p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/snap.pdf">.pdf</a> ]
<a name="MooreHN01"></a><pre>
@INPROCEEDINGS{MooreHN01,
  AUTHOR = {Jonathan T. Moore and Michael Hicks and Scott Nettles},
  TITLE = {Practical Programmable Packets},
  BOOKTITLE = {Proceedings of the Twentieth {IEEE} Computer and
                  Communication Society {INFOCOM} Conference},
  MONTH = {April},
  YEAR = 2001,
  PAGES = {41-50},
  PUBLISHER = {{IEEE}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>General-Purpose Persistence Using Flash Memory</b>.
  Jonathan&nbsp;T. Moore, Michael Hicks, and Scott Nettles.
  Unpublished manuscript, April 1997.</font><p>
Flash memory is a semiconductor memory technology that has interesting
price, performance, and semantic tradeoffs. We have developed Gordon,
a general-purpose persistence system for Standard ML that uses Flash
mapped into the virtual address space as its stable storage medium.<P>
Flash supports a write-once/bulk-erase interface that makes it
difficult to support update-in-place semantics. In addition, Flash
chips are only guaranteed to survive a limited number of erase
cycles. Gordon has been designed to overcome these difficulties, and
our performance analysis demonstrates good performance and reasonable
lifetimes for appropriate application domains.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/flash.ps">.ps</a> ]
<a name="MooreHN98"></a><pre>
@UNPUBLISHED{MooreHN98,
  AUTHOR = {Jonathan T. Moore and Michael Hicks and Scott Nettles},
  TITLE = {General-Purpose Persistence Using Flash Memory},
  YEAR = 1997,
  MONTH = {April},
  NOTE = {Unpublished manuscript}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Chunks in PLAN: Language Support for Programs as Packets</b>.
  Jonathan&nbsp;T. Moore, Michael Hicks, and Scott&nbsp;M. Nettles.
  In <i>Proceedings of the 37th Annual Allerton Conference on
  Communication, Control, and Computing</i>, September 1999.</font><p>
<i>Chunks</i> are a programming construct in PLAN, the Packet Language for
Active Networks, comprised of a code segment and a suspended function call.
In PLAN, chunks provide support for encapsulation and other packet
programming techniques.  This paper begins by explaining the semantics and
implementation of chunks.  We proceed, using several PLAN source code
examples, to demonstrate the usefulness of chunks for micro-protocols,
asynchronous adaptation, and as units of authentication granularity.
  <p>[ <a href="http://www.cis.upenn.edu/~switchware/papers/planchunks.pdf">.pdf</a> ]
<a name="MooreHN99"></a><pre>
@INPROCEEDINGS{MooreHN99,
  AUTHOR = {Jonathan T. Moore and Michael Hicks and Scott M. Nettles},
  TITLE = {Chunks in {PLAN}: Language Support for Programs as Packets},
  BOOKTITLE = {Proceedings of the 37th Annual Allerton Conference on
                  Communication, Control, and Computing},
  MONTH = {September},
  YEAR = 1999
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Rebinding for Marshalling and Update, via Redex-time and
  Destruct-time Reduction</b>.
  Peter Sewell, Gareth Stoyle, Michael Hicks, Gavin Bierman, and Keith
  Wansbrough.
  <i>Journal of Functional Programming (JFP)</i>, 18(4):437-502, July
  2008.
  Appeared on-line October, 2007. Supercedes ICFP 2003 and USE 2003
  papers.</font><p>
    Most programming languages adopt static binding, but for distributed
programming an exclusive reliance on static binding is too
restrictive: dynamic binding is required in various guises, for
example when a marshalled value is received from the network,
containing identifiers that must be rebound to local resources.
Typically it is provided only by ad-hoc mechanisms that lack clean
semantics.<P>
    In this paper we adopt a foundational approach, developing core
dynamic rebinding mechanisms as extensions to the simply-typed
call-by-value lambda-calculus.  To do so we must first explore
refinements of the call-by-value reduction strategy that delay
instantiation, to ensure computations make use of the most recent
versions of rebound definitions.  We introduce redex-time and
destruct-time strategies.  The latter forms the basis for a
lambda-marsh calculus that supports dynamic rebinding of marshalled
values, while remaining as far as possible statically-typed.  We
sketch an extension of lambda-marsh with concurrency and
communication, giving examples showing how wrappers for encapsulating
untrusted code can be expressed.  Finally, we show that a high-level
semantics for dynamic updating can also be based on the destruct-time
strategy, defining a lambda-update calculus with simple primitives to
provide type-safe updating of running code.  We show how the ideas of
this simple calculus extend to more real-world, module-level dynamic
updating in the style of Erlang.  We thereby establish primitives and
a common semantic foundation for a variety of real-world dynamic
rebinding requirements.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dynbind-journal.pdf">.pdf</a> ]
<a name="SewellSHBW07"></a><pre>
@ARTICLE{SewellSHBW07,
  AUTHOR = {Peter Sewell and Gareth Stoyle and Michael Hicks and Gavin Bierman and Keith Wansbrough},
  TITLE = {Dynamic Rebinding for Marshalling and Update, via Redex-time and Destruct-time Reduction},
  JOURNAL = {Journal of Functional Programming (JFP)},
  VOLUME = 18,
  NUMBER = 4,
  MONTH = JUL,
  PAGES = {437--502},
  YEAR = 2008,
  NOTE = {Appeared on-line October, 2007.  Supercedes ICFP 2003 and USE 2003 papers},
  OPTDOI = {doi: 10.1017/S0956796807006600}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evolution in Action: Using Active Networking to Evolve Network Support for
  Mobility</b>.
  Seo-Kyu Song, Stephen Shannon, Michael Hicks, and Scott Nettles.
  In James Sterbenz, Osamu Takada, Christian Tschudin, and Bernhard
  Plattner, editors, <i>Proceedings of the Fourth International Working
  Conference on Active Networks (IWAN)</i>, volume 2546 of <i>Lecture Notes in
  Computer Science</i>, pages 146-161. Springer-Verlag, December 2002.</font><p>
A key early objective of Active Networking (AN) was to support
on-the-fly network evolution.  Although AN has been used
relatively extensively to build application-customized protocols
and even whole networking systems, demonstrations of evolution
have been limited.  This paper examines three AN mechanisms and how they enable
evolution: active packets and plug-in extensions, well-known to the AN
community, and update extensions, which are novel to AN.  We devote our
presentation to a series of demonstrations of how each type of evolution can
be applied to the problem of adding support for mobility to a network. This
represents the most large-scale demonstration of AN evolution to date. These
demonstrations show what previous AN research has not: that AN technology
can, in fact, support very significant changes to the network, even while
the network is operational.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/evolution-action.pdf">.pdf</a> ]
<a name="SongSHN02"></a><pre>
@INPROCEEDINGS{SongSHN02,
  AUTHOR = {Seo-Kyu Song and Stephen Shannon and Michael Hicks and Scott Nettles},
  TITLE = {Evolution in Action: Using Active Networking to Evolve Network Support for Mobility},
  BOOKTITLE = {Proceedings of the Fourth International Working Conference on Active Networks (IWAN)},
  PUBLISHER = {Springer-Verlag},
  EDITOR = {James Sterbenz and Osamu Takada and Christian Tschudin and Bernhard Plattner},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = 2546,
  PAGES = {146--161},
  YEAR = 2002,
  MONTH = {December}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b><em>Mutatis Mutandis</em>: Safe and Flexible Dynamic Software Updating</b>.
  Gareth Stoyle, Michael Hicks, Gavin Bierman, Peter Sewell, and Iulian
  Neamtiu.
  In <i>Proceedings of the ACM Conference on Principles of
  Programming Languages (POPL)</i>, pages 183-194, January 2005.</font><p>
Dynamic software updates can be used to fix bugs or add features to a
running program without downtime.  Essential for some applications and
convenient for others, low-level dynamic updating support has been
used for many years.  However, there is little high-level
understanding that would support programmers in writing dynamic
updates effectively.<P>
In an effort to bridge this gap, we present a formal calculus called
Proteus for modeling dynamic software updating in C-like languages
that is flexible, safe, and predictable.  Proteus supports dynamic
updates to functions (even those that are active) and types, allowing
on-line evolution to match source-code evolution as we have observed
it in practice.  All updates are provably type-safe and
<em>representation-consistent</em>, meaning that only one version of a given
type may exist in the program at any time, simplifying reasoning and
avoiding unintuitive copy-based semantics.  Finally, Proteus's novel
and efficient static <em>updateability analysis</em> allows a programmer to
automatically prove that an update is independent of the on-line
program state, and thus predict it will not fail dynamically.  Proteus
admits a straightforward implementation, and we sketch how it could be
extended to more advanced language features including threads.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/proteus-popl.pdf">.pdf</a> ]
<a name="StoyleHBSN05"></a><pre>
@INPROCEEDINGS{StoyleHBSN05,
  AUTHOR = {Gareth Stoyle and Michael Hicks and Gavin Bierman and Peter Sewell and Iulian Neamtiu},
  TITLE = {\emph{Mutatis Mutandis}: Safe and Flexible Dynamic Software Updating},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Principles of Programming Languages (POPL)},
  PAGES = {183--194},
  MONTH = {January},
  YEAR = {2005},
  WHERE = {Long Beach, California}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b><em>Mutatis Mutandis</em>: Safe and Flexible Dynamic Software Updating (full
  version)</b>.
  Gareth Stoyle, Michael Hicks, Gavin Bierman, Peter Sewell, and Iulian
  Neamtiu.
  <i>ACM Transactions on Programming Languages and Systems
  (TOPLAS)</i>, 29(4), August 2007.
  Full version of POPL 05 paper.</font><p>
This paper presents Proteus, a core calculus that models dynamic
software updating, a service for fixing bugs and adding features to a
running program.  Proteus permits a program's type structure to change
dynamically but guarantees the updated program remains type-correct by
ensuring a property we call ``con-freeness.''  We show how con-freeness
can be enforced dynamically, and how it can be approximated via a
novel static analysis.  This analysis can be used to assess the
implications of a program's structure on future updates, to make
update success more predictable.  We have implemented Proteus for C,
and briefly discuss our implementation, which we have tested on
several well-known programs.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/mutatis-journal.pdf">.pdf</a> ]
<a name="StoyleHBSN06"></a><pre>
@ARTICLE{StoyleHBSN06,
  AUTHOR = {Gareth Stoyle and Michael Hicks and Gavin Bierman and Peter Sewell and Iulian Neamtiu},
  TITLE = {\emph{Mutatis Mutandis}: Safe and Flexible Dynamic Software Updating (full version)},
  VOLUME = 29,
  NUMBER = 4,
  JOURNAL = {{ACM} Transactions on Programming Languages and Systems (TOPLAS)},
  NOTE = {Full version of POPL 05 paper},
  YEAR = 2007,
  MONTH = AUG
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Quantifying vulnerability of secret generation using hyper-distributions</b>.
  Mrio&nbsp;S. Alvim, Piotr Mardziel, and Michael Hicks, October 2016.
  Extended version of short paper that appeared at FCS16:
  <A HREF="http://www.cs.umd.edu/~mwh/papers/stratquant.pdf">http://www.cs.umd.edu/~mwh/papers/stratquant.pdf</A>.</font><p>
    Traditional approaches to Quantitative Information Flow (QIF)
  represent the adversary's prior knowledge about how secrets
  are generated as a single probability distribution.
  Although adequate when a unique random procedure is used to 
  generate secrets, this representation may overlook important 
  structure often present in the secret-generation process.
  For instance, the representation of prior knowledge about
  passwords of a system's users as a single distribution 
  overlooks the fact  that many users generate passwords using 
  some <em>strategy</em>, and that knowledge of such strategies can 
  help the adversary in guessing the secret.
  The result is a potential underestimation of the vulnerability of the 
  secret.
  In this paper we explicitly model strategies as 
  distributions on secrets, and  generalize the representation of 
  the adversary's prior knowledge from a distribution on secrets
  to an <em>environment</em>, which is a distribution on strategies 
  (and, thus, a distribution on distributions on secrets, 
  called a <em>hyper-distribution</em>).
  By applying information-theoretic techniques to environments 
  we derive several meaningful generalizations of the traditional
  approach to QIF.
  In particular, we are able to disentangle the 
  <em>vulnerability of a secret</em> from the <em>vulnerability of the strategies</em> 
  that generate secrets, and thereby we can distinguish <em>security
  from aggregation</em>-which relies on the uncertainty over
  strategies-and <em>real security</em>-which relies on the
  intrinsic uncertainty within a strategy.
  We also demonstrate that, in a precise way, no further generalization
  of prior knowledge 
  (e.g., by using distributions of even higher order) 
  is needed to soundly quantify the vulnerability of the secret.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/quant-secret-submit.pdf">.pdf</a> ]
<a name="alvim16strat"></a><pre>
@MISC{alvim16strat,
  AUTHOR = {M\'{a}rio S. Alvim and Piotr Mardziel and Michael Hicks},
  TITLE = {Quantifying vulnerability of secret generation using hyper-distributions},
  YEAR = 2016,
  MONTH = OCT,
  SUBMITTED = {yes},
  NOTE = {Extended version of short paper that appeared at FCS16: \url{http://www.cs.umd.edu/~mwh/papers/stratquant.pdf}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Quantifying vulnerability of secret generation using hyper-distributions</b>.
  Mrio&nbsp;S. Alvim, Piotr Mardziel, and Michael Hicks.
  In <i>Proceedings of the Symposium on Principles of Security and
  Trust (POST)</i>, April 2017.
  Extended version of short paper that appeared at FCS 2016:
  <A HREF="http://www.cs.umd.edu/~mwh/papers/stratquant.pdf">http://www.cs.umd.edu/~mwh/papers/stratquant.pdf</A>.</font><p>
    Traditional approaches to Quantitative Information Flow (QIF)
  represent the adversary's prior knowledge of possible secret values
  as a single probability distribution.
  This representation may miss important 
  structure.
  For instance, representing prior knowledge about
  passwords of a system's users in this way
  overlooks the fact  that many users generate passwords using 
  some <em>strategy</em>.  Knowledge of such strategies can 
  help the adversary in guessing a secret, so ignoring them may
  underestimate the secret's vulnerability.
  In this paper we explicitly model strategies as 
  distributions on secrets, and  generalize the representation of 
  the adversary's prior knowledge from a distribution on secrets
  to an <em>environment</em>, which is a distribution on strategies 
  (and, thus, a distribution on distributions on secrets, 
  called a <em>hyper-distribution</em>).
  By applying information-theoretic techniques to environments 
  we derive several meaningful generalizations of the traditional
  approach to QIF.
  In particular, we disentangle the 
  <em>vulnerability of a secret</em> from the <em>vulnerability of the strategies</em> 
  that generate secrets, and thereby distinguish 
  <em>security by aggregation</em>-which relies on the uncertainty over
  strategies-from <em>security by strategy</em>-which relies on the
  intrinsic uncertainty within a strategy.
  We also demonstrate that, in a precise way, no further generalization
  of prior knowledge 
  (e.g., by using distributions of even higher order) 
  is needed to soundly quantify the vulnerability of the secret.
<p>[ <a href="https://arxiv.org/abs/1701.04174">http</a> ]
<a name="alvim17strat"></a><pre>
@INPROCEEDINGS{alvim17strat,
  AUTHOR = {M\'{a}rio S. Alvim and Piotr Mardziel and Michael Hicks},
  TITLE = {Quantifying vulnerability of secret generation using hyper-distributions},
  BOOKTITLE = {Proceedings of the Symposium on Principles of Security and Trust (POST)},
  YEAR = 2017,
  MONTH = APR,
  NOTE = {Extended version of short paper that appeared at FCS 2016: \url{http://www.cs.umd.edu/~mwh/papers/stratquant.pdf}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Inference of Static Types for Ruby</b>.
  Jong hoon (David)&nbsp;An, Avik Chaudhuri, Jeffrey&nbsp;S. Foster, and Michael
  Hicks, July 2010.</font><p>
  There have been several efforts to bring static type
  inference to object-oriented dynamic languages such as Ruby, Python,
  and Perl.  In our experience, however, such type inference systems
  are extremely difficult to develop, because dynamic languages are
  typically complex, poorly specified, and include
  features, such as <tt>eval</tt> and reflection, that are hard to
  analyze.  In this paper, we introduce 
  <em>constraint-based dynamic type inference</em>, a technique that
  infers static types based on dynamic program executions.  In our approach,
  we wrap each run-time value to associate it with a type variable,
  and the wrapper generates constraints on this type variable when
  the wrapped value is used.  This technique avoids many of the often
  overly conservative approximations of static tools,
  as constraints
  are generated based on how values are used during actual program runs.
  Using wrappers is also easy to implement, since we need only
  write a constraint resolution algorithm and a transformation to
  introduce the wrappers.
  The best part is that we can eat our
  cake, too: our algorithm will infer <em>sound</em> types as long as it
  observes every 
  path through each method body-note that the number of such paths
  may be dramatically smaller than the number of paths through the
  program as a whole.  We have developed Rubydust, an implementation of
  our algorithm for Ruby.  Rubydust takes advantage of Ruby's dynamic
  features to implement wrappers as a language library.  We applied
  Rubydust to a number of small programs.  We found it to be
  lightweight and useful: Rubydust discovered 1 real type error,
  and all other inferred types were correct, and readable.
 <p><a name="an10rubydust"></a><pre>
@MISC{an10rubydust,
  AUTHOR = {Jong-hoon (David) An and Avik Chaudhuri and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Dynamic Inference of Static Types for Ruby},
  MONTH = JUL,
  SUBMITTED = {yes},
  YEAR = 2010
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Dynamic Inference of Static Types for Ruby</b>.
  Jong hoon (David)&nbsp;An, Avik Chaudhuri, Jeffrey&nbsp;S. Foster, and Michael
  Hicks.
  Technical Report CS-TR-4965, University of Maryland Department of
  Computer Science, July 2010.
  Extended version contains proofs of theorems.</font><p>
  There have been several efforts to bring static type
  inference to object-oriented dynamic languages such as Ruby, Python,
  and Perl.  In our experience, however, such type inference systems
  are extremely difficult to develop, because dynamic languages are
  typically complex, poorly specified, and include
  features, such as <tt>eval</tt> and reflection, that are hard to
  analyze.  In this paper, we introduce 
  <em>constraint-based dynamic type inference</em>, a technique that
  infers static types based on dynamic program executions.  In our approach,
  we wrap each run-time value to associate it with a type variable,
  and the wrapper generates constraints on this type variable when
  the wrapped value is used.  This technique avoids many of the often
  overly conservative approximations of static tools,
  as constraints
  are generated based on how values are used during actual program runs.
  Using wrappers is also easy to implement, since we need only
  write a constraint resolution algorithm and a transformation to
  introduce the wrappers.
  The best part is that we can eat our
  cake, too: our algorithm will infer <em>sound</em> types as long as it
  observes every 
  path through each method body-note that the number of such paths
  may be dramatically smaller than the number of paths through the
  program as a whole.  We have developed Rubydust, an implementation of
  our algorithm for Ruby.  Rubydust takes advantage of Ruby's dynamic
  features to implement wrappers as a language library.  We applied
  Rubydust to a number of small programs.  We found it to be
  lightweight and useful: Rubydust discovered 1 real type error,
  and all other inferred types were correct, and readable.
 <p>[ <a href="http://www.lib.umd.edu/drum/bitstream/1903/10599/1/CS-TR-4965.pdf">.pdf</a> ]
<a name="an10rubydustTR"></a><pre>
@TECHREPORT{an10rubydustTR,
  AUTHOR = {Jong-hoon (David) An and Avik Chaudhuri and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Dynamic Inference of Static Types for Ruby},
  INSTITUTION = {University of Maryland Department of Computer Science},
  NUMBER = {CS-TR-4965},
  MONTH = JUL,
  YEAR = 2010,
  NOTE = {Extended version contains proofs of theorems}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Inference of Static Types for Ruby</b>.
  Jong hoon (David)&nbsp;An, Avik Chaudhuri, Jeffrey&nbsp;S. Foster, and Michael
  Hicks.
  In <i>Proceedings of the ACM Conference on Principles of
  Programming Languages (POPL)</i>, pages 459-472, January 2011.</font><p>
  There have been several efforts to bring static type
  inference to object-oriented dynamic languages such as Ruby, Python,
  and Perl.  In our experience, however, such type inference systems
  are extremely difficult to develop, because dynamic languages are
  typically complex, poorly specified, and include
  features, such as <tt>eval</tt> and reflection, that are hard to
  analyze.  <P>
In this paper, we introduce 
  <em>constraint-based dynamic type inference</em>, a technique that
  infers static types based on dynamic program executions.  In our approach,
  we wrap each run-time value to associate it with a type variable,
  and the wrapper generates constraints on this type variable when
  the wrapped value is used.  This technique avoids many of the often
  overly conservative approximations of static tools,
  as constraints
  are generated based on how values are used during actual program runs.
  Using wrappers is also easy to implement, since we need only
  write a constraint resolution algorithm and a transformation to
  introduce the wrappers.
  The best part is that we can eat our
  cake, too: our algorithm will infer <em>sound</em> types as long as it
  observes every 
  path through each method body-note that the number of such paths
  may be dramatically smaller than the number of paths through the
  program as a whole.  <P>
We have developed Rubydust, an implementation of
  our algorithm for Ruby.  Rubydust takes advantage of Ruby's dynamic
  features to implement wrappers as a language library.  We applied
  Rubydust to a number of small programs and found it to be both easy
  to use and useful:
  Rubydust discovered 1 real type error,
  and all other inferred types were correct and
  readable.
 <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/rubydust.pdf">.pdf</a> ]
<a name="an11rubydust"></a><pre>
@INPROCEEDINGS{an11rubydust,
  AUTHOR = {Jong-hoon (David) An and Avik Chaudhuri and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Dynamic Inference of Static Types for Ruby},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Principles of Programming Languages (POPL)},
  MONTH = JAN,
  YEAR = 2011,
  PAGES = {459--472}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Position Paper: Dynamically Inferred Types for Dynamic Languages</b>.
  Jong hoon (David)&nbsp;An, Avik Chaudhuri, Jeffrey&nbsp;S. Foster, and Michael
  Hicks.
  In <i>Proceedings of the Workshop on Scripts to Programs (STOP)</i>,
  January 2011.</font><p>
    Capsule summary of results and future directions of dynamic type inference, as proposed in our <a href="http://www.cs.umd.edu/~mwh/papers/an10rubydust.html">POPL 2011 paper</a>.
  <p><a name="an2011position"></a><pre>
@INPROCEEDINGS{an2011position,
  TITLE = {Position Paper: Dynamically Inferred Types for Dynamic Languages},
  AUTHOR = {Jong-hoon (David) An and Avik Chaudhuri and
    Jeffrey S. Foster and Michael Hicks},
  BOOKTITLE = {Proceedings of the Workshop on Scripts to Programs (STOP)},
  MONTH = JAN,
  YEAR = 2011
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Decomposition Instead of Self-Composition for k-Safety</b>.
  Timos Antonopoulos, Paul Gazzillo, Michael Hicks, Eric Koskinen,
  Tachio Terauchi, and Shiyi Wei, November 2016.</font><p>
  We describe a novel technique for proving <EM>k</EM>-safety properties (non-interference, determinism, etc.) via a decomposition that enables one to leverage non-relational reasoning techniques. The key is the inter-operation of the following principles. First, we observe that many <EM>k</EM>-safety properties of interest have a particular structure that we call <EM>psi</EM>-quotient partitionability where <EM>psi</EM> is a <EM>k</EM>-ary formula. Second, we develop a partitioning strategy of execution traces based on the <EM>k</EM>-safety property <EM>Phi</EM> of interest such that if <EM>psi</EM> holds for <EM>k</EM> traces then they must be in the same partition. Finally, within a partition component <EM>T</EM><sub>i</sub>, we observe that we can prove <EM>k</EM>-safety by instead proving a universal property: all traces within the partition satisfy some common property <EM>P</EM><sub>i</sub>, chosen to be strong enough that it implies the <EM>k</EM>-safety property <EM>Phi</EM> of any <EM>k</EM>-tuple of traces in components <EM>T</EM><sub>i</sub>.<P>
We apply this strategy to the task of discovering timing side channels. A key feature of our approach is a demand-driven partitioning strategy that uses high/low-annotated regex-like trails to reason about one partition component of execution traces at a time. We have applied our technique in a prototype implementation tool called Blazer, based on WALA, PPL, Z3, and the brics automaton library. We have proved non-interference of (or synthesized an attack specification for) 25 programs written in Java bytecode, including 7 classic examples from the literature, and 6 examples extracted from the DARPA STAC challenge problems.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/blazer-submit.pdf">.pdf</a> ]
<a name="antopoulous16blazer"></a><pre>
@MISC{antopoulous16blazer,
  AUTHOR = {Timos Antonopoulos and Paul Gazzillo and Michael Hicks and Eric Koskinen and Tachio Terauchi and Shiyi Wei},
  TITLE = {Decomposition Instead of Self-Composition for k-Safety},
  SUBMITTED = {yes},
  MONTH = NOV,
  YEAR = 2016
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Decomposition Instead of Self-Composition for k-Safety</b>.
  Timos Antonopoulos, Paul Gazzillo, Michael Hicks, Eric Koskinen,
  Tachio Terauchi, and Shiyi Wei.
  In <i>Proceedings of the ACM Conference on Programming Language
  Design and Implementation (PLDI)</i>, June 2017.</font><p>
We present a novel approach to proving the absence of timing channels.
The idea is to partition the program's execution traces in such a way
that each partition component is checked for timing attack
resilience by a time complexity analysis and that per-component
resilience implies the resilience of the whole program.  We construct
a partition by splitting the program traces at
secret-independent branches.  This ensures that any pair of traces
with the same public input has a component containing both
traces.  Crucially, the per-component checks can be normal <em>safety
properties</em> expressed in terms of a single execution.  Our approach is
thus in contrast to prior approaches, such as <em>self-composition</em>,
that aim to reason about multiple (<EM>k</EM>&gt;= 2) executions at once.<P>
We formalize the above as an approach called <i>quotient partitioning</i>,
generalized to any <EM>k</EM>-safety property, and prove it to be sound. A
key feature of our approach is a demand-driven partitioning strategy
that uses a regex-like notion called <em>trails</em> to identify sets of
execution traces, particularly those influenced by tainted (or secret)
data.
We have applied our technique in a prototype implementation
tool called <em>Blazer</em>, based on WALA, PPL, and the Brics
automaton library.
We have proved timing-channel freedom of (or synthesized an attack
specification for) 24 programs
written in Java bytecode, including 6 classic examples from the literature and 6
examples extracted from the DARPA STAC challenge problems.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/blazer.pdf">.pdf</a> ]
<a name="antopoulous17blazer"></a><pre>
@INPROCEEDINGS{antopoulous17blazer,
  AUTHOR = {Timos Antonopoulos and Paul Gazzillo and Michael Hicks and Eric Koskinen and Tachio Terauchi and Shiyi Wei},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Programming Language Design and Implementation (PLDI)},
  TITLE = {Decomposition Instead of Self-Composition for k-Safety},
  MONTH = JUN,
  YEAR = 2017
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>The Synergy Between Programming Languages and Cryptography (Dagstuhl
  Seminar 14492)</b>.
  Gilles Barthe, Michael Hicks, Florian Kerschbaum, and Dominique
  Unruh.
  <i>Dagstuhl Reports</i>, 4(12):29-47, 2015.</font><p>
Increasingly, modern cryptography (crypto) has moved beyond the problem of secure communication to a broader consideration of securing computation. The past thirty years have seen a steady progression of both theoretical and practical advances in designing cryptographic protocols for problems such as secure multiparty computation, searching and computing on encrypted data, verifiable storage and computation, statistical data privacy, and more. More recently, the programming-languages (PL) community has begun to tackle the same set of problems, but from a different perspective, focusing on issues such as language design (e.g., new features or type systems), formal methods (e.g., model checking, deductive verification, static and dynamic analysis), compiler optimizations, and analyses of side-channel attacks and information leakage. This seminar helped to cross-fertilize ideas between the PL and crypto communities, exploiting the synergies for advancing the development of secure computing, broadly speaking, and fostering new research directions in and across both communities.
<p>[ <a href="http://drops.dagstuhl.de/opus/volltexte/2015/5004">http</a> ]
<a name="barthe2015dagstuhl"></a><pre>
@ARTICLE{barthe2015dagstuhl,
  AUTHOR = {Gilles Barthe and Michael Hicks and Florian Kerschbaum and Dominique Unruh},
  TITLE = {{The Synergy Between Programming Languages and Cryptography (Dagstuhl Seminar 14492)}},
  PAGES = {29--47},
  JOURNAL = {Dagstuhl Reports},
  ISSN = {2192-5283},
  YEAR = {2015},
  VOLUME = {4},
  NUMBER = {12},
  EDITOR = {Gilles Barthe and Michael Hicks and Florian Kerschbaum and Dominique Unruh},
  PUBLISHER = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  ADDRESS = {Dagstuhl, Germany},
  URN = {urn:nbn:de:0030-drops-50045},
  DOI = {<a href="http://dx.doi.org/10.4230/DagRep.4.12.29">http://dx.doi.org/10.4230/DagRep.4.12.29</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>The Synergy Between Programming Languages and Cryptography (Dagstuhl
  Seminar 14492)</b>.
  Gilles Barthe, Michael Hicks, Florian Kerschbaum, and Florian Unruh.
  <i>Dagstuhl Reports</i>, 4(12):29-47, 2015.</font><p>
Increasingly, modern cryptography (crypto) has moved beyond the problem of secure communication to a broader consideration of securing computation. The past thirty years have seen a steady progression of both theoretical and practical advances in designing cryptographic protocols for problems such as secure multiparty computation, searching and computing on encrypted data, verifiable storage and computation, statistical data privacy, and more. More recently, the programming-languages (PL) community has begun to tackle the same set of problems, but from a different perspective, focusing on issues such as language design (e.g., new features or type systems), formal methods (e.g., model checking, deductive verification, static and dynamic analysis), compiler optimizations, and analyses of side-channel attacks and information leakage. This seminar helped to cross-fertilize ideas between the PL and crypto communities, exploiting the synergies for advancing the development of secure computing, broadly speaking, and fostering new research directions in and across both communities.
<p>[ <a href="http://drops.dagstuhl.de/opus/volltexte/2015/5004">http</a> ]
<a name="barthe_et_al:DR:2015:5004"></a><pre>
@ARTICLE{barthe_et_al:DR:2015:5004,
  AUTHOR = {Gilles Barthe and Michael Hicks and Florian Kerschbaum and Florian Unruh},
  TITLE = {{The Synergy Between Programming Languages and Cryptography (Dagstuhl Seminar 14492)}},
  PAGES = {29--47},
  JOURNAL = {Dagstuhl Reports},
  ISSN = {2192-5283},
  YEAR = {2015},
  VOLUME = {4},
  NUMBER = {12},
  EDITOR = {Gilles Barthe and Michael Hicks and Florian Kerschbaum and Dominique Unruh},
  PUBLISHER = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  ADDRESS = {Dagstuhl, Germany},
  URN = {urn:nbn:de:0030-drops-50045},
  DOI = {<a href="http://dx.doi.org/10.4230/DagRep.4.12.29">http://dx.doi.org/10.4230/DagRep.4.12.29</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Combining Provenance and Security Policies in a Web-based Document
  Management System</b>.
  Brian Corcoran, Nikhil Swamy, and Michael Hicks.
  In <i>On-line Proceedings of the Workshop on Principles of
  Provenance (PrOPr)</i>, November 2007.
  <A HREF="http://homepages.inf.ed.ac.uk/jcheney/propr/">http://homepages.inf.ed.ac.uk/jcheney/propr/</A>.</font><p>
Provenance and security are intimately related. Cheney et
al. show that the dependencies underlying provenance
information also underly information flow security policies. Provenance
information can also play a role in history-based access control
policies.  Many real applications have the need to
combine a variety of security policies with provenance tracking. For
instance, an online stock trading website might restrict access to certain
premium features it offers using an access control policy, while at the same
time using an information flow policy to ensure that a user's sensitive
trading information is not leaked to other users. Similarly, the application
might need to track the provenance of transaction information to support an
annual financial audit while also using provenance to attest to the
reliability of stock analyses that it presents to its users.<P>
We have been exploring the interaction between provenance and security
policies while developing a document management system we call the
<em>Collaborative Planning Application</em> (CPA).  The CPA is written in
SELinks, our language for supporting user-defined, label-based security
policies. SELinks is an extension of the Links
web-programming language with means to express label-based
security policies.  Labels are associated with the data they protect by
using dependent types which, along with some syntactic restrictions, suffice
to ensure that user-defined policies enjoy <em>complete mediation</em> and
cannot be circumvented.  Our interest in provenance and
security policies is thus part of a broader exploration of how security
policies can be encoded, composed, and reasoned about within SELinks.  In
this paper, we describe the architecture of the CPA and its approach to
label-based provenance and security policies
and we sketch directions for further exploration on the interaction between
the two.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/prov.pdf">.pdf</a> ]
<a name="corcoran07provenance"></a><pre>
@INPROCEEDINGS{corcoran07provenance,
  AUTHOR = {Brian Corcoran and Nikhil Swamy and Michael Hicks},
  TITLE = {Combining Provenance and Security Policies in a Web-based
    Document Management System},
  BOOKTITLE = {On-line Proceedings of the Workshop on Principles of Provenance (PrOPr)},
  NOTE = {\url{http://homepages.inf.ed.ac.uk/jcheney/propr/}},
  LOCATION = {Edinburgh, Scotland, UK},
  MONTH = NOV,
  YEAR = 2007
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Cross-tier, Label-based Security Enforcement for Web Applications</b>.
  Brian&nbsp;J. Corcoran, Nikhil Swamy, and Michael Hicks, March 2008.</font><p>
This paper presents SELinks, an extension of the Links web
programming language, that allows a database and web server to
collaboratively enforce a security policy with high assurance. Our
approach has a number of benefits. First, the relationship between
data and its security label is made explicit by the SELinks type
system, which allows the compiler to ensure that a policy is always
correctly enforced.  Next, application-specific logic is communicated
seamlessly to the database by compiling SELinks code and values to
user-defined functions and custom datatypes, respectively, to be
stored in the database.  As a result, application-specific security
policies can be enforced at the database while processing queries,
improving both the overall efficiency of the application, as well as
ensuring that sensitive data never leaves the database needlessly. Our
experience with two sizeable web applications indicates that
cross-tier policy enforcement in SELinks is flexible, relatively easy
to use and improves efficiency, in terms of increased throughput, by
as much as an order of magnitude.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/crosstier.pdf">.pdf</a> ]
<a name="corcoran08selinks"></a><pre>
@MISC{corcoran08selinks,
  AUTHOR = {Brian J. Corcoran and Nikhil Swamy and Michael Hicks},
  TITLE = {Cross-tier, Label-based Security Enforcement for Web Applications},
  MONTH = MAR,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Cross-tier, Label-based Security Enforcement for Web Applications</b>.
  Brian&nbsp;J. Corcoran, Nikhil Swamy, and Michael Hicks.
  In <i>Proceedings of the ACM SIGMOD International Conference on
  Management of Data (SIGMOD)</i>, pages 269-282, June 2009.</font><p>
  This paper presents SELinks, a programming language focused on
  building secure multi-tier web applications.  SELinks provides a
  uniform programming model, in the style of LINQ and Ruby on Rails,
  with language syntax for accessing objects residing either in the
  database or at the server.  Object-level security policies are
  expressed as fully-customizable, first-class <em>labels</em> which may
  themselves be subject to security policies.  Access to labeled data
  is mediated via trusted, user-provided <em>policy enforcement</em>
  functions.<P>
  SELinks has two novel features that ensure security policies are
  enforced correctly and efficiently.  First, SELinks implements a
   type system called Fable that allows a protected
  object's type to refer to its protecting label. The type
  system can check that labeled data is never accessed directly by the
  program without first consulting the appropriate policy
  enforcement function.  Second, SELinks compiles policy enforcement
  code to database-resident user-defined functions that can be
  called directly during query processing.  Database-side checking
  avoids transferring data to the server needlessly, while still
  allowing policies to be expressed in a customizable and portable
  manner.<P>
  Our experience with two sizable web applications, a model
  health-care database and a secure wiki with fine-grained security
  policies, indicates that cross-tier policy enforcement in SELinks
  is flexible, relatively easy to use, and, when compared to a
  single-tier approach, improves throughput by nearly an order of
  magnitude. SELinks is freely available.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/selinks.pdf">.pdf</a> ]
<a name="corcoran09selinks"></a><pre>
@INPROCEEDINGS{corcoran09selinks,
  AUTHOR = {Brian J. Corcoran and Nikhil Swamy and Michael Hicks},
  TITLE = {Cross-tier, Label-based Security Enforcement for Web Applications},
  BOOKTITLE = {Proceedings of the {ACM} SIGMOD International Conference on Management of Data (SIGMOD)},
  MONTH = JUN,
  YEAR = 2009,
  PAGES = {269--282}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Toward On-line Schema Evolution for Non-stop Systems</b>.
  Amol Deshpande and Michael Hicks.
  Presented at the 11th High Performance Transaction Systems Workshop,
  September 2005.</font><p>
    Considers how to perform handle database schema evolution for on-line systems that are actively using the database whose schema is to be changed.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/db-dsu.pdf">.pdf</a> ]
<a name="despande05dbupdate"></a><pre>
@MISC{despande05dbupdate,
  AUTHOR = {Amol Deshpande and Michael Hicks},
  TITLE = {Toward On-line Schema Evolution for Non-stop Systems},
  HOWPUBLISHED = {Presented at the 11th High Performance Transaction Systems Workshop},
  MONTH = {September},
  LOCATION = {Pacific Grove, CA},
  YEAR = 2005
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Improving Software Quality with Static Analysis</b>.
  Jeffrey&nbsp;S. Foster, Michael&nbsp;W. Hicks, and William Pugh.
  In <i>Proceedings of the ACM Workshop on Program Analysis for
  Software Tools and Engineering (PASTE)</i>, pages 83-84, June 2007.</font><p>
At the University of Maryland, we have been working to improve the
reliability and security of software by developing new, effective
static analysis tools.  These tools scan software for bug patterns
or show that the software is free from a particular class of defects.
There are two themes common to our different projects:
<p><ol>
<li> Our ultimate focus is on <em>utility</em>: can a programmer
  actually improve the quality of his or her software using an analysis tool?
  The important first step toward answering this question is to
  engineer tools so that they can analyze existing, nontrivial
  programs, and to carefully report the results of such analyses
  experimentally.  The desire to better understand a more
  human-centered notion of utility underlies much of our
  future work.
<li> We release all of our tools open
  source (<A HREF="http://www.cs.umd.edu/projects/PL/">http://www.cs.umd.edu/projects/PL/</A>).
  This
  allows other researchers to verify our results, and to reuse some or
  all of our implementations, which often required significant
  effort to engineer.  We believe that
  releasing source code is important for accelerating the pace of
  research results software quality, and just as importantly allows
  feedback from the wider community.
</ol>
In this research group presentation, we summarize some recent work
and sketch future directions.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/paste41gp-foster.pdf">.pdf</a> ]
<a name="foster07improving"></a><pre>
@INPROCEEDINGS{foster07improving,
  AUTHOR = {Jeffrey S. Foster and Michael W. Hicks and William Pugh},
  TITLE = {Improving Software Quality with Static Analysis},
  BOOKTITLE = {Proceedings of the {ACM} Workshop on Program Analysis for Software Tools and Engineering (PASTE)},
  PAGES = {83--84},
  MONTH = JUN,
  YEAR = 2007
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Static Type Inference for Ruby</b>.
  Michael Furr, Jong hoon (David)&nbsp;An, Jeffrey&nbsp;S. Foster, and Michael
  Hicks.
  In <i>Proceedings of the ACM Symposium on Applied Computing,
  Object-oriented Programming Languages and Systems Track (OOPS)</i>, pages
  1859-1866, March 2009.</font><p>
  Many general-purpose, object-oriented scripting languages are
  dynamically typed, which provides flexibility but leaves the
  programmer without the benefits of static typing, including early
  error detection and the documentation provided by type
  annotations.  This paper describes Diamondback Ruby
  (DRuby), a tool that blends Ruby's dynamic type system with a
  static typing discipline.  DRuby provides a type
  language that is rich enough to precisely type Ruby code we have
  encountered, without unneeded complexity.
  When possible, DRuby infers static types to discover
  type errors in Ruby programs.  When necessary, the programmer can
  provide DRuby with
  annotations that assign static types to dynamic code.  These
  annotations are checked at run time, isolating type errors to
  unverified code.  We applied DRuby to a suite of benchmarks and
  found several bugs that would cause run-time type
  errors. DRuby also reported a number of warnings that reveal questionable
  programming practices in the benchmarks. We believe that DRuby
  takes a major step toward bringing the benefits
  of combined static and dynamic typing to Ruby and other
  object-oriented languages.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/druby.pdf">.pdf</a> ]
<a name="furr08druby"></a><pre>
@INPROCEEDINGS{furr08druby,
  AUTHOR = {Michael Furr and Jong-hoon (David) An and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Static Type Inference for {Ruby}},
  BOOKTITLE = {Proceedings of the {ACM} Symposium on Applied Computing, Object-oriented Programming Languages and Systems Track (OOPS)},
  MONTH = MAR,
  YEAR = 2009,
  PAGES = {1859--1866}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>The Ruby Intermediate Language</b>.
  Michael Furr, Jong hoon (David)&nbsp;An, Jeffrey&nbsp;S. Foster, and Michael
  Hicks.
  In <i>Proceedings of the ACM SIGPLAN Dynamic Languages
  Symposium (DLS)</i>, pages 89-98, October 2009.</font><p>
  Ruby is a popular, dynamic scripting language that aims to ``feel
  natural to programmers'' and give users the ``freedom to choose''
  among many different ways of doing the same thing.  While this
  arguably makes programming in Ruby easier, it makes it hard to build
  analysis and transformation tools that operate on Ruby source code.
  In this paper, we present the Ruby Intermediate Language (RIL), a
  Ruby front-end and intermediate representation that addresses these
  challenges.  Our system includes an extensible GLR parser for Ruby,
  and an automatic translation into RIL, an easy-to-analyze
  intermediate form.  This translation eliminates redundant language
  constructs, unravels the often subtle ordering among side effecting
  operations, and makes implicit interpreter operations explicit in
  its representation.<P>
  We demonstrate the usefulness of RIL by presenting a simple static
  analysis and source code transformation to eliminate null pointer
  errors in Ruby programs.  We also describe several additional useful
  features of RIL, including a pretty printer that outputs RIL as
  syntactically valid Ruby code, a dataflow analysis engine, and a
  dynamic instrumentation library for profiling source code.  We hope
  that RIL's features will enable others to more easily build analysis
  tools for Ruby, and that our design will inspire the creation of
  similar frameworks for other dynamic languages.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/ril.pdf">.pdf</a> ]
<a name="furr09ril"></a><pre>
@INPROCEEDINGS{furr09ril,
  TITLE = {The {Ruby} Intermediate Language},
  AUTHOR = {Michael Furr and Jong-hoon (David) An and Jeffrey S. Foster and Michael Hicks},
  BOOKTITLE = {Proceedings of the {ACM} {SIGPLAN} Dynamic Languages Symposium (DLS)},
  PAGES = {89--98},
  MONTH = OCT,
  YEAR = 2009
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Tests to the Left of Me, Types to the Right: How Not to Get Stuck in the
  Middle of a Ruby Execution (A Demo of Diamondback Ruby)</b>.
  Michael Furr, Jong hoon (David)&nbsp;An, Jeffrey&nbsp;S. Foster, and Michael
  Hicks.
  In <i>Proceedings of the Workshop on Scripts to Programs (STOP)</i>,
  July 2009.</font><p>
Ruby is a popular dynamic scripting language that permits
terse, expressive code, but provides no static checks to detect errors
before running the program. To address this, we have developed Diamondback
Ruby (DRuby), a tool that blends the benets of static and dynamic
typing. This paper briey describes the main features of DRuby, which
we will present in a tool demonstration. The presentation will concentrate
on the development of a small, statically typed Ruby program,
illustrating how DRuby might be used in practice. The audience will
learn about some of the practical design decisions that went into DRuby,
and how to use it to develop a type-safe Ruby program.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/rubydemo.pdf">.pdf</a> ]
<a name="furr09stop"></a><pre>
@INPROCEEDINGS{furr09stop,
  TITLE = {Tests to the Left of Me, Types to the Right: How Not to Get Stuck in the Middle of a {Ruby} Execution (A Demo of Diamondback Ruby)},
  AUTHOR = {Michael Furr and Jong-hoon (David) An and Jeffrey S. Foster and Michael Hicks},
  BOOKTITLE = {Proceedings of the Workshop on Scripts to Programs (STOP)},
  YEAR = 2009,
  MONTH = JUL
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Cyclone: a Type-safe Dialect of C</b>.
  Dan Grossman, Michael Hicks, Trevor Jim, and Greg Morrisett.
  <i>C/C++ Users Journal</i>, 23(1), January 2005.</font><p>
Cyclone is an effort to bring safety to C.  This article briefly
introduces Cyclone.
  <p>[ <a href="http://cyclone.thelanguage.org">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/cyclone-cuj.pdf">.pdf</a> ]
<a name="grossman04cuj"></a><pre>
@ARTICLE{grossman04cuj,
  AUTHOR = {Dan Grossman and Michael Hicks and Trevor Jim and Greg Morrisett},
  TITLE = {Cyclone: a Type-safe Dialect of {C}},
  JOURNAL = {{C/C++} Users Journal},
  VOLUME = 23,
  NUMBER = 1,
  MONTH = {January},
  YEAR = 2005,
  HTTP = {<a href="http://cyclone.thelanguage.org">http://cyclone.thelanguage.org</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A demo of Coco: a compiler for monadic coercions in ML</b>.
  Nataliya Guts, Michael Hicks, Nikhil Swamy, and Daan Leijen.
  In <i>Informal proceedings of the ML Workshop</i>, September 2011.</font><p>
  Combining monadic computations may induce a significant syntactic overhead. 
  To allow monadic programming in direct style, we have developed Coco, a type-based tool that automatically rewrites ML code inserting necessary binds, unit, and morphisms between monads.
 This tool demonstration will show how to take advantage of Coco to facilitate using monadic libraries in practice, 
  and will discuss possible future development of Coco to fit the actual needs of programmers.
  <p>[ <a href="http://research.microsoft.com/en-us/projects/coco/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/coco-demo.pdf">.pdf</a> ]
<a name="guts11coco"></a><pre>
@INPROCEEDINGS{guts11coco,
  TITLE = {A demo of {Coco}: a compiler for monadic coercions in {ML}},
  AUTHOR = {Nataliya Guts and Michael Hicks and Nikhil Swamy and Daan Leijen},
  BOOKTITLE = {Informal proceedings of the {ML} Workshop},
  YEAR = 2011,
  HTTP = {<a href="http://research.microsoft.com/en-us/projects/coco/">http://research.microsoft.com/en-us/projects/coco/</a>},
  MONTH = SEP
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Adapton: Composable, Demand-Driven Incremental Computation</b>.
  Matthew Hammer, Yit&nbsp;Phang Khoo, Michael Hicks, and Jeffrey&nbsp;S. Foster.
  In <i>Proceedings of the ACM Conference on Programming Language
  Design and Implementation (PLDI)</i>, June 2014.</font><p>
  Many researchers have proposed programming languages that
  support <em>incremental computation</em> (IC), which allows programs
  to be efficiently re-executed after a small change to the
  input. However, existing implementations of such languages have two
  important drawbacks. First, recomputation is oblivious to
  specific demands on the program output; that is, if a program input
  changes, all dependencies will be recomputed, even if an observer no
  longer requires certain outputs. Second, programs are made
  incremental as a unit, with little or no support for reusing
  results outside of their original context, e.g., when reordered. <P>
  To address these problems, we present <sup>CDD</sup><sub>IC</sub>, a core calculus that
  applies a <em>demand-driven</em> semantics to incremental computation,
  tracking changes in a hierarchical fashion in a novel <em>demanded
    computation graph</em>. <sup>CDD</sup><sub>IC</sub> also formalizes an explicit separation
  between inner, incremental computations and outer observers. This
  combination ensures <sup>CDD</sup><sub>IC</sub> programs only recompute computations as
  demanded by observers, and allows inner computations to be reused
  more liberally. We present Adapton, an OCaml library implementing
  <sup>CDD</sup><sub>IC</sub>. We evaluated Adapton on a range of benchmarks, and found
  that it provides reliable speedups, and in many cases dramatically
  outperforms state-of-the-art IC approaches.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/adapton-submit.pdf">.pdf</a> ]
<a name="hammer13adapton"></a><pre>
@INPROCEEDINGS{hammer13adapton,
  AUTHOR = {Matthew Hammer and Yit Phang Khoo and Michael Hicks and Jeffrey S. Foster},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Programming Language Design and Implementation (PLDI)},
  TITLE = {Adapton: Composable, Demand-Driven Incremental Computation},
  MONTH = JUN,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Adapton: Composable, Demand-Driven Incremental Computation</b>.
  Matthew Hammer, Yit&nbsp;Phang Khoo, Michael Hicks, and Jeffrey&nbsp;S. Foster.
  Technical Report CS-TR-5027, Department of Computer Science, the
  University of Maryland, College Park, July 2013.</font><p>
  Many researchers have proposed programming languages that
  support <em>incremental computation</em> (IC), which allows programs
  to be efficiently re-executed after a small change to the
  input. However, existing implementations of such languages have two
  important drawbacks. First, recomputation is oblivious to
  specific demands on the program output; that is, if a program input
  changes, all dependencies will be recomputed, even if an observer no
  longer requires certain outputs. Second, programs are made
  incremental as a unit, with little or no support for reusing
  results outside of their original context, e.g., when reordered. 
  To address these problems, we present lambdaCDDIC, a core calculus that applies
  a <em>demand-driven</em> semantics to incremental computation,
  tracking changes in a hierarchical fashion in a novel <em>demanded
    computation graph</em>. lambdaCDDIC also formalizes an explicit
  separation between inner, incremental computations and outer
  observers. This combination ensures lambdaCDDIC programs only recompute
  computations as demanded by observers, and allows inner computations
  to be composed more freely. We describe an algorithm for implementing
  lambdaCDDIC efficiently, and we present AdaptOn, a library for writing
  lambdaCDDIC-style programs in OCaml. We evaluated AdaptOn on a range of
  benchmarks, and found that it provides reliable speedups, and in
  many cases dramatically outperforms prior state-of-the-art IC approaches.
  <p>[ <a href="http://drum.lib.umd.edu/bitstream/1903/14708/1/CS-TR-5027.pdf">.pdf</a> ]
<a name="hammer13adaptontr"></a><pre>
@TECHREPORT{hammer13adaptontr,
  AUTHOR = {Matthew Hammer and Yit Phang Khoo and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Adapton: Composable, Demand-Driven Incremental Computation},
  INSTITUTION = {Department of Computer Science, the University of Maryland, College Park},
  NUMBER = {CS-TR-5027},
  MONTH = JUL,
  YEAR = 2013
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Composable, Demand-driven Incremental Computation</b>.
  Matthew Hammer, Yit&nbsp;Phang Khoo, Michael Hicks, and Jeffrey&nbsp;S. Foster,
  July 2013.</font><p>
  Many researchers have proposed programming languages that
  support <em>incremental computation</em> (IC), which allows programs
  to be efficiently re-executed after a small change to the
  input. However, existing implementations of such languages have two
  important drawbacks. First, recomputation is oblivious to
  specific demands on the program output; that is, if a program input
  changes, all dependencies will be recomputed, even if an observer no
  longer requires certain outputs. Second, programs are made
  incremental as a unit, with little or no support for reusing
  results outside of their original context, e.g., when reordered. 
  To address these problems, we present lambdaCDDIC, a core calculus that applies
  a <em>demand-driven</em> semantics to incremental computation,
  tracking changes in a hierarchical fashion in a novel <em>demanded
    computation graph</em>. lambdaCDDIC also formalizes an explicit
  separation between inner, incremental computations and outer
  observers. This combination ensures lambdaCDDIC programs only recompute
  computations as demanded by observers, and allows inner computations
  to be composed more freely. We describe an algorithm for implementing
  lambdaCDDIC efficiently, and we present AdaptOn, a library for writing
  lambdaCDDIC-style programs in OCaml. We evaluated AdaptOn on a range of
  benchmarks, and found that it provides reliable speedups, and in
  many cases dramatically outperforms prior state-of-the-art IC approaches.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/cddic.pdf">.pdf</a> ]
<a name="hammer13cddic"></a><pre>
@MISC{hammer13cddic,
  AUTHOR = {Matthew Hammer and Yit Phang Khoo and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Composable, Demand-driven Incremental Computation},
  MONTH = JUL,
  YEAR = 2013,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Incremental Computation with Names</b>.
  Matthew Hammer, Kyle Headley, Nicholas Labich, Jeffrey&nbsp;S. Foster,
  Michael Hicks, David&nbsp;Van Horn, and Joshua Dunfield.
  In <i>Proceedings of the ACM Conference on Object-Oriented
  Programming Languages, Systems, and Applications (OOPSLA)</i>, October 2015.</font><p>
  Over the past thirty years, there has been significant progress in
  developing general-purpose, language-based approaches to
  <em>incremental computation</em>, which aims to efficiently update the
  result of a computation when an input is changed. A key design
  challenge in such approaches is how to provide efficient incremental
  support for a broad range of programs.  In this paper, we argue that
  first-class <em>names</em> are a critical linguistic feature for
  efficient incremental computation. Names identify computations to be
  reused across differing runs of a program, and making them first
  class gives programmers a high level of control over reuse. We
  demonstrate the benefits of names by presenting Nominal Adapton, an
  ML-like language for incremental computation with names. We describe
  how to use Nominal Adapton to efficiently incrementalize several
  standard programming patterns-including maps, folds, and
  unfolds-and show how to build efficient, incremental probabilistic
  trees and tries. Since Nominal Adapton's implementation is subtle,
  we formalize it as a core calculus and prove it is
  <em>from-scratch consistent</em>, meaning it always produces the same
  answer as simply re-running the computation. Finally, we demonstrate
  that Nominal Adapton can provide large speedups over both
  from-scratch computation and Adapton, a previous state-of-the-art
  incremental system.
  <p>[ <a href="http://arxiv.org/abs/1503.07792">http</a> ]
<a name="hammer14nominal"></a><pre>
@INPROCEEDINGS{hammer14nominal,
  AUTHOR = {Matthew Hammer and Kyle Headley and Nicholas Labich and Jeffrey S. Foster and Michael Hicks and David Van Horn and Joshua Dunfield},
  TITLE = {Incremental Computation with Names},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Object-Oriented Programming Languages, Systems, and Applications (OOPSLA)},
  MONTH = OCT,
  YEAR = 2015
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Systematic Testing for Dynamically Updatable Software</b>.
  Chris Hayden, Eric&nbsp;A. Hardisty, Michael Hicks, and Jeffrey&nbsp;S. Foster,
  March 2009.</font><p>
  Recent years have seen significant advances in dynamic software
  updating (DSU) systems, which allow programs to be patched
  on the fly.  However, a significant challenge remains: How can we
  ensure the act of applying a patch does not itself introduce errors?
  In this paper, we address this problem by presenting a new systematic
  testing methodology for updatable programs.
  Our idea is to transform standard 
  system tests into <em>update tests</em> that execute as before, but
  each transformed test applies a patch at a different <em>update point</em> 
  during execution.  To mitigate the increase in the number of tests, we
  developed an algorithm for <em>test suite 
    minimization</em> that finds a subset of update points that, if fully
  tested, yields the equivalent to full update point coverage.  We
  implemented our approach and evaluated it on OpenSSH and vsftpd, two
  widely used server applications.  We found that minimization is
  highly effective; that when updates are allowed almost anywhere,
  many update tests fail; and that excluding type unsafe update points
  eliminates nearly, but not quite all, failing update tests.
<p><a name="hayden09systematic"></a><pre>
@MISC{hayden09systematic,
  AUTHOR = {Chris Hayden and Eric A. Hardisty and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Systematic Testing for Dynamically Updatable Software},
  MONTH = MAR,
  YEAR = 2009,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Efficient Systematic Testing for Dynamically Updatable Software</b>.
  Christopher&nbsp;M. Hayden, Eric&nbsp;A. Hardisty, Michael Hicks, and
  Jeffrey&nbsp;S. Foster.
  In <i>Proceedings of the Workshop on Hot Topics in Software
  Upgrades (HotSWUp)</i>, October 2009.
  Invited article.</font><p>
  Recent years have seen significant advances in dynamic software
  updating (DSU) systems, which allow programs to be patched
  on the fly.  However, a significant challenge remains: How can we
  ensure the act of applying a patch does not itself introduce errors?
  In this paper, we address this problem by presenting a new systematic
  testing methodology for updatable programs.
  Our idea is to transform standard
  system tests into <em>update tests</em> that execute as before, but
  each transformed test applies a patch at a different <em>update point</em> during
  execution.  To mitigate the increase in the number of tests, we
  developed an algorithm for <em>test suite
    minimization</em> that finds a subset of update points that, if fully
  tested, yields the equivalent to full update point coverage.  We
  implemented our approach and evaluated it on OpenSSH and Vsftpd, two
  widely used server applications.  We found that minimization is
  highly effective, reducing the number of update tests required
  for full coverage by 93%.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsutesting.pdf">.pdf</a> ]
<a name="hayden09testing"></a><pre>
@INPROCEEDINGS{hayden09testing,
  AUTHOR = {Christopher M. Hayden and Eric A. Hardisty and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Efficient Systematic Testing for Dynamically Updatable Software},
  BOOKTITLE = {Proceedings of the Workshop on Hot Topics in Software Upgrades (HotSWUp)},
  NOTE = {Invited article},
  YEAR = 2009,
  MONTH = OCT
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A Testing Based Empirical Study of Dynamic Software Update Safety
  Restrictions</b>.
  Christopher&nbsp;M. Hayden, Eric&nbsp;A. Hardisty, Michael Hicks, and
  Jeffrey&nbsp;S. Foster.
  Technical Report CS-TR-4949, University of Maryland, Department of
  Computer Science, November 2009.</font><p>
  Recent years have seen significant advances in dynamic software
  updating (DSU) systems, which allow programs to be patched on the
  fly.  Most DSU systems employ automatic safety checks to avoid
  applying a patch if doing so may lead to incorrect behavior.
  This
  paper presents what we believe is the first comprehensive empirical evaluation
  of the two most significant DSU safety checks: <em>activeness
    safety</em> (AS), which disallows patches that modify functions
  on the stack, and <em>con-freeness safety</em>
  (CFS), which allows modifications to active functions, but only
  when doing so will be type safe.<P>
  To measure the checks' effectiveness, we tested them
  against three years of updates to OpenSSH and
  vsftpd.  We performed this testing using a novel DSU testing methodology that
  systematically applies updates throughout the
  execution of a test suite.  After testing updates to both
  applications in this way, we tracked how often the safety checks
  allow updates and which updates result in
  test failures.  We found that updating without safety checks
  produced
  many failures, and that both AS and CFS dramatically reduced, but did not
  fully eliminate, these failures.  CFS yielded more failures
  than AS, but
  AS was more restrictive than CFS, disallowing far
  more successful updates.
  Our results suggest that neither AS nor CFS is likely
  suitable for general-purpose DSU on its own.
  Indeed, we found that selecting update points manually could
  avoid all failures while still permitting sufficient updates.
  Our results present a challenge and important insights for future
  work: to discover 
  safe and sufficient update points fully automatically.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsutesting-tr.pdf">.pdf</a> ]
<a name="hayden09testingTR"></a><pre>
@TECHREPORT{hayden09testingTR,
  TITLE = {A Testing Based Empirical Study of Dynamic Software Update Safety Restrictions},
  AUTHOR = {Christopher M. Hayden and Eric A. Hardisty and Michael Hicks and Jeffrey S. Foster},
  NUMBER = {CS-TR-4949},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  YEAR = 2009,
  MONTH = NOV
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evaluating Dynamic Software Update Safety Using Efficient Systematic
  Testing</b>.
  Christopher&nbsp;M. Hayden, Eric&nbsp;A. Hardisty, Michael Hicks, and
  Jeffrey&nbsp;S. Foster, April 2010.</font><p>
  Dynamic software updating (DSU) systems, which allow programs to be
  patched on the fly, often employ automatic safety checks to avoid
  applying a patch that may lead to incorrect behavior.
  This paper presents what we believe is the first significant empirical 
  evaluation of two DSU safety checks: <em>activeness safety</em> (AS)
  and <em>con-freeness safety</em> (CFS).
  To measure the checks' effectiveness, we developed a novel approach
  to systematically test dynamic updates by forcing updates at
  each of the <em>update points</em> encountered during system test
  execution. To mitigate the
  increase in the number of tests, we developed an algorithm for
  <em>test suite minimization</em> which proved highly effective 
  in our experiments.  Using this approach, we
  systematically tested a series of dynamic patches to 
  OpenSSH, vsftpd and ngIRCd.  
  AS and CFS prevented most, but not all, dynamic update 
  failures;
  CFS allowed more failures than AS, but
  AS was more restrictive, disallowing many more successful updates.
  Our results show that neither AS nor CFS can be completely
  relied upon to produce correct dynamic updates, and our investigation
  points to the reasons why.
  Our work represents an important step, and important insights, toward
  developing safe, easy-to-use DSU systems.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsutesting-journal.pdf">.pdf</a> ]
<a name="hayden10testing-journal"></a><pre>
@MISC{hayden10testing-journal,
  AUTHOR = {Christopher M. Hayden and Eric A. Hardisty and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Evaluating Dynamic Software Update Safety Using Efficient Systematic Testing},
  YEAR = 2010,
  MONTH = APR,
  OPTSUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Specifying and Verifying the Correctness of Dynamic Software Updates</b>.
  Christopher&nbsp;M. Hayden, Stephen Magill, Michael Hicks, Nate Foster,
  and Jeffrey&nbsp;S. Foster.
  Technical Report CS-TR-4997, University of Maryland Department of
  Computer Science, November 2011.
  Extended version of VSTTE'12 paper with proofs of theorems and
  additional discussion.</font><p>
Dynamic software updating (DSU) systems allow running programs to be patched on-the-fly to add features or fix bugs. While dynamic updates can be tricky to write, techniques for establishing their correctness have received little attention. In this paper, we present the first methodology for automatically verifying the correctness of dynamic updates. Programmers express the desired properties of an updated execution using client-oriented specifications (CO-specs), which can describe a wide range of client-visible behaviors. We verify CO-specs automatically by using off-the-shelf tools to analyze a merged program, which is a combination of the old and new versions of a program. We formalize the merging transformation and prove it correct. We have implemented a program merger for C, and applied it to updates for the Redis key-value store and several synthetic programs. Using Thor, a verification tool, we could verify many of the synthetic programs; using Otter, a symbolic executor, we could analyze every program, often in less than a minute. Both tools were able to detect faulty patches and incurred only a factor-of-four slowdown, on average, compared to single version programs.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsucorrectnessTR.pdf">.pdf</a> ]
<a name="hayden11dsucorrectTR"></a><pre>
@TECHREPORT{hayden11dsucorrectTR,
  TITLE = {Specifying and Verifying the Correctness of Dynamic Software Updates},
  AUTHOR = {Christopher M. Hayden and Stephen Magill and Michael Hicks and Nate Foster and Jeffrey S. Foster},
  INSTITUTION = {University of Maryland Department of Computer Science},
  NUMBER = {CS-TR-4997},
  YEAR = 2011,
  MONTH = NOV,
  NOTE = {Extended version of VSTTE'12 paper with proofs of theorems and additional discussion}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Kitsune: Efficient, General-purpose Dynamic Software Updating for C</b>.
  Christopher&nbsp;M. Hayden, Edward&nbsp;K. Smith, Michail Denchev, Michael
  Hicks, and Jeffrey&nbsp;S. Foster, January 2012.</font><p>
  Dynamic software updating (DSU) systems allow programs to be updated
  while running, thereby allowing developers to add features and fix
  bugs without downtime.  This paper introduces Kitsune, a new DSU
  system for C whose design has three notable features.  First,
  Kitsune's updating mechanism updates the whole program, not
  individual functions.  This mechanism is more flexible than most
  prior approaches and places no restrictions on data representations
  or allowed compiler optimizations.  Second, Kitsune makes the
  important aspects of updating explicit in the program text, making
  its semantics easy to understand while keeping programmer work to a
  minimum.  Finally, the programmer can write simple specifications to
  direct Kitsune to generate code that traverses and transforms
  old-version state for use by the new code; such state
  transformation is often necessary, and is significantly more
  difficult in prior DSU systems.  We have used Kitsune
  to update five popular, open-source, single- and multi-threaded
  programs, and find that few program changes are required to use
  Kitsune, and that it incurs essentially no performance overhead.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/kitsune.pdf">.pdf</a> ]
<a name="hayden11kitsune"></a><pre>
@MISC{hayden11kitsune,
  TITLE = {Kitsune: Efficient, General-purpose Dynamic Software Updating for {C}},
  AUTHOR = {Christopher M. Hayden and Edward K. Smith and Michail Denchev and Michael Hicks and Jeffrey S. Foster},
  MONTH = JAN,
  YEAR = 2012,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evaluating Dynamic Software Update Safety Using Efficient Systematic
  Testing</b>.
  Christopher&nbsp;M. Hayden, Edward&nbsp;K. Smith, Eric&nbsp;A. Hardisty, Michael
  Hicks, and Jeffrey&nbsp;S. Foster.
  Technical Report CS-TR-4993, University of Maryland, Department of
  Computer Science, September 2011.</font><p>
Dynamic software updating (DSU) systems patch programs on the fly without incurring downtime. To avoid failures due to the updating process itself, many DSU systems employ timing restrictions. However, timing restrictions are theoretically imperfect, and their practical effectiveness is an open question. This paper presents the first significant empirical evaluation of three popular timing restrictions: activeness safety (AS), which prevents updates to active functions; confreeness safety (CFS), which only allows modifications to active functions when doing so is provably type-safe; and manual identification of the event-handling loops during which an update may occur. We evaluated these timing restrictions using a series of DSU patches to three programs: OpenSSH, vsftpd, and ngIRCd.We systematically applied updates at each distinct update point reached during execution of a suite of system tests for these programs to determine which updates pass and which fail. We found that all three timing restrictions prevented most failures, but only manual identification allowed none. Further, although CFS and AS allowed many more update points, manual identification still supported updates with minimal delay. Finally, we found that manual identification required the least developer effort. Overall, we conclude that manual identification is most effective.
  <p>[ <a href="http://drum.lib.umd.edu//handle/1903/12146">http</a> ]
<a name="hayden11testing-TR"></a><pre>
@TECHREPORT{hayden11testing-TR,
  AUTHOR = {Christopher M. Hayden and Edward K. Smith and Eric A. Hardisty and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Evaluating Dynamic Software Update Safety Using Efficient Systematic Testing},
  NUMBER = {CS-TR-4993},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  YEAR = 2011,
  MONTH = SEP
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evaluating Dynamic Software Update Safety Using Efficient Systematic
  Testing</b>.
  Christopher&nbsp;M. Hayden, Edward&nbsp;K. Smith, Eric&nbsp;A. Hardisty, Michael
  Hicks, and Jeffrey&nbsp;S. Foster.
  <i>IEEE Transactions on Software Engineering</i>, 99(PrePrints),
  September 2011.</font><p>
  Dynamic software updating (DSU) systems patch programs
  on the fly without incurring downtime.
  To avoid failures due to the updating process itself, 
  many DSU systems employ <em>timing restrictions</em>.
  However, timing restrictions are theoretically
  imperfect, and their practical effectiveness is an open question.<P>
  This paper presents the first significant empirical evaluation of
  three popular timing restrictions: <em>activeness safety</em> (AS),
  which prevents updates to active functions;
  <em>con-freeness safety</em> (CFS), which only allows modifications to
  active functions when doing so is provably type-safe; and
  <em>manual identification</em> of the event-handling loops during which an
  update may occur.<P>
  We evaluated these timing restrictions using a series of DSU patches
  to three programs:
  OpenSSH, vsftpd, and ngIRCd.  We systematically applied
  updates at each distinct update point reached during execution of 
  a suite of system tests for these programs
  to determine which updates pass and which fail.
  We found that all
  three timing restrictions prevented most
  failures, but only manual identification allowed none.  Further,
   although CFS and AS allowed many
  more update points, manual identification
  still supported updates with minimal delay.  Finally, 
  we found that manual identification required the least developer effort.
  Overall, we conclude that manual identification is most effective.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsutesting-journal.pdf">.pdf</a> ]
<a name="hayden11testing-journal"></a><pre>
@ARTICLE{hayden11testing-journal,
  AUTHOR = {Christopher M. Hayden and Edward K. Smith and Eric A. Hardisty and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Evaluating Dynamic Software Update Safety Using Efficient Systematic Testing},
  JOURNAL = {IEEE Transactions on Software Engineering},
  VOLUME = {99},
  NUMBER = {PrePrints},
  YEAR = 2011,
  MONTH = SEP
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Specifying and Verifying the Correctness of Dynamic Software Updates</b>.
  Christopher&nbsp;M. Hayden, Stephen Magill, Michael Hicks, Nate Foster,
  and Jeffrey&nbsp;S. Foster.
  In <i>Proceedings of the International Conference on Verified
  Software: Theories, Tools, and Experiments (VSTTE)</i>, pages 278-293,
  January 2012.</font><p>
  Dynamic software updating
  (DSU) systems allow running programs to be patched on-the-fly
  to add features or fix bugs.  While dynamic updates can be tricky
  to write, techniques for establishing their
  correctness have received little attention.
  In this paper, we present the first methodology for automatically
  verifying the correctness of dynamic updates.  Programmers express
  the desired properties of an updated execution using
  <em>client-oriented specifications</em> (CO-specs), which can describe a
  wide range of client-visible behaviors.
  We verify CO-specs automatically by using off-the-shelf tools to 
  analyze a <em>merged</em> program, which is a combination of the old and new
  versions of a program, along with the CO-spec.
  We formalize the merging transformation and prove it correct.  We
  also implemented a C program merger, and applied it to updates
  for the Redis key-value server and to updates for several synthetic
  programs.  Using the Thor verification tool we could verify
  many of the synthetic programs, while Otter, a symbolic
  executor, could analyze every program, often in less than a minute.
  Both tools were able to detect faulty patches and incurred only a
  factor-of-four slowdown, on average, compared with analyzing individual
  versions.
  <p>[ <a href="http://drum.lib.umd.edu/bitstream/1903/12167/1/CS-TR-4997.pdf">.pdf</a> ]
<a name="hayden12dsucorrect"></a><pre>
@INPROCEEDINGS{hayden12dsucorrect,
  TITLE = {Specifying and Verifying the Correctness of Dynamic Software Updates},
  AUTHOR = {Christopher M. Hayden and Stephen Magill and Michael Hicks and Nate Foster and Jeffrey S. Foster},
  BOOKTITLE = {Proceedings of the International Conference on Verified Software: Theories, Tools, and Experiments ({VSTTE})},
  YEAR = 2012,
  MONTH = JAN,
  PAGES = {278--293}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Kitsune: Efficient, General-purpose Dynamic Software Updating for C</b>.
  Christopher&nbsp;M. Hayden, Edward&nbsp;K. Smith, Michail Denchev, Michael
  Hicks, and Jeffrey&nbsp;S. Foster.
  In <i>Proceedings of the ACM Conference on Object-Oriented
  Programming Languages, Systems, and Applications (OOPSLA)</i>, October 2012.</font><p>
  Dynamic software updating (DSU) systems allow programs to be updated
  while running, thereby permitting developers to add features and fix
  bugs without downtime.  This paper introduces Kitsune, a new DSU
  system for C whose design has three notable features.  First,
  Kitsune's updating mechanism updates the whole program, not
  individual functions.  This mechanism is more flexible than most
  prior approaches and places no restrictions on data representations
  or allowed compiler optimizations.  Second, Kitsune makes the
  important aspects of updating explicit in the program text, making
  the program's semantics easy to understand while minimizing programmer effort.  Finally, the programmer can write simple specifications to
  direct Kitsune to generate code that traverses and transforms
  old-version state for use by new code; such state
  transformation is often necessary, and is significantly more
  difficult in prior DSU systems.  We have used Kitsune
  to update five popular, open-source, single- and multi-threaded
  programs, and find that few program changes are required to use
  Kitsune, and that it incurs essentially no performance overhead.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/kitsune.pdf">.pdf</a> ]
<a name="hayden12kitsune"></a><pre>
@INPROCEEDINGS{hayden12kitsune,
  TITLE = {Kitsune: Efficient, General-purpose Dynamic Software Updating for {C}},
  AUTHOR = {Christopher M. Hayden and Edward K. Smith and Michail Denchev and Michael Hicks and Jeffrey S. Foster},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Object-Oriented Programming Languages, Systems, and Applications (OOPSLA)},
  MONTH = OCT,
  YEAR = 2012
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A Study of Dynamic Software Update Quiescence for Multithreaded Programs</b>.
  Christopher&nbsp;M. Hayden, Karla Saur, Michael Hicks, and Jeffrey&nbsp;S.
  Foster.
  In <i>Proceedings of the Workshop on Hot Topics in Software
  Upgrades (HotSWUp)</i>, pages 6-10, June 2012.</font><p>
  Dynamic software updating (DSU) techniques show great promise in
  allowing vital software services to be upgraded without downtime,
  avoiding dropped connections and the loss of critical program state.
  For multithreaded programs, DSU systems must balance
  <em>correctness</em> and <em>timeliness</em>.  To simplify reasoning
  that an update is correct, we could limit updates to take place only
  when all threads have blocked at well-defined <em>update
    points</em>.  However, several researchers have pointed out that this
  approach poses the risk of delaying an update for too long, even
  indefinitely, and therefore have developed fairly complicated
  mechanisms to mitigate the risk.  This paper argues that such
  mechanisms are unnecessary by demonstrating empirically that 
  many multithreaded programs can be updated
  with minimal delay using only a small number of manually annotated
  update points.  Our study of the time taken for all of the
  threads in six real-world, event-driven programs to reach
  their update points ranged from 0.155 to 107.558 ms,
  and most were below 1 ms.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/quiescence.pdf">.pdf</a> ]
<a name="hayden12quiescence"></a><pre>
@INPROCEEDINGS{hayden12quiescence,
  TITLE = {A Study of Dynamic Software Update Quiescence for Multithreaded Programs},
  AUTHOR = {Christopher M. Hayden and Karla Saur and Michael Hicks and Jeffrey S. Foster},
  BOOKTITLE = {Proceedings of the Workshop on Hot Topics in Software Upgrades (HotSWUp)},
  MONTH = JUN,
  PAGES = {6--10},
  YEAR = 2012
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evaluating Dynamic Software Update Safety Using Efficient Systematic
  Testing</b>.
  Christopher&nbsp;M. Hayden, Edward&nbsp;K. Smith, Eric&nbsp;A. Hardisty, Michael
  Hicks, and Jeffrey&nbsp;S. Foster.
  <i>IEEE Transactions on Software Engineering</i>, 38(6):1340-1354,
  December 2012.
  Accepted September 2011.</font><p>
  Dynamic software updating (DSU) systems patch programs
  on the fly without incurring downtime.
  To avoid failures due to the updating process itself, 
  many DSU systems employ <em>timing restrictions</em>.
  However, timing restrictions are theoretically
  imperfect, and their practical effectiveness is an open question.<P>
  This paper presents the first significant empirical evaluation of
  three popular timing restrictions: <em>activeness safety</em> (AS),
  which prevents updates to active functions;
  <em>con-freeness safety</em> (CFS), which only allows modifications to
  active functions when doing so is provably type-safe; and
  <em>manual identification</em> of the event-handling loops during which an
  update may occur.<P>
  We evaluated these timing restrictions using a series of DSU patches
  to three programs:
  OpenSSH, vsftpd, and ngIRCd.  We systematically applied
  updates at each distinct update point reached during execution of 
  a suite of system tests for these programs
  to determine which updates pass and which fail.
  We found that all
  three timing restrictions prevented most
  failures, but only manual identification allowed none.  Further,
   although CFS and AS allowed many
  more update points, manual identification
  still supported updates with minimal delay.  Finally, 
  we found that manual identification required the least developer effort.
  Overall, we conclude that manual identification is most effective.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsutesting-journal.pdf">.pdf</a> ]
<a name="hayden12testing-journal"></a><pre>
@ARTICLE{hayden12testing-journal,
  AUTHOR = {Christopher M. Hayden and Edward K. Smith and Eric A. Hardisty and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Evaluating Dynamic Software Update Safety Using Efficient Systematic Testing},
  JOURNAL = {IEEE Transactions on Software Engineering},
  VOLUME = {38},
  NUMBER = {6},
  PAGES = {1340--1354},
  YEAR = 2012,
  MONTH = DEC,
  NOTE = {Accepted September 2011},
  DOI = {<a href="http://doi.ieeecomputersociety.org/10.1109/TSE.2011.101">http://doi.ieeecomputersociety.org/10.1109/TSE.2011.101</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Efficient, General-purpose Dynamic Software Updating for C</b>.
  Christopher&nbsp;M. Hayden, Karla Saur, Edward&nbsp;K. Smith, Michael Hicks,
  and Jeffrey&nbsp;S. Foster, June 2013.
  Extended version of OOPSLA'12 paper.</font><p>
Dynamic software updating (DSU) systems facilitate software updates to
running programs, thereby permitting developers to add features and
fix bugs without downtime. This paper introduces Kitsune, a DSU
system for C that updates the whole program, rather than individual
functions. Kitsune makes the important aspects of updating explicit in the program text,
making the program's semantics easy to
understand. The programmer can write simple specifications
to direct Kitsune to generate code that traverses and transforms
old-version state for use by new code. We find that Kitsune requires
few program changes and provides fast update times and essentially no
overhead.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/kitsune-journal.pdf">.pdf</a> ]
<a name="hayden13kitsune-journal"></a><pre>
@MISC{hayden13kitsune-journal,
  TITLE = {Efficient, General-purpose Dynamic Software Updating for C},
  AUTHOR = {Christopher M. Hayden and Karla Saur and Edward K. Smith and Michael Hicks and Jeffrey S. Foster},
  NOTE = {Extended version of OOPSLA'12 paper},
  MONTH = JUN,
  YEAR = 2013,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Efficient, General-purpose Dynamic Software Updating for C</b>.
  Christopher&nbsp;M. Hayden, Karla Saur, Edward&nbsp;K. Smith, Michael Hicks,
  and Jeffrey&nbsp;S. Foster.
  <i>ACM Transactions on Programming Languages and Systems
  (TOPLAS)</i>, 36(4):13, October 2014.</font><p>
  Dynamic software updating (DSU) systems 
  facilitate software updates to running programs,
  thereby permitting developers to add features and fix
  bugs without downtime.  This paper introduces Kitsune, a DSU
  system for C. Kitsune's design has three notable features.  First,
  Kitsune updates the whole program, rather than
  individual functions, using a mechanism that places no restrictions on data
  representations or allowed compiler optimizations.
  Second, Kitsune makes the
  important aspects of updating explicit in the program text, making
  the program's semantics easy to understand while minimizing programmer effort.
  Finally, the programmer can write simple specifications to
  direct Kitsune to generate code that traverses and transforms
  old-version state for use by new code; such state
  transformation is often necessary and is significantly more
  difficult in prior DSU systems.  We have used Kitsune
  to update six popular, open-source, single- and multi-threaded
  programs, and find that few program changes are required to use
  Kitsune, that it incurs essentially no performance overhead,
  and that update times are fast.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/kitsune-journal.pdf">.pdf</a> ]
<a name="hayden14kitsune-journal"></a><pre>
@ARTICLE{hayden14kitsune-journal,
  TITLE = {Efficient, General-purpose Dynamic Software Updating for C},
  AUTHOR = {Christopher M. Hayden and Karla Saur and Edward K. Smith and Michael Hicks and Jeffrey S. Foster},
  JOURNAL = {{ACM} Transactions on Programming Languages and Systems (TOPLAS)},
  MONTH = OCT,
  YEAR = 2014,
  VOLUME = 36,
  NUMBER = 4,
  PAGES = 13
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>State Transfer for Clear and Efficient Runtime Upgrades</b>.
  Christopher&nbsp;M. Hayden, Edward&nbsp;K. Smith, Michael Hicks, and Jeffrey&nbsp;S.
  Foster.
  In <i>Proceedings of the Workshop on Hot Topics in Software
  Upgrades (HotSWUp)</i>, pages 179-184, April 2011.</font><p>

Dynamic software updating (DSU), the practice of updating software while it
executes, is a lively area of research.  The DSU approach most
prominent in both commercial and research systems is <em>in-place
  updating</em>, in which patches containing program modifications are
loaded into a running
process.  However, in-place updating suffers from several problems: it
requires complex tool support, it may adversely affect the performance of
normal execution, it requires challenging reasoning to understand the
behavior of an updated program, and it requires extra effort to modify
program state to be compatible with an update.<P>
This paper presents preliminary work investigating the potential for <em>state
transfer updating</em> to address these problems.  State transfer updates
work by launching a new process running the updated program version
and transferring program state from the running process to the updated
version.  In this paper, we describe the use and implementation of
Ekiden, a new state transfer updating library for C/C++ programs.
Ekiden seeks to redress the difficulties of in-place updating, and we report
on our experience updating vsftpd using Ekiden.  This initial
experience suggests that state transfer provides the availability
benefits of in-place DSU approaches while addressing many of their
shortcomings.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsuxfer.pdf">.pdf</a> ]
<a name="hayden2011xfer"></a><pre>
@INPROCEEDINGS{hayden2011xfer,
  TITLE = {State Transfer for Clear and Efficient Runtime Upgrades},
  AUTHOR = {Christopher M. Hayden and Edward K. Smith and Michael
    Hicks and Jeffrey S. Foster},
  BOOKTITLE = {Proceedings of the Workshop on Hot Topics in Software Upgrades (HotSWUp)},
  PAGES = {179--184},
  MONTH = APR,
  YEAR = 2011
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>User-specified Adaptive Scheduling in a Streaming Media Network</b>.
  Michael Hicks, Adithya Nagarajan, and Robbert van Renesse.
  Technical Report CS-TR-4430, University of Maryland Department of
  Computer Science, March 2003.</font><p>
In disaster and combat situations, mobile cameras
and other sensors transmit real-time data, used by
many operators and/or analysis tools. Unfortunately,
in the face of limited, unreliable resources, and varying demands, not all users may be able to get the  
fidelity they require. This paper describes MediaNet, a distributed multi-media processing system designed with the above scenarios in mind. Unlike past  
approaches, MediaNet's users can intuitively specify how the system should adapt based on their individual needs. MediaNet uses both local and on-line global resource scheduling to improve user performance and network utilization, and adapts without requiring underlying support for resource reservations. Performance experiments show that our 
scheduling algorithm is reasonably fast, and that user 
performance and network utilization are both significantly improved.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/medianet-extended.pdf">.pdf</a> ]
<a name="hicks03medianettr"></a><pre>
@TECHREPORT{hicks03medianettr,
  AUTHOR = {Michael Hicks and Adithya Nagarajan and Robbert van Renesse},
  TITLE = {User-specified Adaptive Scheduling in a Streaming Media Network},
  NUMBER = {CS-TR-4430},
  INSTITUTION = {University of Maryland Department of Computer Science},
  MONTH = MAR,
  YEAR = {2003}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Safe and Flexible Memory Management in Cyclone</b>.
  Michael Hicks, Greg Morrisett, Dan Grossman, and Trevor Jim.
  Technical Report CS-TR-4514, University of Maryland Department of
  Computer Science, July 2003.</font><p>
Cyclone is a type-safe programming language intended for applications
requiring control over memory management.  Our previous work on
Cyclone included support for stack allocation, lexical region
allocation, and a garbage-collected heap.  We achieved safety (i.e.,
prevented dangling pointers) through a region-based type-and-effects
system.  This paper describes some new memory-management mechanisms
that we have integrated into Cyclone: dynamic regions, unique
pointers, and reference-counted objects.  Our experience shows that
these new mechanisms are well suited for the timely recovery of
objects in situations where it is awkward to use lexical regions.
Crucially, programmers can write reusable functions without
unnecessarily restricting callers' choices among the variety of
memory-management options. To achieve this goal, Cyclone employs a
combination of polymorphism and scoped constructs that temporarily let
us treat objects as if they were allocated in a lexical region.  In
our experience, our new constructs can significantly improve
application performance, while adding a modest programming overhead.
  <p>[ <a href="http://cyclone.thelanguage.org">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/CS-TR-4514.pdf">.pdf</a> ]
<a name="hicks03safe"></a><pre>
@TECHREPORT{hicks03safe,
  AUTHOR = {Michael Hicks and Greg Morrisett and Dan Grossman and Trevor Jim},
  TITLE = {Safe and Flexible Memory Management in {Cyclone}},
  NUMBER = {CS-TR-4514},
  INSTITUTION = {University of Maryland Department of Computer Science},
  MONTH = {July},
  YEAR = {2003},
  HTTP = {<a href="http://cyclone.thelanguage.org">http://cyclone.thelanguage.org</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Experience with Safe Manual Memory Management in Cyclone</b>.
  Michael Hicks, Greg Morrisett, Dan Grossman, and Trevor Jim.
  In <i>Proceedings of the ACM International Symposium on Memory
  Management (ISMM)</i>, pages 73-84, October 2004.
  An abstract of this paper appeared in SPACE `04,
  <A HREF="http://www.diku.dk/topps/space2004/space_final/hicks-grossman-jim.pdf">http://www.diku.dk/topps/space2004/space_final/hicks-grossman-jim.pdf</A>.</font><p>
  The goal of the Cyclone project is to investigate 
  type safety for low-level languages such as C.  Our
  hardest challenge has been providing programmers control over memory
  management while retaining type safety.  This paper reports on our
  experience trying to integrate and effectively use two previously
  proposed, type-safe memory management mechanisms: statically-scoped regions 
  and unique pointers.  We found that these typing mechanisms can be combined 
  to build alternative memory-management abstractions, such as reference 
  counted objects and arenas with dynamic lifetimes, and thus provide
  a flexible basis.  Our experience-porting C code and building new
  applications for resource-constrained systems-confirms that experts can use 
  these features to improve memory footprint and
  sometimes to improve
  throughput when used instead of, or in combination with, a conservative 
  garbage collector.  
<p>[ <a href="http://cyclone.thelanguage.org">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/ismm.pdf">.pdf</a> ]
<a name="hicks04experience"></a><pre>
@INPROCEEDINGS{hicks04experience,
  AUTHOR = {Michael Hicks and Greg Morrisett and Dan Grossman and Trevor Jim},
  TITLE = {Experience with Safe Manual Memory Management in {Cyclone}},
  BOOKTITLE = {Proceedings of the {ACM} International Symposium on Memory Management (ISMM)},
  NOTE = {An abstract of this paper appeared in SPACE `04, \url{http://www.diku.dk/topps/space2004/space_final/hicks-grossman-jim.pdf}},
  HTTP = {<a href="http://cyclone.thelanguage.org">http://cyclone.thelanguage.org</a>},
  MONTH = {October},
  YEAR = 2004,
  PAGES = {73--84}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Updating of Information-Flow Policies</b>.
  Michael Hicks, Stephen Tse, Boniface Hicks, and Steve Zdancewic.
  In <i>Proceedings of the International Workshop on Foundations of
  Computer Security (FCS)</i>, pages 7-18, June 2005.</font><p>
Applications that manipulate sensitive information should ensure
<em>end-to-end</em> security by satisfying two properties:
<em>sound execution</em> and some form of <em>noninterference</em>.  By
the former, we mean the program should always perform actions in
keeping with its current policy, and by the latter we mean that these
actions should never cause high-security information to be visible to
a low-security observer.  Over the last decade, security-typed
languages have been developed that exhibit these properties,
increasingly improving so as to model important features of real
programs.
No current security-typed language, however, permits general changes
to security policies in use by running programs.  This paper presents
a simple information flow type system that allows for dynamic
security policy updates while ensuring sound execution and a relaxed
form of noninterference we term
<em>noninterference between updates</em>.  We see this work as an
important step toward using language-based techniques to ensure
end-to-end security for realistic applications.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/secupdate.pdf">.pdf</a> ]
<a name="hicks05secupdate"></a><pre>
@INPROCEEDINGS{hicks05secupdate,
  AUTHOR = {Michael Hicks and Stephen Tse and Boniface Hicks and Steve Zdancewic},
  TITLE = {Dynamic Updating of Information-Flow Policies},
  BOOKTITLE = {Proceedings of the International Workshop on Foundations of Computer Security (FCS)},
  MONTH = {June},
  PAGES = {7--18},
  LOCATION = {Chicago, IL},
  YEAR = {2005}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Inferring Locking for Atomic Sections</b>.
  Michael Hicks, Jeffrey&nbsp;S. Foster, and Polyvios Pratikakis.
  In <i>On-line Proceedings of the ACM SIGPLAN Workshop on Languages,
  Compilers, and Hardware Support for Transactional Computing (TRANSACT)</i>, June
  2006.
 
  <A HREF="http://www.cs.purdue.edu/homes/jv/events/TRANSACT/transact-06.tgz">http://www.cs.purdue.edu/homes/jv/events/TRANSACT/transact-06.tgz</A>.</font><p>
  Software transactions allow the programmer to specify sections of
  code that should be serializable, without the programmer needing to
  worry about exactly how atomicity is enforced.  Recent research
  proposes using optimistic concurrency to implement transactions.  In
  this short paper, we propose a pessimistic lock-based technique that
  uses the results of static whole-program analysis to enforce
  atomicity.  The input to our analysis is a program that contains
  programmer-specified atomic sections and calls to fork.  We present
  a sharing inference algorithm that uses the results of points-to
  analysis to determine which memory locations are shared.  Our
  analysis uses <em>continuation effects</em> to track the locations
  accessed after a point in the program.  This allows data to be
  thread-local before a fork and thread-shared afterward.  We then 
  present a mutex inference algorithm that determines a sufficient set
  of locks to guard accesses to shared locations.  After mutex
  inference, a compiler adds the appropriate lock acquires and
  releases to the beginning and end of atomic sections.  Our algorithm
  is efficient, and provides parallelism according to precision of the
  alias analysis while minimizing the number of required locks.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/infatomic.pdf">.pdf</a> ]
<a name="hicks06atomic"></a><pre>
@INPROCEEDINGS{hicks06atomic,
  TITLE = {Inferring Locking for Atomic Sections},
  AUTHOR = {Michael Hicks and Jeffrey S. Foster and Polyvios Pratikakis},
  BOOKTITLE = {On-line Proceedings of the ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT)},
  NOTE = {\url{http://www.cs.purdue.edu/homes/jv/events/TRANSACT/transact-06.tgz}},
  YEAR = 2006,
  MONTH = JUN
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Trusted Declassification: high-level policy for a security-typed
  language</b>.
  Boniface Hicks, Dave King, Patrick McDaniel, and Michael Hicks.
  In <i>Proceedings of the ACM SIGPLAN Workshop on Programming
  Languages and Analysis for Security (PLAS)</i>, pages 65-74, June 2006.</font><p>
  Security-typed languages promise to be a powerful tool with which
  provably secure software applications may be developed.  Programs
  written in these languages enforce a strong, global policy of
  <em>noninterference</em> which ensures that high-security data will
  not be observable on low-security channels.  Because noninterference
  is typically too strong a property, most programs use some form of
  <em>declassification</em> to selectively leak high security information,
  e.g. when performing a password check or data encryption.
  Unfortunately, such a declassification is often expressed as an
  operation within a given program, rather than as part of a global
  policy, making reasoning about the security implications of a policy
  more difficult.<P>
  In this paper, we propose a simple idea we call <i>trusted
  declassification</i> in which special <em>declassifier</em> functions are
  specified as part of the global policy.  In particular, individual
  principals declaratively specify which declassifiers they trust so
  that all information flows implied by the policy can be reasoned
  about in absence of a particular program.  We formalize our approach
  for a Java-like language and prove a modified form of
  noninterference which we call <em>noninterference modulo trusted methods</em>.  We have implemented
  our approach as an extension to Jif and provide some of our
  experience using it to build a secure e-mail client.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/plas06-final-dist.pdf">.pdf</a> ]
<a name="hicks06trusted"></a><pre>
@INPROCEEDINGS{hicks06trusted,
  TITLE = {Trusted Declassification: high-level policy for a security-typed language},
  AUTHOR = {Boniface Hicks and Dave King and Patrick McDaniel and Michael Hicks},
  BOOKTITLE = {Proceedings of the {ACM SIGPLAN} Workshop on Programming Languages and Analysis for Security (PLAS)},
  MONTH = {June},
  PAGES = {65--74},
  YEAR = 2006
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Trusted Declassification: high-level policy for a security-typed language
  (Extended version)</b>.
  Boniface Hicks, Dave King, Patrick McDaniel, and Michael Hicks.
  Technical Report NAS-TR-033-2006, Department of Computer Science and
  Engineering, the Pennsylvania State University, June 2006.
  Extended version of the PLAS 2006 paper with full formal development.</font><p>
  Security-typed languages promise to be a powerful tool with which
  provably secure software applications may be developed.  Programs
  written in these languages enforce a strong, global policy of
  <em>noninterference</em> which ensures that high-security data will
  not be observable on low-security channels.  Because noninterference
  is typically too strong a property, most programs use some form of
  <em>declassification</em> to selectively leak high security information,
  e.g. when performing a password check or data encryption.
  Unfortunately, such a declassification is often expressed as an
  operation within a given program, rather than as part of a global
  policy, making reasoning about the security implications of a policy
  more difficult.<P>
  In this paper, we propose a simple idea we call <i>trusted
  declassification</i> in which special <em>declassifier</em> functions are
  specified as part of the global policy.  In particular, individual
  principals declaratively specify which declassifiers they trust so
  that all information flows implied by the policy can be reasoned
  about in absence of a particular program.  We formalize our approach
  for a Java-like language and prove a modified form of
  noninterference which we call <em>noninterference modulo trusted methods</em>.  We have implemented
  our approach as an extension to Jif and provide some of our
  experience using it to build a secure e-mail client.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/plas06-tr.pdf">.pdf</a> ]
<a name="hicks06trustedtr"></a><pre>
@TECHREPORT{hicks06trustedtr,
  TITLE = {Trusted Declassification: high-level policy for a security-typed language (Extended version)},
  AUTHOR = {Boniface Hicks and Dave King and Patrick McDaniel and Michael Hicks},
  INSTITUTION = {Department of Computer Science and Engineering, the Pennsylvania State University},
  NUMBER = {NAS-TR-033-2006},
  NOTE = {Extended version of the PLAS 2006 paper with full formal development},
  MONTH = {June},
  YEAR = 2006
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Toward Specifying and Validating Cross-Domain Policies</b>.
  Michael Hicks, Nikhil Swamy, and Simon Tsang.
  Technical Report CS-TR-4870, Department of Computer Science,
  University of Maryland, April 2007.</font><p>
Formal security policies are extremely useful for two related reasons.
First, they allow a policy to be considered in isolation, separate
from programs under the purview of the policy and separate from the
implementation of the policy's enforcement.  Second, policies can be
checked for compliance against higher-level security goals by using
automated analyses.  By contrast, ad hoc enforcement mechanisms (for
which no separate policies are specified) enjoy neither benefit, and
non-formal policies enjoy the first but not the second.<P>
We would like to understand how best to define
(and enforce) multi-level security policies when information must be
shared across domains that have varying levels of trust (the so-called
``cross domain'' problem).  Because we wish to show such policies meet
higher-level security goals with high assurance, we are interested in
specifying cross domain policies formally, and then reasoning about
them using automated tools.  In this report, we briefly survey
work that presents formal security policies with cross-domain
concerns, in particular with respect to the problem of
<em>downgrading</em>.  We also describe correctness properties for such
policies, all based on <em>noninterference</em>.  Finally, we briefly
discuss recently-developed tools for analyzing formal security
policies; though no existing tools focus on the analysis of
downgrading-oriented policies, existing research points the way
to providing such support.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/xdom-tr.pdf">.pdf</a> ]
<a name="hicks07xdomtr"></a><pre>
@TECHREPORT{hicks07xdomtr,
  AUTHOR = {Michael Hicks and Nikhil Swamy and Simon Tsang},
  TITLE = {Toward Specifying and Validating Cross-Domain Policies},
  INSTITUTION = {Department of Computer Science, University of Maryland},
  NUMBER = {CS-TR-4870},
  YEAR = 2007,
  MONTH = APR
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Adapting Scrum to Managing a Research Group</b>.
  Michael Hicks and Jeffrey&nbsp;S. Foster.
  Technical report, University of Maryland, Department of Computer
  Science, June 2008.</font><p>Score is an adaptation of the Scrum agile software development methodology to the task of managing Ph.D. students in an academic research group.    This paper describes Score, and our experience using it over the last year and a half.  We have found that Score enables us-faculty and students-to be more efficient and thereby more productive, and enhances the cohesion of our research group.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/score.pdf">.pdf</a> ]
<a name="hicks08score"></a><pre>
@TECHREPORT{hicks08score,
  TITLE = {Adapting {Scrum} to Managing a Research Group},
  AUTHOR = {Michael Hicks and Jeffrey S. Foster},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  MONTH = JUN,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Adapting Scrum to Managing a Research Group</b>.
  Michael Hicks and Jeffrey&nbsp;S. Foster.
  Technical report, University of Maryland, Department of Computer
  Science, June 2008.</font><p>Scram is an adaptation of the Scrum agile software development methodology to the task of managing Ph.D. students in an academic research group.    This paper describes Scram, and our experience using it over the last year and a half.  We have found that Scram enables us-faculty and students-to be more efficient and thereby more productive, and enhances the cohesion of our research group.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/scram.pdf">.pdf</a> ]
<a name="hicks08scram"></a><pre>
@TECHREPORT{hicks08scram,
  TITLE = {Adapting {Scrum} to Managing a Research Group},
  AUTHOR = {Michael Hicks and Jeffrey S. Foster},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  MONTH = JUN,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Trusted Declassification: Policy Infrastructure for a Security-Typed
  Language</b>.
  Boniface Hicks, Dave King, Patrick McDaniel, and Michael Hicks, June
  2008.
  Full version of PLAS 06 paper.</font><p>
Security-typed languages are a powerful tools for developing verifiably secure software applications. Programs written in these languages enforce a strong, global policy of noninterference which ensures that high-security data will not be observable on low-security channels. Because noninterference is typically too strong a property, most programs use some form of declassification to selectively leak high security information, e.g. when performing a password check or data encryption. Unfortunately, such a declassification is often expressed as an operation within a given program, rather than as part of a global policy, making reasoning about the security implications of a policy difficult. <P>
In this paper, we propose a simple idea we call trusted declassification in which special declassifier functions are specified as part of the global policy. In particular, individual principals declaratively specify which declassifiers they trust so all information flows implied by the policy can be reasoned about in absence of a particular program. We formalize our approach for a Java-like language and prove a modified form of noninterference which we call noninterference modulo trusted methods. We have implemented our approach as an extension to Jif, a security-typed variant of Java, and provide our experience using it to build a secure email client, JPmail.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/tdeclass-submitted.pdf">.pdf</a> ]
<a name="hicks08trusted"></a><pre>
@MISC{hicks08trusted,
  TITLE = {Trusted Declassification: Policy Infrastructure for a Security-Typed Language},
  AUTHOR = {Boniface Hicks and Dave King and Patrick McDaniel and Michael Hicks},
  MONTH = {June},
  NOTE = {Full version of PLAS 06 paper},
  SUBMITTED = {yes},
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Score: Agile Research Group Management</b>.
  Michael Hicks and Jeffrey&nbsp;S. Foster.
  <i>Communications of the ACM</i>, May 2009.
  To appear.</font><p>Score is an adaptation of the Scrum agile software development methodology to the task of managing Ph.D. students in an academic research group.    This paper describes Score, conceived in October 2006, and our experience using it.  We have found that Score enables us-faculty and students-to be more efficient and thereby more productive, and enhances the cohesion of our research group.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/score-short.pdf">.pdf</a> ]
<a name="hicks09scoreshort"></a><pre>
@ARTICLE{hicks09scoreshort,
  TITLE = {Score: Agile Research Group Management},
  AUTHOR = {Michael Hicks and Jeffrey S. Foster},
  JOURNAL = {Communications of the {ACM}},
  MONTH = MAY,
  YEAR = 2009,
  NOTE = {To appear}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Scram: Agile Research Group Management</b>.
  Michael Hicks and Jeffrey&nbsp;S. Foster, May 2009.</font><p>Scram is an adaptation of the Scrum agile software development methodology to the task of managing Ph.D. students in an academic research group.    This paper describes Scram, conceived in October 2006, and our experience using it.  We have found that Scram enables us-faculty and students-to be more efficient and thereby more productive, and enhances the cohesion of our research group.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/scram-short.pdf">.pdf</a> ]
<a name="hicks09scramshort"></a><pre>
@MISC{hicks09scramshort,
  TITLE = {Scram: Agile Research Group Management},
  AUTHOR = {Michael Hicks and Jeffrey S. Foster},
  MONTH = MAY,
  YEAR = 2009,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Adapting Scrum to Managing a Research Group</b>.
  Michael Hicks and Jeffrey&nbsp;S. Foster.
  Technical Report CS-TR-4966, University of Maryland, Department of
  Computer Science, September 2010.</font><p>Score is an adaptation of the Scrum agile software development methodology to the task of managing Ph.D. students in an academic research group.    This paper describes Score, conceived in October 2006, and our experience using it.  We have found that Score enables us-faculty and students-to be more efficient and thereby more productive, and enhances the cohesion of our research group.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/score.pdf">.pdf</a> ]
<a name="hicks10score"></a><pre>
@TECHREPORT{hicks10score,
  TITLE = {Adapting {Scrum} to Managing a Research Group},
  AUTHOR = {Michael Hicks and Jeffrey S. Foster},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  NUMBER = {CS-TR-4966},
  MONTH = SEP,
  YEAR = 2010
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Score: Agile Research Group Management</b>.
  Michael Hicks and Jeffrey&nbsp;S. Foster.
  <i>Communications of the ACM</i>, 53(10):30-31, October 2010.</font><p>Score is an adaptation of the Scrum agile software development methodology to the task of managing Ph.D. students in an academic research group.    This paper describes Score, conceived in October 2006, and our experience using it.  We have found that Score enables us-faculty and students-to be more efficient and thereby more productive, and enhances the cohesion of our research group.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/score-short.pdf">.pdf</a> ]
<a name="hicks10scoreshort"></a><pre>
@ARTICLE{hicks10scoreshort,
  TITLE = {Score: Agile Research Group Management},
  AUTHOR = {Michael Hicks and Jeffrey S. Foster},
  JOURNAL = {Communications of the {ACM}},
  MONTH = OCT,
  VOLUME = {53},
  NUMBER = {10},
  PAGES = {30--31},
  YEAR = 2010
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Polymonads</b>.
  Nataliya Guts, Michael Hicks, Nikhil Swamy, Daan Leijen, and Gavin
  Bierman, July 2012.</font><p>
  From their semantic origins to their use in structuring effectful
  computations, monads are now also used as a programming pattern to
  structure code in a number of important scenarios, including
  functional reactivity, information flow tracking and probabilistic
  computation. However, whilst these examples are inspired by monads
  they are not strictly speaking monadic but rather something more
  general. The first contribution of this paper is the definition of a
  new structure, the polymonad, which subsumes monads and encompasses
  the monad-like programming patterns that we have observed.  A
  concern is that given such a general setting, a program would
  quickly become polluted with polymonadic coercions, making it hard
  to read and maintain.  The second contribution of this paper is to
  build on previous work to define a polymorphic type inference
  algorithm that supports programming with polymonads using a direct
  style, e.g., as if computations of type <EM>M</EM> <EM>tau</EM> were expressions
  of type <EM>tau</EM>.  During type inference the program is rewritten to
  insert the necessary polymonadic coercions, a process that we prove
  is coherent-all sound rewritings produce programs with the same
  semantics.  The resulting programming style is powerful and
  lightweight.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/polymonads.pdf">.pdf</a> ]
<a name="hicks12polymonad"></a><pre>
@MISC{hicks12polymonad,
  TITLE = {Polymonads},
  AUTHOR = {Nataliya Guts and Michael Hicks and Nikhil Swamy and Daan Leijen and Gavin Bierman},
  MONTH = JUL,
  YEAR = 2012,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Polymonads</b>.
  Nataliya Guts, Michael Hicks, Nikhil Swamy, Daan Leijen, and Gavin
  Bierman.
  Technical Report XXX, University of Maryland Department of Computer
  Science, July 2012.
  Extended version of POPL'13 submission.</font><p>
  From their semantic origins to their use in structuring effectful
  computations, monads are now also used as a programming pattern to
  structure code in a number of important scenarios, including
  functional reactivity, information flow tracking and probabilistic
  computation. However, whilst these examples are inspired by monads
  they are not strictly speaking monadic but rather something more
  general. The first contribution of this paper is the definition of a
  new structure, the polymonad, which subsumes monads and encompasses
  the monad-like programming patterns that we have observed.  A
  concern is that given such a general setting, a program would
  quickly become polluted with polymonadic coercions, making it hard
  to read and maintain.  The second contribution of this paper is to
  build on previous work to define a polymorphic type inference
  algorithm that supports programming with polymonads using a direct
  style, e.g., as if computations of type <EM>M</EM> <EM>tau</EM> were expressions
  of type <EM>tau</EM>.  During type inference the program is rewritten to
  insert the necessary polymonadic coercions, a process that we prove
  is coherent-all sound rewritings produce programs with the same
  semantics.  The resulting programming style is powerful and
  lightweight.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/polymonadsTR.pdf">.pdf</a> ]
<a name="hicks12polymonadTR"></a><pre>
@TECHREPORT{hicks12polymonadTR,
  TITLE = {Polymonads},
  AUTHOR = {Nataliya Guts and Michael Hicks and Nikhil Swamy and Daan Leijen and Gavin Bierman},
  NOTE = {Extended version of POPL'13 submission},
  INSTITUTION = {University of Maryland Department of Computer Science},
  NUMBER = {XXX},
  MONTH = JUL,
  YEAR = 2012
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>POPL'12 Program Chair's Report (or, how to run a medium-sized
  conference)</b>.
  Michael Hicks.
  <i>SIGPLAN Notices</i>, 47(4), April 2012.</font><p>
It was a pleasure and a privilege to serve as the program committee
(PC) chair of the 39th Symposium on the Principles of Programming
Languages (POPL).  This paper describes the review process we used,
why we used it, and an assessment of how it worked out.<P>
We made some substantial changes to the review process this year, most
notably by incorporating a form of double-blind reviewing.  These and
other changes were made in an attempt to improve accepted paper
quality, as well as to improve review quality and fairness (both of which
ultimately support paper quality).<P>
Much of this paper argues in favor of these changes based on
principle, i.e., why one might think the process should increase
quality.  Ideally we could also evaluate the process directly, i.e.,
by showing that this year's program was better than it would have been
under a different review process.  Unfortunately, I think it would be
very difficult to efficiently evaluate a review process directly
(e.g., by having two committees and two review processes on the same
papers).  As such, I exercised a more tractable alternative: I polled
the authors and reviewers to report on their experience, and to see
whether that experience convinces them that the process has merit.  In
most cases, the answer was ``yes.''
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/popl12recap.pdf">.pdf</a> ]
<a name="hicks12popl"></a><pre>
@ARTICLE{hicks12popl,
  TITLE = {{POPL}'12 Program Chair's Report (or, how to run a medium-sized conference)},
  AUTHOR = {Michael Hicks},
  JOURNAL = {SIGPLAN Notices},
  VOLUME = 47,
  NUMBER = 4,
  YEAR = 2012,
  MONTH = APR
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Polymonadic Programming</b>.
  Michael Hicks, Gavin Bierman, Nataliya Guts, Daan Leijen, and Nikhil
  Swamy.
  In <i>Proceedings of the Fifth Workshop on Mathematically
  Structured Functional Programming (MSFP)</i>, April 2014.</font><p>
  Monads are a popular tool for the working functional programmer to
  structure effectful computations. This paper presents
  <em>polymonads</em>, a generalization of monads. Polymonads give the
  familiar monadic bind the more general type 
  for all <EM>a</EM>,<EM>b</EM>. <EM>L</EM> <EM>a</EM> -&gt; (<EM>a</EM> -&gt; <EM>M</EM> <EM>b</EM>) -&gt; <EM>N</EM> <EM>b</EM>, to
  compose computations with three different kinds of effects, rather
  than just one. Polymonads subsume monads and parameterized monads,
  and can express other constructions, including precise
  type-and-effect systems and information flow tracking; more
  generally, polymonads correspond to Tate's <em>productoid</em>
  semantic model. We show how to equip a core language (called <EM>lambda</EM><sub>PM</sub>)
  with syntactic support for programming with polymonads. Type
  inference and elaboration in <EM>lambda</EM><sub>PM</sub> allows programmers to write
  polymonadic code directly in an ML-like syntax-our algorithms
  compute principal types and produce elaborated programs wherein
  the binds appear explicitly. Furthermore, we prove that the
  elaboration is <em>coherent</em>: no matter which (type-correct) binds
  are chosen, the elaborated program's semantics will be the
  same. Pleasingly, the inferred types are easy to read: the polymonad
  laws justify (sometimes dramatic) simplifications, but with no
  effect on a type's generality.<P>
<a href="http://www.cs.umd.edu/~mwh/polymonads-impl.tgz">A prototype implementation of <EM>lambda</EM><sub>PM</sub></a> is available.
  <p>[ <a href="http://arxiv.org/pdf/1406.2060v1.pdf">.pdf</a> ]
<a name="hicks14polymonad"></a><pre>
@INPROCEEDINGS{hicks14polymonad,
  TITLE = {Polymonadic Programming},
  AUTHOR = {Michael Hicks and Gavin Bierman and Nataliya Guts and Daan Leijen and Nikhil Swamy},
  BOOKTITLE = {Proceedings of the Fifth Workshop on Mathematically Structured Functional Programming (MSFP)},
  MONTH = APR,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Defeating Scripting Attacks with Browser-Enforced Embedded Policies</b>.
  Trevor Jim, Nikhil Swamy, and Michael Hicks.
  In <i>Proceedings of the International World Wide Web Conference
  (WWW)</i>, pages 601-610, May 2007.</font><p>
  Web sites that accept and display content such as wiki articles or
  comments typically filter the content to prevent injected script
  code from running in browsers that view the site.  The diversity of
  browser rendering algorithms and the desire to allow rich content
  make filtering quite difficult, however, and attacks such as the
  Samy and Yamanner worms have exploited filtering weaknesses.  This
  paper proposes a simple alternative mechanism for preventing script
  injection called Browser-Enforced Embedded Policies (BEEP).  The idea is that a
  web site can embed a policy in its pages that specifies which
  scripts are allowed to run.  The browser, which knows exactly when
  it will run a script, can enforce this policy perfectly.  We have
  added BEEP support to several browsers, and built tools to
  simplify adding policies to web applications.  We found that
  supporting BEEP in browsers requires only small and localized
  modifications, modifying web applications requires minimal effort,
  and enforcing policies is generally lightweight.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/jssecurity.pdf">.pdf</a> ]
<a name="jim07beep"></a><pre>
@INPROCEEDINGS{jim07beep,
  AUTHOR = {Trevor Jim and Nikhil Swamy and Michael Hicks},
  TITLE = {Defeating Scripting Attacks with Browser-Enforced Embedded Policies},
  BOOKTITLE = {Proceedings of the International World Wide Web Conference (WWW)},
  PAGES = {601--610},
  MONTH = MAY,
  YEAR = 2007,
  LOCATION = {Banff, Alberta, Canada}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Directing JavaScript with Arrows (poster summary)</b>.
  Yit&nbsp;Phang Khoo, Michael Hicks, Jeffrey&nbsp;S. Foster, and Vibha Sazawal.
  In <i>Poster Proceedings of the ACM International Conference on
  Functional Programming (ICFP)</i>, September 2008.</font><p>
Event-driven programming in JavaScript often leads to code that
is messy and hard to maintain. We have found <em>arrows</em>, a generalization
of <em>monads</em>, to be an elegant solution to this problem. Our
arrow-based <em>Arrowlets</em> library makes it easy to compose eventdriven
programs in modular units of code. In particular, we show
how to implement <em>drag-and-drop</em> modularly using arrows.
  <p>[ <a href="http://www.cs.umd.edu/~khooyp/papers/poster-summary.pdf">.pdf</a> ]
<a name="khoo08jsarrows"></a><pre>
@INPROCEEDINGS{khoo08jsarrows,
  AUTHOR = {Yit Phang Khoo and Michael Hicks and Jeffrey S. Foster and Vibha Sazawal},
  TITLE = {Directing JavaScript with Arrows (poster summary)},
  BOOKTITLE = {Poster Proceedings of the {ACM} International Conference on Functional Programming (ICFP)},
  MONTH = SEP,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Directing JavaScript with Arrows (Functional Pearl)</b>.
  Yit&nbsp;Phang Khoo, Michael Hicks, Jeffrey&nbsp;S. Foster, and Vibha Sazawal.
  Technical Report CS-TR-4923, University of Maryland, Department of
  Computer Science, August 2008.
  Extended version of ICFP 2008 poster.</font><p>
JavaScript, being a single-threaded language, makes extensive use of event-driven programming to enable responsive web applications. However, standard approaches to sequencing events are messy, and often lead to code that is difficult to understand and maintain. We have found that arrows, a generalization of monads, are an elegant solution to this problem. Arrows allow us to easily write asynchronous programs in small, modular units of code, and flexibly compose them in many different ways, while nicely abstracting the details of asynchronous program composition. In particular, we show how to use arrows to construct a variety of state machines, such as autoscrollers and drag-and-drop handlers.
<p>[ <a href="http://hdl.handle.net/1903/8400">http</a> ]
<a name="khoo08jsarrowstr"></a><pre>
@TECHREPORT{khoo08jsarrowstr,
  AUTHOR = {Yit Phang Khoo and Michael Hicks and Jeffrey S. Foster and Vibha Sazawal},
  TITLE = {Directing JavaScript with Arrows (Functional Pearl)},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  NUMBER = {CS-TR-4923},
  MONTH = AUG,
  YEAR = 2008,
  NOTE = {Extended version of ICFP 2008 poster}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Path Projection for User-Centered Static Analysis Tools</b>.
  Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, Michael Hicks, and Vibha Sazawal.
  In <i>Proceedings of the ACM Workshop on Program Analysis for
  Software Tools and Engineering (PASTE)</i>, pages 57-63, November 2008.</font><p>
  The research and industrial communities have made
  great strides in developing sophisticated defect detection tools
  based on static analysis.  To date most of the work in this
  area has focused on developing novel static analysis
  <em>algorithms</em>, but has neglected study of other aspects of static
  analysis <em>tools</em>, particularly user interfaces.  In this work,
  we present a novel user interface toolkit called Path Projection
  that helps users visualize, navigate, and understand program paths,
  a common component of many tools' error reports.
  We performed a controlled user study to measure the benefit of Path
  Projection in triaging error reports from Locksmith, a data race
  detection tool for C.  We found that Path Projection improved
  participants' time to complete this task without affecting
  accuracy, while participants felt Path Projection was useful and
  strongly preferred it to a more standard viewer.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/pathproj-short.pdf">.pdf</a> ]
<a name="khoo08pathproj"></a><pre>
@INPROCEEDINGS{khoo08pathproj,
  AUTHOR = {Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks and Vibha Sazawal},
  TITLE = {Path Projection for User-Centered Static Analysis Tools},
  BOOKTITLE = {Proceedings of the {ACM} Workshop on Program Analysis for Software Tools and Engineering (PASTE)},
  PAGES = {57--63},
  MONTH = NOV,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Path Projection for User-Centered Static Analysis Tools (long version)</b>.
  Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, Michael Hicks, and Vibha Sazawal.
  Technical Report CS-TR-4919, University of Maryland, Department of
  Computer Science, August 2008.</font><p>
The research and industrial communities have made great strides in developing sophisticated defect detection tools based on static analysis. However, to date most of the work in this area has focused on developing novel static analysis algorithms, and neglected study of other aspects of static analysis tools, in particular user interfaces. In this work, we present a novel user interface toolkit called Path Projection that helps users visualize, navigate, and understand program paths, a common component of many static analysis tools error reports. We performed a controlled user study to measure the benefit of Path Projection in triaging error reports from Locksmith, a data race detection tool for C. We found that Path Projection improved participants time to complete this task, without affecting accuracy, and that participants felt Path Projection was useful.
<p>[ <a href="http://hdl.handle.net/1903/8369">http</a> ]
<a name="khoo08pathprojtr"></a><pre>
@TECHREPORT{khoo08pathprojtr,
  AUTHOR = {Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks and Vibha Sazawal},
  TITLE = {Path Projection for User-Centered Static Analysis Tools (long version)},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  NUMBER = {CS-TR-4919},
  MONTH = AUG,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Directing JavaScript with Arrows</b>.
  Yit&nbsp;Phang Khoo, Michael Hicks, Jeffrey&nbsp;S. Foster, and Vibha Sazawal.
  In <i>Proceedings of the ACM SIGPLAN Dynamic Languages
  Symposium (DLS)</i>, pages 49-58, October 2009.</font><p>
  JavaScript programmers make extensive use of event-driven
  programming to help build responsive web applications. However,
  standard approaches to sequencing events are messy, and often lead
  to code that is difficult to understand and maintain. We have found
  that <em>arrows</em>, a generalization of <em>monads</em>, are an
  elegant solution to this problem. Arrows allow us to easily write
  asynchronous programs in small, modular units of code, and flexibly
  compose them in many different ways, while nicely abstracting the
  details of asynchronous program composition.  In this paper, we
  present Arrowlets, a new JavaScript library that offers arrows to
  the everyday JavaScript programmer. We show how to use Arrowlets to
  construct a variety of state machines, including state machines that
  branch and loop.  We also demonstrate how Arrowlets separate
  computation from composition with examples such as a drag-and-drop
  handler and a bubblesort animation.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/jsarrows.pdf">.pdf</a> ]
<a name="khoo09arrowlets"></a><pre>
@INPROCEEDINGS{khoo09arrowlets,
  AUTHOR = {Yit Phang Khoo and Michael Hicks and Jeffrey S. Foster and Vibha Sazawal},
  TITLE = {Directing {JavaScript} with Arrows},
  BOOKTITLE = {Proceedings of the {ACM} {SIGPLAN} Dynamic Languages Symposium (DLS)},
  PAGES = {49--58},
  MONTH = OCT,
  YEAR = 2009
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Triaging Checklists: a Substitute for a PhD in Static Analysis</b>.
  Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, Michael Hicks, and Vibha Sazawal.
  In <i>Proceedings of the Workshop on the Evaluation and Usability
  of Programming Languages and Tools (PLATEAU)</i>, October 2009.</font><p>
Static analysis tools have achieved great success in recent years in automating the process of
detecting defects in software. However, these sophisticated tools have yet to gain widespread
adoption, since many of these tools remain too difficult to understand and use. In
previous work, we discovered that even with an effective code visualization tool, users still found
it hard to determine if warnings reported by these tools were true errors or false warnings.
The fundamental problem users face is to understand enough of the underlying algorithm to determine
if a warning is caused by imprecision in the algorithm. In our current work, we propose to use
<em>triaging checklists</em> to provide users with systematic guidance to identify false warnings by
taking into account specific sources of imprecision in the particular tool. Additionally, we plan to
provide <em>checklist assistants</em>, which is a library of simple analyses designed to aid users in
answering checklist questions.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/ppchecklists.pdf">.pdf</a> ]
<a name="khoo09checklist"></a><pre>
@INPROCEEDINGS{khoo09checklist,
  AUTHOR = {Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks and Vibha Sazawal},
  TITLE = {Triaging Checklists: a Substitute for a {PhD} in Static Analysis},
  BOOKTITLE = {Proceedings of the Workshop on the Evaluation and Usability of Programming Languages and Tools (PLATEAU)},
  MONTH = OCT,
  YEAR = 2009
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Expositor: Scriptable Time-Travel Debugging with First Class Traces</b>.
  Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, and Michael Hicks, August 2012.</font><p>
  We present Expositor, a new debugging environment that combines
  scripting and time-travel debugging to allow developers to automate
  complex debugging tasks. The fundamental abstraction provided by
  Expositor is the execution <em>trace</em>, which is a time-indexed
  sequence of program state snapshots. Developers can manipulate traces as if they were simple
  lists with operations such as map and filter. Under the hood,
  Expositor efficiently implements traces as lazy, sparse
  interval trees, whose contents are materialized on demand.
  Expositor also provides a novel data
  structure, the <em>edit hash array mapped trie</em>, which is a lazy
  implementation of sets, maps, multisets, and multimaps that enables
  developers to maximize the efficiency of their debugging scripts.  We have used
  Expositor to debug a stack overflow and to unravel a subtle
  data race in Firefox. We believe that
  Expositor represents an important step forward in improving the
  technology for diagnosing complex, hard-to-understand bugs.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/expositor-submitted.pdf">.pdf</a> ]
<a name="khoo12expositor"></a><pre>
@MISC{khoo12expositor,
  AUTHOR = {Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Expositor: Scriptable Time-Travel Debugging with First Class Traces},
  MONTH = AUG,
  YEAR = 2012,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Expositor: Scriptable Time-Travel Debugging with First Class Traces (Full
  version)</b>.
  Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, and Michael Hicks, December 2013.
  Extended version of ICSE'13 paper.</font><p>
  We present Expositor, a new debugging environment that combines
  scripting and time-travel debugging to allow programmers to automate
  complex debugging tasks. The fundamental abstraction provided by
  Expositor is the <em>execution trace</em>, which is a time-indexed
  sequence of program state snapshots or projections thereof.
  Programmers can manipulate traces as if they were simple
  lists with operations such as map and filter. Under the hood,
  Expositor efficiently implements traces as lazy, sparse
  interval trees whose contents are materialized on demand.
  Expositor also provides a novel data
  structure, the <em>edit hash array mapped trie</em>, which is a lazy
  implementation of sets, maps, multisets, and multimaps that enables
  programmers to maximize the efficiency of their debugging scripts.
  In our micro-benchmarks, Expositor scripts are faster than
  the equivalent non-lazy scripts for common debugging scenarios.  We have also used
  Expositor to debug a stack overflow, and to unravel a subtle
  data race in Firefox. We believe that
  Expositor represents an important step forward in improving the
  technology for diagnosing complex, hard-to-understand bugs.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/expositor-tse-submitted.pdf">.pdf</a> ]
<a name="khoo13expositor-journal"></a><pre>
@MISC{khoo13expositor-journal,
  AUTHOR = {Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Expositor: Scriptable Time-Travel Debugging with First Class Traces (Full version)},
  NOTE = {Extended version of ICSE'13 paper},
  MONTH = DEC,
  YEAR = 2013
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Expositor: Scriptable Time-Travel Debugging with First Class Traces</b>.
  Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  In <i>Proceedings of the International Conference on Software
  Engineering (ICSE)</i>, May 2013.</font><p>
  We present Expositor, a new debugging environment that combines
  scripting and time-travel debugging to allow programmers to automate
  complex debugging tasks. The fundamental abstraction provided by
  Expositor is the execution <em>trace</em>, which is a time-indexed
  sequence of program state snapshots. Programmers can manipulate traces as if they were simple
  lists with operations such as map and filter. Under the hood,
  Expositor efficiently implements traces as lazy, sparse
  interval trees whose contents are materialized on demand.
  Expositor also provides a novel data
  structure, the <em>edit hash array mapped trie</em>, which is a lazy
  implementation of sets, maps, multisets, and multimaps that enables
  programmers to maximize the efficiency of their debugging scripts.  We have used
  Expositor to debug a stack overflow and to unravel a subtle
  data race in Firefox. We believe that
  Expositor represents an important step forward in improving the
  technology for diagnosing complex, hard-to-understand bugs.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/icse13main-p326-p-15890-preprint.pdf">.pdf</a> ]
<a name="khoo13expositor"></a><pre>
@INPROCEEDINGS{khoo13expositor,
  AUTHOR = {Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Expositor: Scriptable Time-Travel Debugging with First Class Traces},
  BOOKTITLE = {Proceedings of the International Conference on Software Engineering (ICSE)},
  MONTH = MAY,
  YEAR = 2013
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Expositor: Scriptable Time-Travel Debugging with First-Class Traces</b>.
  Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  Technical Report CS-TR-5021, Department of Computer Science,
  University of Maryland, College Park, February 2013.</font><p><p><a name="khoo:cs-tr-5021"></a><pre>
@TECHREPORT{khoo:cs-tr-5021,
  AUTHOR = {Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks},
  TITLE = {{Expositor: Scriptable Time-Travel Debugging with First-Class Traces}},
  INSTITUTION = {Department of Computer Science, University of Maryland, College Park},
  YEAR = {2013},
  NUMBER = {CS-TR-5021},
  MONTH = {February}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Implicit Flows: Can't live with 'em, can't live without 'em</b>.
  Dave King, Boniface Hicks, Michael Hicks, and Trent Jaeger.
  In R.&nbsp;Sekar and Arun&nbsp;K. Pujari, editors, <i>Proceedings of the
  International Conference on Information Systems Security (ICISS)</i>, volume
  5352 of <i>Lecture Notes in Computer Science</i>, pages 56-70. Springer,
  December 2008.</font><p>
Verifying that programs trusted to enforce security actually do so is
a practical concern for programmers and administrators.  However, there is a
disconnect between the kinds of tools that have been successfully applied to real
software systems (such as taint mode in Perl and Ruby), and information-flow
compilers that enforce a variant of the stronger security property of
noninterference.  Tools that have been successfully used to find security
violations have focused on <i>explicit flows</i> of information, where
high-security information is directly leaked to output.  Analysis tools that
enforce noninterference also prevent <i>implicit flows</i> of
information, where high-security information can be inferred from a program's
flow of control.  However, these tools have seen little use in
practice, despite the stronger guarantees that they provide.  <P>
To better understand why, this paper experimentally investigates
the explicit and implicit flows identified by the standard
algorithm for establishing noninterference.  When applied to
implementations of authentication and cryptographic functions, the
standard algorithm discovers many real implicit flows of
information, but also reports an extremely high number of false alarms,
most of which are due to conservative handling of unchecked
exceptions (e.g., null pointer exceptions).  After a careful
analysis of all sources of 
true and false alarms, due to both implicit and explicit flows, the
paper concludes with some ideas to improve the false alarm rate,
toward making stronger security analysis more practical.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/implicitflows.pdf">.pdf</a> ]
<a name="king08implicit"></a><pre>
@INPROCEEDINGS{king08implicit,
  TITLE = {Implicit Flows: Can't live with 'em, can't live without 'em},
  AUTHOR = {Dave King and Boniface Hicks and Michael Hicks and Trent Jaeger},
  BOOKTITLE = {Proceedings of the International Conference on Information Systems Security (ICISS)},
  MONTH = DEC,
  YEAR = 2008,
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = {5352},
  EDITOR = {R. Sekar and Arun K. Pujari},
  PUBLISHER = {Springer},
  PAGES = {56--70}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Memory Trace Oblivious Program Execution</b>.
  Chang Liu, Michael Hicks, and Elaine Shi.
  In <i>Proceedings of the Computer Security Foundations Symposium
  (CSF)</i>, June 2013.
  Winner of the 2014 NSA <b>Best Scientific Cybersecurity Paper</b>
  competition.</font><p>
  Cloud computing allows users to delegate data and computation to
  cloud service providers, at the cost of giving up physical control
  of their computing infrastructure.  An attacker (e.g., insider) with
  physical access to the computing platform can perform various
  physical attacks, including probing memory buses and cold-boot style
  attacks.  Previous work on secure (co-)processors provides hardware
  support for memory encryption and prevents direct leakage of
  sensitive data over the memory bus.  However, an adversary snooping
  on the bus can still infer sensitive information from the memory
  access traces.  Existing work on Oblivious RAM (ORAM) provides a
  solution for users to put all data in an ORAM; and accesses to an
  ORAM are obfuscated such that no information leaks through memory
  access traces.  This method, however, incurs significant memory
  access overhead.<P>
  In this work, we are among the first to leverage programming
  language techniques to offer efficient memory-trace oblivious
  program execution, while providing formal security guarantees.  We
  formally define the notion of memory-trace obliviousness, and
  provide a type system for verifying that a program satisfies this
  property.  We also describe a compiler that transforms a program
  into a structurally similar one that satisfies memory trace
  obliviousness.  To achieve optimal efficiency, our compiler
  partitions variables into several small ORAM banks rather than one
  large one, without risking security.  We use several example
  programs to demonstrate the efficiency gains our compiler achieves
  in comparison with the naive method of placing all variables in the
  same ORAM.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/csf2013oram.pdf">.pdf</a> ]
<a name="liu13oblivious"></a><pre>
@INPROCEEDINGS{liu13oblivious,
  TITLE = {Memory Trace Oblivious Program Execution},
  AUTHOR = {Chang Liu and Michael Hicks and Elaine Shi},
  BOOKTITLE = {Proceedings of the Computer Security Foundations Symposium (CSF)},
  MONTH = JUN,
  YEAR = 2013,
  NOTE = {Winner of the 2014 NSA \textbf{Best Scientific Cybersecurity Paper} competition}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Automating Efficient RAM-Model Secure Computation</b>.
  Chang Liu, Yan Huang, Elaine Shi, Jonathan Katz, and Michael Hicks.
  In <i>Proceedings of the IEEE Symposium on Security and Privacy
  (Oakland)</i>, May 2014.</font><p>
RAM-model secure computation addresses the inherent limitations
of circuit-model secure computation considered in almost all previous work.
Here, we describe the first <em>automated</em> approach for
RAM-model secure computation in the semi-honest model.
We define an intermediate representation
called SCVM and a corresponding type system suited for RAM-model secure computation.
Leveraging compile-time optimizations, our approach achieves
order-of-magnitude speedups compared to both circuit-model secure
computation and the state-of-art RAM-model secure computation.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/ram-sc.pdf">.pdf</a> ]
<a name="liu14scram"></a><pre>
@INPROCEEDINGS{liu14scram,
  AUTHOR = {Chang Liu and Yan Huang and Elaine Shi and Jonathan Katz and Michael Hicks},
  TITLE = {Automating Efficient {RAM}-Model Secure Computation},
  BOOKTITLE = {Proceedings of the {IEEE} Symposium on Security and Privacy (Oakland)},
  MONTH = MAY,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>GhostRider: A Hardware-Software System for Memory Trace Oblivious
  Computation</b>.
  Chang Liu, Austin Harris, Martin Maas, Michael Hicks, Mohit Tiwari,
  and Elaine Shi.
  In <i>Proceedings of the International Conference on Architectural
  Support for Programming Languages and Operating Systems (ASPLOS)</i>, March
  2015.
  <b>Winner of Best Paper Award</b>.</font><p>
This paper presents a new, co-designed compiler and architecture
called GhostRider for supporting privacy preserving computation in the
cloud. GhostRider ensures all programs satisfy a property called
memory-trace obliviousness (MTO): Even an adversary that observes
memory, bus traffic, and access times while the program executes can
learn nothing about the program's sensitive inputs and outputs. One
way to achieve MTO is employ Oblivious RAM (ORAM), allocating all code
and data in a single ORAM bank, and to also disable caches or fix the
rate of memory traffic. This baseline approach can be inefficient, and
so GhostRider's compiler uses a program analysis to do better,
allocating data to non-oblivious, encrypted RAM (ERAM) and employing a
scratchpad when doing so will not compromise MTO. The compiler can
also allocate to multiple ORAM banks, which sometimes significantly
reduces access times. We have formalized our approach and proved it
enjoys MTO. Our FPGA-based hardware prototype and simulation results
show that GhostRider significantly outperforms the baseline strategy.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/ghostrider15.pdf">.pdf</a> ]
<a name="liu15ghostrider"></a><pre>
@INPROCEEDINGS{liu15ghostrider,
  AUTHOR = {Chang Liu and Austin Harris and Martin Maas and Michael Hicks and Mohit Tiwari and Elaine Shi},
  TITLE = {GhostRider: A Hardware-Software System for Memory Trace Oblivious Computation},
  BOOKTITLE = {Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)},
  MONTH = MAR,
  YEAR = 2015,
  NOTE = {\textbf{Winner of Best Paper Award}}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Directed Symbolic Execution</b>.
  Kin-Keung Ma, Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  In Eran Yahav, editor, <i>Proceedings of the Static Analysis
  Symposium (SAS)</i>, volume 6887 of <i>Lecture Notes in Computer Science</i>,
  pages 95-111. Springer, September 2011.</font><p>
In this paper, we study the problem of automatically finding program
executions that reach a particular target line. This problem arises
in many debugging scenarios; for example, a developer may want to confirm
that a bug reported by a static analysis tool on a particular line is
a true positive. 
We propose two new <em>directed</em> 
symbolic execution strategies that aim to solve this problem:
<em>shortest-distance symbolic execution (SDSE)</em> uses a distance metric in
an interprocedural control flow graph to guide symbolic execution toward a
particular target; and <em>call-chain-backward symbolic execution (CCBSE)</em>
iteratively runs forward symbolic execution, starting in the function
containing the target line, and then jumping backward up the call chain
until it finds a feasible path from the start of the program. 
We also propose a hybrid strategy, Mix-CCBSE, which alternates CCBSE with
another (forward) search strategy.  We compare these three with several
existing strategies from the literature on a suite of six GNU
coreutils programs. 
We find that SDSE performs extremely well in many cases
but may fail badly. CCBSE also performs quite well, but imposes
additional overhead that sometimes makes it slower than SDSE.  Considering
all our benchmarks together, Mix-CCBSE performed best on average,
combining to good effect the features of its constituent components.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dse-sas11.pdf">.pdf</a> ]
<a name="ma11directed"></a><pre>
@INPROCEEDINGS{ma11directed,
  TITLE = {Directed Symbolic Execution},
  AUTHOR = {Kin-Keung Ma and Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks},
  BOOKTITLE = {Proceedings of the Static Analysis Symposium (SAS)},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = {6887},
  EDITOR = {Eran Yahav},
  PUBLISHER = {Springer},
  PAGES = {95--111},
  YEAR = 2011,
  MONTH = SEP
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Directed Symbolic Execution</b>.
  Kin-Keung Ma, Yit&nbsp;Phang Khoo, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  Technical Report CS-TR-4979, University of Maryland Department of
  Computer Science, April 2011.
  Extended version contains refinements and further experimental
  analysis.</font><p>
In this paper, we study the problem of automatically finding program
executions that reach a particular target line. This problem arises
in many debugging scenarios; for example, a developer may want to confirm
that a bug reported by a static analysis tool on a particular line is
a true positive. 
We propose two new <em>directed</em> 
symbolic execution strategies that aim to solve this problem:
<em>shortest-distance symbolic execution (SDSE)</em> uses a distance metric in
an interprocedural control flow graph to guide symbolic execution toward a
particular target; and <em>call-chain-backward symbolic execution (CCBSE)</em>
iteratively runs forward symbolic execution, starting in the function
containing the target line, and then jumping backward up the call chain
until it finds a feasible path from the start of the program. 
We also propose a hybrid strategy, Mix-CCBSE, which alternates CCBSE with
another (forward) search strategy.  We compare these three with several
existing strategies from the literature on a suite of six GNU
coreutils programs. 
We find that SDSE performs extremely well in many cases
but may fail badly. CCBSE also performs quite well, but imposes
additional overhead that sometimes makes it slower than SDSE.  Considering
all our benchmarks together, Mix-CCBSE performed best on average,
combining to good effect the features of its constituent components.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/directedSE-TR.pdf">.pdf</a> ]
<a name="ma11directedTR"></a><pre>
@TECHREPORT{ma11directedTR,
  TITLE = {Directed Symbolic Execution},
  AUTHOR = {Kin-Keung Ma and Yit Phang Khoo and Jeffrey S. Foster and Michael Hicks},
  MONTH = APR,
  YEAR = 2011,
  NUMBER = {CS-TR-4979},
  INSTITUTION = {University of Maryland Department of Computer Science},
  NOTE = {Extended version contains refinements and further experimental analysis}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Specifying and Verifying the Correctness of Dynamic Software Updates</b>.
  Stephen Magill, Christopher&nbsp;M. Hayden, Michael Hicks, Nate Foster,
  and Jeffrey&nbsp;S. Foster, November 2010.</font><p>
  Recently, there has been much interest in dynamic software updating
  (DSU) systems, which allow running programs to be patched on-the-fly
  to add features or fix bugs.  Open-source and commercial products
  are now available to support dynamic updates to OS kernels, desktop
  applications, server programs, and embedded devices.  However,
  despite the many recent advances in DSU mechanisms, techniques to
  reason that dynamic updates are correct have lagged behind, focusing
  largely on simple properties like type safety.<P>
  In this paper, we present a more complete framework for specifying
  and verifying the correctness of dynamic updates.  Our framework is
  capable of describing application-specific, behavioral notions of
  correctness.  We use our framework to characterize several
  classes of program properties that arise in updatable
  software.<P>
  To verify such properties in actual updatable programs, we develop a
  transformation that combines the old and new versions of a program
  into a single <em>merged program</em>.  This merged program is
  provably equivalent to running the old and new programs in a DSU
  system, and, most importantly, the merged program can be analyzed by
  off-the-shelf program analysis tools.  We describe an implementation
  of a program merger we have developed for C, and we demonstrate its
  utility with several case studies.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsucorrect.pdf">.pdf</a> ]
<a name="magill10dsucorrect"></a><pre>
@MISC{magill10dsucorrect,
  TITLE = {Specifying and Verifying the Correctness of Dynamic Software Updates},
  AUTHOR = {Stephen Magill and Christopher M. Hayden and Michael Hicks and Nate Foster and Jeffrey S. Foster},
  SUBMITTED = {yes},
  YEAR = 2010,
  MONTH = NOV
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Specifying and Verifying the Correctness of Dynamic Software Updates</b>.
  Stephen Magill, Christopher&nbsp;M. Hayden, Michael Hicks, Nate Foster,
  and Jeffrey&nbsp;S. Foster, July 2010.</font><p>
  Recently, there has been much interest in dynamic software updating
  (DSU) systems, which allow running programs to be patched on-the-fly
  to add features or fix bugs.  Open-source and commercial products
  are now available to support dynamic updates to OS kernels, desktop
  applications, server programs, and embedded devices.  However,
  despite the many 
  recent advances in DSU mechanisms, techniques to reason that
  dynamic updates are correct have lagged behind, focusing largely
  on simple properties like type safety.<P>
  In this paper, we present a
  more complete framework for specifying and verifying the correctness
  of dynamic updates.
  Our framework is capable of describing
  application-specific, behavioral notions of correctness.
  We also use our framework to formally characterize several general classes of
  program properties that arise in updatable software.<P>
  To verify such properties in actual updatable programs, we develop a
  transformation that combines the old and new version of a program
  into a single <em>merged program</em>.  This merged program is provably equivalent to
  running the old and new programs in a DSU system, and,
  most importantly, the merged
  program can be analyzed by off-the-shelf
  program analysis tools.  We describe an implementation of a
  program merger we have developed for C, and we demonstrate its
  utility with several case studies.
  <p><a name="magill10dsucorrectness"></a><pre>
@MISC{magill10dsucorrectness,
  AUTHOR = {Stephen Magill and Christopher M. Hayden and Michael Hicks and Nate Foster and Jeffrey S. Foster},
  TITLE = {Specifying and Verifying the Correctness of Dynamic Software Updates},
  MONTH = JUL,
  SUBMITTED = {yes},
  YEAR = 2010
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Specifying and Verifying the Correctness of Dynamic Software Updates</b>.
  Stephen Magill, Christopher&nbsp;M. Hayden, Michael Hicks, Nate Foster,
  and Jeffrey&nbsp;S. Foster, March 2011.</font><p>
  Recently, there has been much interest in dynamic software updating
  (DSU) systems, which allow running programs to be patched on-the-fly
  to add features or fix bugs.  While dynamic updates can be tricky
  to write, techniques for establishing their
  correctness have received little attention.
  In this paper, we present the first methodology for automatically
  verifying the correctness of dynamic updates.  Programmers express
  the desired properties of an updated execution using
  <em>client-oriented specifications</em> (CO-specs), which can describe a
  wide range of behaviors visible from clients' points of view.
  Then we verify CO-specs automatically by combining the old and new
  versions of a program, along with the CO-spec, into a single
  <em>merged program</em> which we can analyze with off-the-shelf tools.
  We formalize the merging transformation and prove it correct.  With
  our implementation of a C-program merger, we merged actual updates
  to the Redis key-value server, as well as updates to some synthetic
  programs.  We found that Thor, a verification tool, was capable of
  checking many of the synthetic examples, while Otter, a symbolic
  executor, could check every example, often in less than a minute.
  Both tools were able to detect faulty patches and incurred only a
  4&#215; slowdown, on average, compared with checking individual
  versions.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsucorrectness.pdf">.pdf</a> ]
<a name="magill11dsucorrect"></a><pre>
@MISC{magill11dsucorrect,
  TITLE = {Specifying and Verifying the Correctness of Dynamic Software Updates},
  AUTHOR = {Stephen Magill and Christopher M. Hayden and Michael Hicks and Nate Foster and Jeffrey S. Foster},
  SUBMITTED = {yes},
  YEAR = 2011,
  MONTH = MAR
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Automating Object Transformations for Dynamic Software Updating</b>.
  Stephen Magill, Suriya Subramanian, Michael Hicks, and Kathryn&nbsp;S.
  McKinley, November 2011.</font><p>
  Dynamic software updating (DSU) systems eliminate costly downtime by
  dynamically fixing bugs and adding features to executing programs.
  Given a static *code* patch, most DSU systems can construct the
  run-time code changes automatically.  However, a dynamic update must
  also specify how to change the running program's execution *state*,
  e.g., its stack and heap, to be compatible with the new code.
  Constructing such *state transformations* correctly and
  automatically remains an open problem.  This paper presents a
  solution called Targeted Object Synthesis (TOS).  TOS first executes
  the same tests on the old and new program versions separately,
  observing the program state at key points.  Given two corresponding
  states, TOS *matches* corresponding objects between the two
  versions, and *synthesizes* the simplest-possible function to
  transform old version objects to their corresponding new versions.
  We show the efficacy of TOS by inferring transformation functions
  for actual updates to four open-source server programs.
  <p><a name="magill11tos"></a><pre>
@MISC{magill11tos,
  TITLE = {Automating Object Transformations for Dynamic Software Updating},
  AUTHOR = {Stephen Magill and Suriya Subramanian and Michael Hicks and Kathryn S. McKinley},
  MONTH = NOV,
  YEAR = 2011,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Automating Object Transformations for Dynamic Software Updating</b>.
  Stephen Magill, Michael Hicks, Suriya Subramanian, and Kathryn&nbsp;S.
  McKinley.
  In <i>Proceedings of the ACM Conference on Object-Oriented
  Programming Languages, Systems, and Applications (OOPSLA)</i>, October 2012.</font><p>
  Dynamic software updating (DSU) systems eliminate costly downtime by
  dynamically fixing bugs and adding features to executing programs.
  Given a static <em>code</em> patch, most DSU systems construct runtime
  code changes automatically.  However, a dynamic update must also
  specify how to change the running program's execution <em>state</em>,
  e.g., the stack and heap, to make it compatible with the new code.
  Constructing such <em>state transformations</em> correctly and
  automatically remains an open problem.  This paper presents a
  solution called <em>Targeted Object Synthesis</em> (TOS).  TOS first executes the same tests on
  the old and new program versions separately, observing the program
  heap state at a few corresponding points.  Given two corresponding
  heap states, TOS
  <em>matches</em> objects in the two versions using <em>key</em> fields
  that uniquely identify objects and correlate old and new-version
  objects. Given example object pairs, TOS then <em>synthesizes</em> the simplest-possible 
  function that transforms an old-version object to its new-version
  counterpart. We show
  that TOS  is effective on updates to four open-source server
  programs for which it generates non-trivial transformation functions that use conditionals,
  operate on collections, and fix memory leaks. These transformations help programmers
  understand their changes and apply dynamic software updates.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/tos.pdf">.pdf</a> ]
<a name="magill12tos"></a><pre>
@INPROCEEDINGS{magill12tos,
  TITLE = {Automating Object Transformations for Dynamic Software Updating},
  AUTHOR = {Stephen Magill and Michael Hicks and Suriya Subramanian and Kathryn S. McKinley},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Object-Oriented Programming Languages, Systems, and Applications (OOPSLA)},
  MONTH = OCT,
  YEAR = 2012
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Secure sharing in distributed information management applications:
  problems and directions</b>.
  Piotr Mardziel, Adam Bender, Michael Hicks, Dave Levin, Mudhakar
  Srivatsa, and Jonathan Katz.
  In <i>Proceedings of the Annual Conference of the International
  Technology Alliance (ACITA)</i>, September 2010.</font><p>
Interaction between entities who may not trust each other is now
commonplace on the Internet.
This paper focuses on the specific problem of sharing information
between distrusting parties.
Previous work in this area shows that <i>privacy</i> and <i>utility</i>
can co-exist, but often do not provide strong assurances of one or the other.
In this paper, we sketch a research agenda with several directions for
attacking these problems, considering several alternative systems that
examine the privacy vs. utility problem from different angles.
We consider new mechanisms such as economic incentives to share data
or discourage 
data leakage and a hybrid of code-splitting and secure multi-party
computation to provide various assurances of secrecy.
We discuss how to incorporate these mechanisms into practical applications,
including online social networks, a recommendation system based on users'
qualifications rather than identities, and a <em>personal information
broker</em> that monitors data leakage over time.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/secure-sharing.pdf">.pdf</a> ]
<a name="mardziel10acita"></a><pre>
@INPROCEEDINGS{mardziel10acita,
  TITLE = {Secure sharing in distributed information management applications: problems and directions},
  AUTHOR = {Piotr Mardziel and Adam Bender and Michael Hicks and Dave Levin and Mudhakar Srivatsa and Jonathan Katz},
  BOOKTITLE = {Proceedings of the Annual Conference of the International Technology Alliance (ACITA)},
  MONTH = SEP,
  YEAR = 2010
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Enforcement of Knowledge-based Security Policies</b>.
  Piotr Mardziel, Stephen Magill, Michael Hicks, and Mudhakar Srivatsa.
  In <i>Proceedings of the Computer Security Foundations Symposium
  (CSF)</i>, pages 114-128, June 2011.</font><p>
  This paper explores the idea of <em>knowledge-based security
    policies</em>, which are used to decide whether to answer queries over
  secret data based on an estimation of the querier's (possibly
  increased) knowledge given the results.  Limiting knowledge is the
  goal of existing information release policies that employ mechanisms
  such as noising, anonymization, and redaction.  Knowledge-based
  policies are more general: they increase flexibility by not fixing
  the means to restrict information flow.  We enforce a
  knowledge-based policy by explicitly tracking a model of a querier's
  belief about secret data, represented as a probability distribution,
  and denying any query that could increase knowledge above a given
  threshold.  We implement query analysis and belief tracking via
  abstract interpretation using a novel 
  <em>probabilistic polyhedral</em> domain, whose design permits trading off
  precision with performance while ensuring estimates of a querier's
  knowledge are sound.  Experiments with our implementation show that
  several useful queries can be handled efficiently, and performance
  scales far better than would more standard implementations of
  probabilistic computation based on sampling.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/beliefpol.pdf">.pdf</a> ]
<a name="mardziel11belief"></a><pre>
@INPROCEEDINGS{mardziel11belief,
  TITLE = {Dynamic Enforcement of Knowledge-based Security Policies},
  AUTHOR = {Piotr Mardziel and Stephen Magill and Michael Hicks and Mudhakar Srivatsa},
  BOOKTITLE = {Proceedings of the Computer Security Foundations Symposium (CSF)},
  YEAR = 2011,
  MONTH = JUN,
  PAGES = {114--128}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Enforcement of Knowledge-based Security Policies</b>.
  Piotr Mardziel, Stephen Magill, Michael Hicks, and Mudhakar Srivatsa.
  Technical Report CS-TR-4978, University of Maryland Department of
  Computer Science, July 2011.
  Extended version with proofs and additional benchmarks.</font><p>
  This paper explores the idea of <em>knowledge-based security
    policies</em>, which are used to decide whether to answer queries over
  secret data based on an estimation of the querier's (possibly
  increased) knowledge given the results.  Limiting knowledge is the
  goal of existing information release policies that employ mechanisms
  such as noising, anonymization, and redaction.  Knowledge-based
  policies are more general: they increase flexibility by not fixing
  the means to restrict information flow.  We enforce a
  knowledge-based policy by explicitly tracking a model of a querier's
  belief about secret data, represented as a probability distribution,
  and denying any query that could increase knowledge above a given
  threshold.  We implement query analysis and belief tracking via
  abstract interpretation using a novel 
  <em>probabilistic polyhedral</em> domain, whose design permits trading off
  precision with performance while ensuring estimates of a querier's
  knowledge are sound.  Experiments with our implementation show that
  several useful queries can be handled efficiently, and performance
  scales far better than would more standard implementations of
  probabilistic computation based on sampling.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/beliefpolTR.pdf">.pdf</a> ]
<a name="mardziel11beliefTR"></a><pre>
@TECHREPORT{mardziel11beliefTR,
  TITLE = {Dynamic Enforcement of Knowledge-based Security Policies},
  AUTHOR = {Piotr Mardziel and Stephen Magill and Michael Hicks and Mudhakar Srivatsa},
  NUMBER = {CS-TR-4978},
  INSTITUTION = {University of Maryland Department of Computer Science},
  YEAR = 2011,
  MONTH = JUL,
  NOTE = {Extended version with proofs and additional benchmarks}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Enforcement of Knowledge-based Security Policies using Abstract
  Interpretation</b>.
  Piotr Mardziel, Stephen Magill, Michael Hicks, and Mudhakar Srivatsa,
  October 2012.
  Extended version of CSF'11 paper.</font><p>
  This paper explores the idea of <em>knowledge-based security
    policies</em>, which are used to decide whether to answer queries over
    secret data based on an estimation of the querier's (possibly
    increased) knowledge given the results.  Limiting knowledge is the
    goal of existing information release policies that employ
    mechanisms such as noising, anonymization, and redaction.
    Knowledge-based policies are more general: they increase
    flexibility by not fixing the means to restrict information flow.
    We enforce a knowledge-based policy by explicitly tracking a model
    of a querier's belief about secret data, represented as a
    probability distribution, and denying any query that could
    increase knowledge above a given threshold.  We implement query
    analysis and belief tracking via abstract interpretation, which allows us to
    trade off precision and performance through the use of
    abstraction. We have developed an approach to augment standard
    abstract domains to include probabilities, and thus define
    distributions.  We focus on developing <em>probabilistic
      polyhedra</em> in particular, to support numeric programs. While
    probabilistic abstract interpretation has been 
    considered before, our domain is the first whose design supports
    sound conditioning, which is required to ensure that estimates of
    a querier's knowledge are accurate. Experiments with our
    implementation show that several useful queries can be handled
    efficiently, particularly compared to exact (i.e., sound)
    inference involving sampling.  We also show that, for our
    benchmarks, restricting constraints to <em>octagons</em>
    or <em>intervals</em>, rather than full polyhedra, can dramatically
    improve performance while incurring little to no loss in
    precision.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/beliefpol-extended.pdf">.pdf</a> ]
<a name="mardziel12belieflong"></a><pre>
@MISC{mardziel12belieflong,
  TITLE = {Dynamic Enforcement of Knowledge-based Security Policies using Abstract Interpretation},
  AUTHOR = {Piotr Mardziel and Stephen Magill and Michael Hicks and Mudhakar Srivatsa},
  YEAR = 2012,
  MONTH = OCT,
  NOTE = {Extended version of CSF'11 paper},
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Knowledge-Oriented Secure Multiparty Computation</b>.
  Piotr Mardziel, Michael Hicks, Jonathan Katz, and Mudhakar Srivatsa.
  In <i>Proceedings of the ACM SIGPLAN Workshop on Programming
  Languages and Analysis for Security (PLAS)</i>, June 2012.</font><p>
Protocols for <em>secure multiparty computation</em> (SMC) allow a set
of mutually distrusting parties to compute a function&nbsp;<EM>f</EM> of their
private inputs while revealing nothing about their inputs beyond what
is implied by the result.  Depending on&nbsp;<EM>f</EM>, however, the result
itself may reveal more information than parties are comfortable with.
Almost all previous work on SMC treats <EM>f</EM> as given.  Left unanswered
is the question of how parties should decide whether it is ``safe''
for them to compute <EM>f</EM> in the first place.<P>
We propose here a way to apply <em>belief tracking</em> to&nbsp;SMC in order
to address exactly this question. In our approach, each participating
party is able to reason about the increase in knowledge that other
parties could gain as a result of computing <EM>f</EM>, and may choose not to
participate (or participate only partially) so as to restrict that
gain in knowledge.  We develop two techniques-the <em>belief set</em>
method and the <em>SMC belief tracking</em> method-prove them sound,
and discuss their precision/performance tradeoffs using a series of
experiments.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/belief-smc.pdf">.pdf</a> ]
<a name="mardziel12smc"></a><pre>
@INPROCEEDINGS{mardziel12smc,
  TITLE = {Knowledge-Oriented Secure Multiparty Computation},
  AUTHOR = {Piotr Mardziel and Michael Hicks and Jonathan Katz and Mudhakar Srivatsa},
  BOOKTITLE = {Proceedings of the {ACM SIGPLAN} Workshop on Programming Languages and Analysis for Security (PLAS)},
  MONTH = JUN,
  YEAR = 2012
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Knowledge inference for optimizing and enforcing secure computations</b>.
  Piotr Mardziel, Michael Hicks, Jonathan Katz, Matthew Hammer, Aseem
  Rastogi, and Mudhakar Srivatsa.
  In <i>Proceedings of the Annual Meeting of the US/UK International
  Technology Alliance</i>, September 2013.
  This short paper consists of coherent excerpts from several prior
  papers.</font><p>
We present several techniques that aim to compute
the belief or knowledge a party might have about the values of hidden variables involved in the computation. These techniques can be used for enforcing knowledge-based security policies and for optimizing secure multiparty computations.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/knowledge-overview.pdf">.pdf</a> ]
<a name="mardziel13belief"></a><pre>
@INPROCEEDINGS{mardziel13belief,
  AUTHOR = {Piotr Mardziel and Michael Hicks and Jonathan Katz and Matthew Hammer and Aseem Rastogi and Mudhakar Srivatsa},
  TITLE = {Knowledge inference for optimizing and enforcing secure computations},
  BOOKTITLE = {Proceedings of the Annual Meeting of the US/UK International Technology Alliance},
  NOTE = {This short paper consists of coherent excerpts from several prior papers},
  YEAR = 2013,
  MONTH = SEP
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Enforcement of Knowledge-based Security Policies using
  Probabilistic Abstract Interpretation</b>.
  Piotr Mardziel, Stephen Magill, Michael Hicks, and Mudhakar Srivatsa.
  <i>Journal of Computer Security</i>, 21:463-532, October 2013.</font><p>
  This paper explores the idea of <em>knowledge-based security
    policies</em>, which are used to decide whether to answer queries over
    secret data based on an estimation of the querier's (possibly
    increased) knowledge given the results.  Limiting knowledge is the
    goal of existing information release policies that employ
    mechanisms such as noising, anonymization, and redaction.
    Knowledge-based policies are more general: they increase
    flexibility by not fixing the means to restrict information flow.
    We enforce a knowledge-based policy by explicitly tracking a model
    of a querier's belief about secret data, represented as a
    probability distribution, and denying any query that could
    increase knowledge above a given threshold.  We implement query
    analysis and belief tracking via abstract interpretation, which allows us to
    trade off precision and performance through the use of
    abstraction. We have developed an approach to augment standard
    abstract domains to include probabilities, and thus define
    distributions.  We focus on developing <em>probabilistic
      polyhedra</em> in particular, to support numeric programs. While
    probabilistic abstract interpretation has been 
    considered before, our domain is the first whose design supports
    sound conditioning, which is required to ensure that estimates of
    a querier's knowledge are accurate. Experiments with our
    implementation show that several useful queries can be handled
    efficiently, particularly compared to exact (i.e., sound)
    inference involving sampling.  We also show that, for our
    benchmarks, restricting constraints to <em>octagons</em>
    or <em>intervals</em>, rather than full polyhedra, can dramatically
    improve performance while incurring little to no loss in
    precision.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/beliefpol-extended.pdf">.pdf</a> ]
<a name="mardziel13belieflong"></a><pre>
@ARTICLE{mardziel13belieflong,
  TITLE = {Dynamic Enforcement of Knowledge-based Security Policies using Probabilistic Abstract Interpretation},
  AUTHOR = {Piotr Mardziel and Stephen Magill and Michael Hicks and Mudhakar Srivatsa},
  YEAR = 2013,
  MONTH = OCT,
  VOLUME = 21,
  PAGES = {463--532},
  JOURNAL = {Journal of Computer Security}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Adversary Gain vs. Defender Loss in Quantified Information Flow</b>.
  Piotr Mardziel, Mrio&nbsp;S. Alvim, and Michael Hicks.
  In <i>(Unofficial) Proceedings of the International Workshop on
  Foundations of Computer Security (FCS)</i>, July 2014.</font><p>
Metrics for quantifying information leakage assume
  that an adversary's gain is the defender's loss.
  We demonstrate that this assumption does not always hold via a class
  of scenarios.
  We describe how to extend quantification to account for a defender
  with goals distinct from adversary failure.
  We implement the extension and experimentally explore the impact on
  the measured information leakage of the motivating scenario.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/qifgl.pdf">.pdf</a> ]
<a name="mardziel14qifgl"></a><pre>
@INPROCEEDINGS{mardziel14qifgl,
  AUTHOR = {Piotr Mardziel and M\'ario S. Alvim and Michael Hicks},
  TITLE = {Adversary Gain vs. Defender Loss in Quantified Information Flow},
  BOOKTITLE = {(Unofficial) Proceedings of the International Workshop on Foundations of Computer Security (FCS)},
  MONTH = JUL,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Quantifying Information Flow for Dynamic Secrets</b>.
  Piotr Mardziel, Mario Alvim, Michael Hicks, and Michael Clarkson.
  In <i>Proceedings of the IEEE Symposium on Security and Privacy
  (Oakland)</i>, May 2014.</font><p>
  A metric is proposed for quantifying leakage of information about
  secrets and about how secrets change over time.
  The metric is used with a model of information flow for
  probabilistic, interactive systems with adaptive adversaries.
  The model and metric are implemented in a probabilistic programming
  language and used to analyze several examples. 
  The analysis demonstrates that adaptivity increases the amount of
  information that adversaries learn.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/qif-dynamic-secrets.pdf">.pdf</a> ]
<a name="mardziel14time"></a><pre>
@INPROCEEDINGS{mardziel14time,
  AUTHOR = {Piotr Mardziel and Mario Alvim and Michael Hicks and Michael Clarkson},
  TITLE = {Quantifying Information Flow for Dynamic Secrets},
  BOOKTITLE = {Proceedings of the {IEEE} Symposium on Security and Privacy (Oakland)},
  MONTH = MAY,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Quantifying Information Flow for Dynamic Secrets (extended version)</b>.
  Piotr Mardziel, Mario Alvim, Michael Hicks, and Michael Clarkson.
  Technical Report CS-TR-5035, Department of Computer Science, the
  University of Maryland, College Park, May 2014.</font><p>
  A metric is proposed for quantifying leakage of information about
  secrets and about how secrets change over time.
  The metric is used with a model of information flow for
  probabilistic, interactive systems with adaptive adversaries.
  The model and metric are implemented in a probabilistic programming
  language and used to analyze several examples. 
  The analysis demonstrates that adaptivity increases the amount of
  information that adversaries learn.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/qif-dynamic-secrets-tr.pdf">.pdf</a> ]
<a name="mardziel14timeTR"></a><pre>
@TECHREPORT{mardziel14timeTR,
  AUTHOR = {Piotr Mardziel and Mario Alvim and Michael Hicks and Michael Clarkson},
  TITLE = {Quantifying Information Flow for Dynamic Secrets (extended version)},
  INSTITUTION = {Department of Computer Science, the University of Maryland, College Park},
  NUMBER = {CS-TR-5035},
  MONTH = MAY,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamically Checking Ownership Policies in Concurrent C/C++ Programs
  (full version)</b>.
  Jean-Phillipe Martin, Michael Hicks, Manuel Costa, Periklis
  Akritidis, and Miguel Castro, July 2009.</font><p>
Concurrent programming errors arise when threads share data
incorrectly. Programmers often avoid these errors by using
synchronization to enforce a simple ownership policy: data is either
<em>owned exclusively</em> by a thread that can read or write the data,
or it is <em>read owned</em> by a set of threads that can read but
not write the data.  Unfortunately, incorrect synchronization often
fails to enforce these policies and memory errors in languages like C
and C++ can violate these policies even when synchronization is
correct.<P>
In this paper, we present a dynamic analysis for checking ownership
policies in concurrent C and C++ programs despite memory errors. The
analysis can be used to find errors in commodity multi-threaded
programs and to prevent attacks that exploit these errors.  We require
programmers to write ownership assertions that describe the sharing
policies used by different parts of the program.  These policies may
change over time, as may the policies' means of enforcement, whether
it be locks, barriers, thread joins, etc. Our compiler inserts checks
in the program that signal an error if these policies are violated at
runtime.  We evaluated our tool on several benchmark programs.  The
run-time overhead was reasonable: between 0 and 49% with an average
of 26%.  We also found the tool easy to use: the total number of
ownership assertions is small, and the asserted specification and
implementation can be debugged together by running the instrumented
program and addressing the errors that arise.  Our approach enjoys a
pleasing modular soundness property: if a thread executes a sequence
of statements on variables it owns, the statements are serializable
within a valid execution, and thus their effects can be reasoned about
in isolation from other threads in the program.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/conccheck-full.pdf">.pdf</a> ]
<a name="martin09ownership"></a><pre>
@MISC{martin09ownership,
  AUTHOR = {Jean-Phillipe Martin and Michael Hicks and Manuel Costa and Periklis Akritidis and Miguel Castro},
  TITLE = {Dynamically Checking Ownership Policies in Concurrent {C/C++}
  Programs (full version)},
  MONTH = JUL,
  YEAR = 2009,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamically Checking Ownership Policies in Concurrent C/C++ Programs</b>.
  Jean-Philippe Martin, Michael Hicks, Manuel Costa, Periklis
  Akritidis, and Miguel Castro.
  In <i>Proceedings of the ACM Conference on Principles of
  Programming Languages (POPL)</i>, pages 457-470, January 2010.
  Full version.</font><p>
Concurrent programming errors arise when threads share data
incorrectly. Programmers often avoid these errors by using
synchronization to enforce a simple ownership policy: data is either
<em>owned exclusively</em> by a thread that can read or write the data,
or it is <em>read owned</em> by a set of threads that can read but
not write the data.  Unfortunately, incorrect synchronization often
fails to enforce these policies and memory errors in languages like C
and C++ can violate these policies even when synchronization is
correct.<P>
In this paper, we present a dynamic analysis for checking ownership
policies in concurrent C and C++ programs despite memory errors. The
analysis can be used to find errors in commodity multi-threaded
programs and to prevent attacks that exploit these errors.  We require
programmers to write ownership assertions that describe the sharing
policies used by different parts of the program.  These policies may
change over time, as may the policies' means of enforcement, whether
it be locks, barriers, thread joins, etc. Our compiler inserts checks
in the program that signal an error if these policies are violated at
runtime.  We evaluated our tool on several benchmark programs.  The
run-time overhead was reasonable: between 0 and 49% with an average
of 26%.  We also found the tool easy to use: the total number of
ownership assertions is small, and the asserted specification and
implementation can be debugged together by running the instrumented
program and addressing the errors that arise.  Our approach enjoys a
pleasing modular soundness property: if a thread executes a sequence
of statements on variables it owns, the statements are serializable
within a valid execution, and thus their effects can be reasoned about
in isolation from other threads in the program.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/conccheck-full.pdf">.pdf</a> ]
<a name="martin10ownership"></a><pre>
@INPROCEEDINGS{martin10ownership,
  AUTHOR = {Jean-Philippe Martin and Michael Hicks and Manuel Costa and Periklis Akritidis and Miguel Castro},
  TITLE = {Dynamically Checking Ownership Policies in Concurrent {C/C++}
  Programs},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Principles of Programming Languages (POPL)},
  PAGES = {457--470},
  MONTH = JAN,
  YEAR = 2010,
  NOTE = {Full version}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>The Network Stack Trace: Performance diagnosis for networked systems</b>.
  Justin McCann and Michael Hicks, October 2011.</font><p>
Transient network stalls that degrade application performance are frustrating to
users and developers alike. Software bugs, network congestion, and intermittent
connectivity all have the same symptoms-low throughput, high latency, and
user-level timeouts. In this paper, we show how an end host can identify the
sources of network stalls using only simple counters from its local network stack.
By viewing the network stack as a producer-consumer dependency graph and
monitoring its activity as a whole, our rule-based expert system correctly
identifies which modules are hampering performance over 99% of the time, with
false positive rates under 3%.  The result is a network stack trace-a
lightweight snapshot of the end host's networking stack that describes the
behavior of each application, socket, connection, and interface.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/nest.pdf">.pdf</a> ]
<a name="mccann11nest"></a><pre>
@MISC{mccann11nest,
  TITLE = {The Network Stack Trace: Performance diagnosis for networked systems},
  AUTHOR = {Justin McCann and Michael Hicks},
  MONTH = OCT,
  YEAR = 2011,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Serializing C intermediate representations for efficient and portable
  parsing</b>.
  Jeffrey&nbsp;A. Meister, Jeffrey&nbsp;S. Foster, and Michael Hicks, May 2009.</font><p>
  C static analysis tools often use intermediate representations (IRs)
  that organize program data in a simple, well-structured
  manner. However, the C parsers that create IRs are slow, and because
  they are difficult to write, only a few implementations exist,
  limiting the languages in which a C static analysis can be written. To
  solve these problems, we investigate two language-independent,
  on-disk representations of C IRs: one using XML, and the other using
  an Internet standard binary encoding called XDR. We benchmark the
  parsing speeds of both options, finding the XML to be about a factor
  of two slower than parsing C and the XDR
  over six times faster.
  Furthermore, we show that the XML files are far too large
  at 19 times the size of C source code, while XDR is only 2.2 times
  the C size. We also demonstrate the
  portability of our XDR system by presenting a C source code querying tool in
  Ruby. Our solution and the insights we gained from building it will
  be useful to analysis authors and other clients of C IRs. We have made
  our software freely available for download at 
  <A HREF="http://www.cs.umd.edu/projects/PL/scil/">http://www.cs.umd.edu/projects/PL/scil/</A>.
  <p>[ <a href="http://www.cs.umd.edu/projects/PL/scil">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/scil.pdf">.pdf</a> ]
<a name="meister08cir"></a><pre>
@MISC{meister08cir,
  AUTHOR = {Jeffrey A. Meister and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Serializing {C} intermediate representations for efficient and portable parsing},
  HTTP = {<a href="http://www.cs.umd.edu/projects/PL/scil">http://www.cs.umd.edu/projects/PL/scil</a>},
  SUBMITTED = {yes},
  MONTH = MAY,
  YEAR = 2009
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Serializing C intermediate representations for efficient and portable
  parsing</b>.
  Jeffrey&nbsp;A. Meister, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  <i>Software, Practice, and Experience</i>, 40(3):225-238, February
  2010.</font><p>
  C static analysis tools often use intermediate representations (IRs)
  that organize program data in a simple, well-structured
  manner. However, the C parsers that create IRs are slow, and because
  they are difficult to write, only a few implementations exist,
  limiting the languages in which a C static analysis can be written. To
  solve these problems, we investigate two language-independent,
  on-disk representations of C IRs: one using XML, and the other using
  an Internet standard binary encoding called XDR. We benchmark the
  parsing speeds of both options, finding the XML to be about a factor
  of two slower than parsing C and the XDR
  over six times faster.
  Furthermore, we show that the XML files are far too large
  at 19 times the size of C source code, while XDR is only 2.2 times
  the C size. We also demonstrate the
  portability of our XDR system by presenting a C source code querying tool in
  Ruby. Our solution and the insights we gained from building it will
  be useful to analysis authors and other clients of C IRs. We have made
  our software freely available for download at 
  <A HREF="http://www.cs.umd.edu/projects/PL/scil/">http://www.cs.umd.edu/projects/PL/scil/</A>.
  <p>[ <a href="http://www.cs.umd.edu/projects/PL/scil">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/scil.pdf">.pdf</a> ]
<a name="meister10cir"></a><pre>
@ARTICLE{meister10cir,
  AUTHOR = {Jeffrey A. Meister and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Serializing {C} intermediate representations for efficient and portable parsing},
  JOURNAL = {Software, Practice, and Experience},
  MONTH = FEB,
  VOLUME = 40,
  NUMBER = 3,
  PAGES = {225--238},
  HTTP = {<a href="http://www.cs.umd.edu/projects/PL/scil">http://www.cs.umd.edu/projects/PL/scil</a>},
  YEAR = 2010
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Authenticated Data Structures, Generically</b>.
  Andrew Miller, Michael Hicks, Jonathan Katz, and Elaine Shi, July
  2013.</font><p>
  An authenticated data structure (ADS) is a data structure whose
  operations can be carried out by an untrusted <em>prover</em>, the
  results of which a <em>verifier</em> can efficiently check as
  authentic. This is done by having the prover produce a
  compact proof that the verifier can check along with each query result.
  ADSs thus support outsourcing data maintenance and processing tasks
  to untrusted servers without loss of integrity. Past work on ADSs
  has focused on particular data structures (or limited
  classes of data structures), one at a time, often with support only
  for particular operations. This
  paper presents a generic method, using a simple extension
  to a ML-like functional programming language we call lambdaAuth
  with 
  which one can program authenticated operations over any data
  structure constructed from standard type constructors, including
  recursive types, sums, and products. The programmer writes the data
  structure largely as usual; it can then be compiled to code
  to be run by the prover and verifier. Using a formalization of
  lambdaAuth
  we prove that all well-typed lambdaAuth programs result in code that is
  secure under the standard cryptographic assumption of
  collision-resistant hash functions. We have implemented
  our approach as an extension to the OCaml compiler, and have used it
  to produce authenticated versions of many interesting data
  structures including binary search trees, red-black trees, skip
  lists, and more. Performance experiments show that our approach is
  efficient, giving up little compared to the hand-optimized data
  structures developed previously.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/gpads.pdf">.pdf</a> ]
<a name="miller13gpads"></a><pre>
@MISC{miller13gpads,
  AUTHOR = {Andrew Miller and Michael Hicks and Jonathan Katz and Elaine Shi},
  TITLE = {Authenticated Data Structures, Generically},
  MONTH = JUL,
  YEAR = 2013,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Authenticated Data Structures, Generically</b>.
  Andrew Miller, Michael Hicks, Jonathan Katz, and Elaine Shi.
  In <i>Proceedings of the ACM Conference on Principles of
  Programming Languages (POPL)</i>, January 2014.</font><p>
  An authenticated data structure (ADS) is a data structure whose
  operations can be carried out by an untrusted <em>prover</em>, the
  results of which a <em>verifier</em> can efficiently check as
  authentic. This is done by having the prover produce a compact proof
  that the verifier can check along with each operation's result.  ADSs thus
  support outsourcing data maintenance and processing tasks to
  untrusted servers without loss of integrity. Past work on ADSs has
  focused on particular data structures (or limited classes of data
  structures), one at a time, often with support only for particular
  operations.<P>
This paper presents a generic method, using a simple
  extension to a ML-like functional programming language we call LambdaAuth,
  with which one can program authenticated operations
  over any data structure defined by standard type constructors,
  including recursive types, sums, and products. The programmer writes
  the data structure largely as usual and it is compiled to code
  to be run by the prover and verifier. Using a formalization of LambdaAuth
  we prove that all well-typed LambdaAuth programs result in code that is
  secure under the standard cryptographic assumption of
  collision-resistant hash functions. We have implemented LambdaAuth
  as an extension to the OCaml compiler, and have used it to produce
  authenticated versions of many interesting data structures including
  binary search trees, red-black+ trees, skip lists, and
  more. Performance experiments show that our approach is efficient,
  giving up little compared to the hand-optimized data structures
  developed previously.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/gpads.pdf">.pdf</a> ]
<a name="miller14gpads"></a><pre>
@INPROCEEDINGS{miller14gpads,
  AUTHOR = {Andrew Miller and Michael Hicks and Jonathan Katz and Elaine Shi},
  TITLE = {Authenticated Data Structures, Generically},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Principles of Programming Languages (POPL)},
  MONTH = JAN,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Understanding Source Code Evolution Using Abstract Syntax Tree Matching</b>.
  Iulian Neamtiu, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  In <i>Proceedings of the International Workshop on Mining Software
  Repositories (MSR)</i>, pages 1-5, May 2005.</font><p>
Mining software repositories at the source code level can provide a
greater understanding of how software evolves.
We present a tool for quickly comparing the source code of different
versions of a C program.  The approach is based on partial abstract
syntax tree matching, and can track simple
changes to global variables, types and functions.  These changes can
characterize aspects of software evolution useful for answering higher
level questions.  In particular, we consider how they could be used to 
inform the design of a dynamic software updating system.
We report results based on measurements of various versions of
popular open source
programs, including BIND, OpenSSH, Apache, Vsftpd and the Linux kernel.
  <p>[ <a href="http://www.cs.umd.edu/projects/dsu/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/evolution.pdf">.pdf</a> ]
<a name="neamtiu05evolution"></a><pre>
@INPROCEEDINGS{neamtiu05evolution,
  AUTHOR = {Iulian Neamtiu and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Understanding Source Code Evolution Using Abstract Syntax Tree Matching},
  BOOKTITLE = {Proceedings of the International Workshop on Mining Software Repositories (MSR)},
  PAGES = {1--5},
  MONTH = {May},
  YEAR = 2005,
  HTTP = {<a href="http://www.cs.umd.edu/projects/dsu/">http://www.cs.umd.edu/projects/dsu/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Practical Dynamic Software Updating for C</b>.
  Iulian Neamtiu, Michael Hicks, Gareth Stoyle, and Manuel Oriol.
  In <i>Proceedings of the ACM Conference on Programming Language
  Design and Implementation (PLDI)</i>, pages 72-83, June 2006.</font><p>
Software updates typically require stopping and restarting an
application, but many systems cannot afford to halt service, or would
prefer not to.  <em>Dynamic software updating</em> (DSU) addresses this
difficulty by permitting programs to be updated while they run.  DSU
is appealing compared to other approaches for on-line upgrades because
it is quite general and requires no redundant hardware.  The challenge
is in making DSU <em>practical</em>: it should be flexible, and yet
safe, efficient, and easy to use.<P>
In this paper, we present Ginseng, a DSU implementation for C that aims to
meet this challenge.  We compile programs specially so that they can
be dynamically patched, and generate most of a dynamic patch
automatically.  Ginseng performs a series of analyses that when
combined with some simple runtime support ensure that an update will
not violate type-safety while guaranteeing that data is kept
up-to-date.  We have used Ginseng to construct and dynamically
apply patches to three substantial open-source server
programs-<em>Very Secure FTP daemon</em>, <em>OpenSSH sshd daemon</em>, and
<em>GNU Zebra</em>.  In total, we dynamically patched each program with
three years' worth of releases.  Though the programs changed
substantially, the majority of updates were easy to generate.
Performance experiments show that all patches could be applied in less
than 5 <EM>ms</EM>, and that the overhead on application throughput due to
updating support ranged from 0 to at most 32%.
<p>[ <a href="http://www.cs.umd.edu/projects/dsu/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/ginseng.pdf">.pdf</a> ]
<a name="neamtiu06dsu"></a><pre>
@INPROCEEDINGS{neamtiu06dsu,
  AUTHOR = {Iulian Neamtiu and Michael Hicks and Gareth Stoyle and Manuel Oriol},
  TITLE = {Practical Dynamic Software Updating for {C}},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Programming Language Design and Implementation (PLDI)},
  PAGES = {72--83},
  LOCATION = {Ottawa, Canada},
  MONTH = {June},
  YEAR = {2006},
  HTTP = {<a href="http://www.cs.umd.edu/projects/dsu/">http://www.cs.umd.edu/projects/dsu/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Practical Dynamic Software Updating for C (Extended version)</b>.
  Iulian Neamtiu, Michael Hicks, Gareth Stoyle, and Manuel Oriol.
  Technical Report CS-TR-4790, Department of Computer Science,
  University of Maryland, March 2006.
  Extended version of PLDI 06 paper.</font><p><p>[ <a href="http://www.cs.umd.edu/projects/dsu/">http</a> ]
<a name="neamtiu06dsutr"></a><pre>
@TECHREPORT{neamtiu06dsutr,
  AUTHOR = { Iulian Neamtiu and Michael Hicks and Gareth Stoyle and Manuel Oriol},
  TITLE = {Practical Dynamic Software Updating for {C} (Extended version)},
  INSTITUTION = {Department of Computer Science, University of Maryland},
  NUMBER = {CS-TR-4790},
  YEAR = 2006,
  MONTH = {March},
  NOTE = {Extended version of PLDI 06 paper},
  HTTP = {<a href="http://www.cs.umd.edu/projects/dsu/">http://www.cs.umd.edu/projects/dsu/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Contextual Effects for Version-Consistent Dynamic Software Updating and
  Safe Concurrent Programming</b>.
  Iulian Neamtiu, Michael Hicks, Jeffrey&nbsp;S. Foster, and Polyvios
  Pratikakis, July 2007.
  Submitted for publication.</font><p>
This paper presents a generalization of standard effect systems that
we call <em>contextual effects</em>.  A traditional effect system
computes the effect of an expression <EM>e</EM>.  Our system additionally
computes the effects of the computational context in which <EM>e</EM> occurs:
both the effect of the computation that has already occurred
(<em>prior effects</em>) and the effect of the computation yet to take
place (<em>future effects</em>).<P>
Contextual effects can be used in any application in which the past or
future computation of the program is relevant at various program points.  We
present two substantial examples.  First, we show how prior and future
effects can be used to enforce <em>transactional version consistency</em>
(TVC), a novel correctness property for dynamic software updates. TVC
ensures that programmer-designated transactional code blocks appear to
execute entirely at the same code version, even if a dynamic update occurs
in the middle of the block.  Second, we show how future effects can be used
in the analysis of multi-threaded programs to find thread-shared locations.
This is an essential step in applications such as data race detection.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/contexteffs.pdf">.pdf</a> ]
<a name="neamtiu07context"></a><pre>
@MISC{neamtiu07context,
  AUTHOR = {Iulian Neamtiu and Michael Hicks and Jeffrey S. Foster and Polyvios Pratikakis},
  TITLE = {Contextual Effects for Version-Consistent Dynamic Software Updating and Safe Concurrent Programming},
  NOTE = {Submitted for publication},
  MONTH = JUL,
  YEAR = 2007
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Contextual Effects for Version-Consistent Dynamic Software Updating and
  Safe Concurrent Programming</b>.
  Iulian Neamtiu, Michael Hicks, Jeffrey&nbsp;S. Foster, and Polyvios
  Pratikakis.
  In <i>Proceedings of the ACM Conference on Principles of
  Programming Languages (POPL)</i>, pages 37-50, January 2008.</font><p>
This paper presents a generalization of standard effect systems that
we call <em>contextual effects</em>.  A traditional effect system
computes the effect of an expression <EM>e</EM>.  Our system additionally
computes the effects of the computational context in which <EM>e</EM> occurs:
both the effect of the computation that has already occurred
(<em>prior effects</em>) and the effect of the computation yet to take
place (<em>future effects</em>).<P>
Contextual effects can be used in any application in which the past or
future computation of the program is relevant at various program points.  We
present two substantial examples.  First, we show how prior and future
effects can be used to enforce <em>transactional version consistency</em>
(TVC), a novel correctness property for dynamic software updates. TVC
ensures that programmer-designated transactional code blocks appear to
execute entirely at the same code version, even if a dynamic update occurs
in the middle of the block.  Second, we show how future effects can be used
in the analysis of multi-threaded programs to find thread-shared locations.
This is an essential step in applications such as data race detection.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/contexteffs.pdf">.pdf</a> ]
<a name="neamtiu08context"></a><pre>
@INPROCEEDINGS{neamtiu08context,
  AUTHOR = {Iulian Neamtiu and Michael Hicks and Jeffrey S. Foster and Polyvios Pratikakis},
  TITLE = {Contextual Effects for Version-Consistent Dynamic Software Updating and Safe Concurrent Programming},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Principles of Programming Languages (POPL)},
  PAGES = {37--50},
  MONTH = JAN,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Safe and Timely Dynamic Updates for Multi-threaded Programs</b>.
  Iulian Neamtiu and Michael Hicks.
  In <i>Proceedings of the ACM Conference on Programming Language
  Design and Implementation (PLDI)</i>, pages 13-24, June 2009.</font><p>
  Many dynamic updating systems have been developed that enable a
  program to be patched while it runs, to fix bugs or add new
  features.  This paper explores techniques for supporting dynamic
  updates to multi-threaded programs, focusing on the problem of
  applying an update in a timely fashion
  while still producing correct behavior.  Past work has shown that
  this tension of <em>safety</em> versus <em>timeliness</em> can be balanced for
  single-threaded programs.  For
  multi-threaded programs, the task is more difficult because
  myriad thread interactions complicate understanding the possible
  program states to which a patch could be applied.  Our approach allows
  the programmer to specify a few program points (e.g., one per
  thread) at which a patch may be applied, which simplifies reasoning
  about safety.  To improve timeliness, a combination of static
  analysis and run-time support automatically expands these few points
  to many more that produce behavior equivalent to
  the originals.  Experiments with thirteen realistic updates to three
  multi-threaded servers show that we can safely perform a dynamic
  update within milliseconds when more straightforward alternatives would
  delay some updates indefinitely.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/ginsengMT.pdf">.pdf</a> ]
<a name="neamtiu09stump"></a><pre>
@INPROCEEDINGS{neamtiu09stump,
  TITLE = {Safe and Timely Dynamic Updates for Multi-threaded Programs},
  AUTHOR = {Iulian Neamtiu and Michael Hicks},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Programming Language Design and Implementation (PLDI)},
  MONTH = JUN,
  YEAR = 2009,
  PAGES = {13--24}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Tagged Sets: a Secure and Transparent Coordination Medium</b>.
  Manuel Oriol and Michael Hicks.
  In Jean-Marie Jacquet and Gian&nbsp;Pietro Picco, editors, <i>
  Proceedings of the International Conference on Coordination Models and
  Languages (COORDINATION)</i>, volume 3454 of <i>Lecture Notes in Computer
  Science</i>, pages 252-267. Springer-Verlag, April 2005.</font><p>
A simple and effective way of coordinating distributed, mobile, and
parallel applications is to use a virtual shared memory (VSM), such as
a Linda tuple-space.  In this paper, we propose a new kind of VSM,
called a <em>tagged set</em>.  Each element in the VSM is a value with
an associated tag, and values are read or removed from the VSM by
matching the tag.  Tagged sets exhibit three properties useful for
VSMs:
<p><ol>
<li> <em>Ease of use</em>. A tagged value naturally corresponds to the
  notion that data has certain attributes, expressed by the tag, which
  can be used for later retrieval.<P>
<li> <em>Flexibility</em>. Tags are implemented as propositional logic
  formulae, and selection as logical implication, so the resulting
  system is quite powerful.  Tagged sets naturally support a variety
  of applications, such as shared data repositories (e.g., for media
  or e-mail), message passing, and publish/subscribe algorithms;
  they are powerful enough to encode existing VSMs,
  such as Linda spaces.<P>
<li> <em>Security</em>.  Our notion of tags naturally corresponds to
  keys, or capabilities: a user may not select data in the set unless
  she presents a legal key or keys.  Normal tags correspond to
  symmetric keys, and we introduce <em>asymmetric tags</em> that
  correspond to public and private key pairs.  Treating tags as keys
  permits users to easily specify protection criteria for data at a
  fine granularity.
</ol>
This paper motivates our approach, sketches its basic theory, and
places it in the context of other data management strategies.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/tsets.pdf">.pdf</a> ]
<a name="oriol05tset"></a><pre>
@INPROCEEDINGS{oriol05tset,
  TITLE = {Tagged Sets: a Secure and Transparent Coordination Medium},
  AUTHOR = {Manuel Oriol and Michael Hicks},
  BOOKTITLE = {Proceedings of the International Conference on Coordination Models and Languages (COORDINATION)},
  MONTH = {April},
  LOCATION = {Namur, Belgium},
  YEAR = {2005},
  PUBLISHER = {Springer-Verlag},
  EDITOR = {Jean-Marie Jacquet and Gian Pietro Picco},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = {3454},
  PAGES = {252--267}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Merging Network Measurement with Data Transport (Extended Abstract)</b>.
  Pavlos Papageorgiou and Michael Hicks.
  In <i>Proceedings of the IEEE Passive/Active Measurement Workshop
  (PAM)</i>, volume 3431, pages 368-371. Springer-Verlag, March 2005.</font><p>
The tasks of measurement and data transport are often treated
independently, but we believe there are benefits to bringing them
together.  This paper proposes the simple idea of a transport agent
to encapsulate useful data within probe packets in place of
useless padding.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/probe-transport.pdf">.pdf</a> ]
<a name="papageorgiou04probe"></a><pre>
@INPROCEEDINGS{papageorgiou04probe,
  TITLE = {Merging Network Measurement with Data Transport (Extended Abstract)},
  AUTHOR = {Pavlos Papageorgiou and Michael Hicks},
  BOOKTITLE = {Proceedings of the {IEEE} Passive/Active Measurement Workshop (PAM)},
  JOURNAL = {Lecture Notes in Computer Science},
  VOLUME = 3431,
  PUBLISHER = {Springer-Verlag},
  MONTH = {March},
  WHERE = {Boston, USA},
  YEAR = {2005},
  PAGES = {368--371}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>MGRP: Active Measurement, Passively</b>.
  Pavlos Papageorgiou, Justin McCann, and Michael Hicks, October 2008.</font><p>
Current active measurement techniques run independently of application
traffic and compete with it for bandwidth.  As a remedy to this, some
applications try to use their own traffic to perform measurement, but
this is done in an ad hoc manner that is tightly coupled to the
application itself. On the other hand, most standalone active
measurement tools include significant portions of empty padding in their
probes.  A natural optimization is to reuse this wasted bandwidth for
useful data, enabling applications to measure the network in the course
of sending their own data traffic.<P>
In this paper we present MGRP, a system for transparently integrating
measurement and application traffic. Through a series of experiments and
empirical evaluation we show that MGRP permits continuous network
measurement in the presence of application traffic.  This enables
applications to quickly respond to varying network conditions with
minimal impact on their own traffic and competing traffic while
increasing the timeliness of measurement results.
  <p><a name="papageorgiou08mgrp"></a><pre>
@MISC{papageorgiou08mgrp,
  AUTHOR = {Pavlos Papageorgiou and Justin McCann and Michael Hicks},
  TITLE = {MGRP: Active Measurement, Passively},
  MONTH = OCT,
  YEAR = 2008,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Passive Aggressive Measurement with MGRP</b>.
  Pavlos Papageorge, Justin McCann, and Michael Hicks.
  In <i>Proceedings of the ACM SIGCOMM Conference on
  Applications, Technologies, Architectures, and Protocols for Computer
  Communications (SIGCOMM)</i>, pages 279-290, August 2009.</font><p>
  We present the <em>Measurement Manager Protocol</em> (MGRP),
  an in-kernel service that schedules and transmits probes
  on behalf of active measurement tools.  Unlike prior measurement
  services, MGRP transparently piggybacks application packets inside
  the often significant amounts of empty padding contained in typical
  probes.  Using MGRP thus combines the modularity, flexibility, and
  accuracy of standalone active measurement tools with the lower
  overhead of passive measurement techniques.  Microbenchmark experiments
  show that the resulting bandwidth savings makes it possible to
  measure the network accurately, but faster and more aggressively than
  without piggybacking, and with
  few ill effects to piggybacked application or competing
  traffic.  When using MGRP to schedule
  measurements on behalf of MediaNet, an overlay service
  that adaptively schedules media streams, we show MediaNet can achieve
  significantly higher streaming rates under the same network
  conditions.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/mgrp.pdf">.pdf</a> ]
<a name="papageorgiou09mgrp"></a><pre>
@INPROCEEDINGS{papageorgiou09mgrp,
  AUTHOR = {Pavlos Papageorge and Justin McCann and Michael Hicks},
  TITLE = {Passive Aggressive Measurement with {MGRP}},
  BOOKTITLE = {Proceedings of the {ACM} {SIGCOMM} Conference on Applications, Technologies, Architectures, and Protocols for Computer Communications (SIGCOMM)},
  PAGES = {279--290},
  MONTH = AUG,
  YEAR = 2009
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Automated Detection of Persistent Kernel Control-Flow Attacks</b>.
  Nick&nbsp;L. Petroni, Jr. and Michael Hicks.
  In <i>Proceedings of the ACM Conference on Computer and
  Communications Security (CCS)</i>, pages 103-115, October 2007.</font><p>
This paper presents a new approach to dynamically monitoring operating
system kernel integrity, based on a property called <em>state-based
control-flow integrity</em> (SBCFI).  Violations of SBCFI signal a
persistent, unexpected modification of the kernel's control-flow
graph.  We performed a thorough analysis of 25 Linux rootkits and
found that 24 (96%) employ persistent control-flow modifications; an
informal study of Windows rootkits yielded similar results.  We have
implemented SBCFI enforcement as part of the Xen and VMware virtual
machine monitors.  Our implementation detected all the control-flow
modifying rootkits we could install, while imposing unnoticeable
overhead for both a typical web server workload and CPU-intensive
workloads when operating at 10 second intervals.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/sbcfi.pdf">.pdf</a> ]
<a name="petroni07sbcfi"></a><pre>
@INPROCEEDINGS{petroni07sbcfi,
  AUTHOR = {Petroni, Jr., Nick L. and Michael Hicks},
  TITLE = {Automated Detection of Persistent Kernel Control-Flow Attacks},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Computer and Communications Security (CCS)},
  MONTH = OCT,
  PAGES = {103--115},
  YEAR = 2007
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Automated Detection of Persistent Kernel Control-Flow Attacks</b>.
  Nick&nbsp;L. Petroni, Jr. and Michael Hicks.
  Technical Report CS-TR-4880, Department of Computer Science,
  University of Maryland, October 2007.
  Extends the CCS 2007 paper with more thorough performance results.</font><p>
This paper presents a new approach to dynamically monitoring operating
system kernel integrity, based on a property called <em>state-based
control-flow integrity</em> (SBCFI).  Violations of SBCFI signal a
persistent, unexpected modification of the kernel's control-flow
graph.  We performed a thorough analysis of 25 Linux rootkits and
found that 24 (96%) employ persistent control-flow modifications; an
informal study of Windows rootkits yielded similar results.  We have
implemented SBCFI enforcement as part of the Xen and VMware virtual
machine monitors.  Our implementation detected all the control-flow
modifying rootkits we could install, while imposing negligible
overhead for both a typical web server workload and CPU-intensive
workloads when operating at 1 second intervals on a multi-core machine.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/CS-TR-4880.pdf">.pdf</a> ]
<a name="petroni07sbcfitr"></a><pre>
@TECHREPORT{petroni07sbcfitr,
  AUTHOR = {Petroni, Jr., Nick L. and Michael Hicks},
  TITLE = {Automated Detection of Persistent Kernel Control-Flow Attacks},
  INSTITUTION = {Department of Computer Science, University of Maryland},
  NUMBER = {CS-TR-4880},
  MONTH = OCT,
  NOTE = {Extends the CCS 2007 paper with more thorough performance results},
  YEAR = 2007
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Rubah: Efficient, General-purpose Dynamic Software Updating for Java</b>.
  Luis Pina and Michael Hicks.
  In <i>Proceedings of the Workshop on Hot Topics in Software
  Upgrades (HotSWUp)</i>, June 2013.</font><p>
  This paper presents Rubah, a new dynamic software updating (DSU)
  system for Java programs that works on stock VMs.  Rubah supports a
  large range of program changes (e.g., changes to the class hierarchy
  and updates to running methods), does not restrict important
  programming idioms (e.g., reflection), and, as shown by performance
  experiments using an updatable version of the H2 database management
  system, imposes low overhead on normal execution.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/rubah.pdf">.pdf</a> ]
<a name="pina13rubah"></a><pre>
@INPROCEEDINGS{pina13rubah,
  TITLE = {Rubah: Efficient, General-purpose Dynamic Software Updating for {Java}},
  AUTHOR = {Luis Pina and Michael Hicks},
  BOOKTITLE = {Proceedings of the Workshop on Hot Topics in Software Upgrades (HotSWUp)},
  MONTH = JUN,
  YEAR = 2013
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Rubah: DSU for Java on a stock JVM</b>.
  Lus Pina, Lus Veiga, and Michael Hicks.
  In <i>Proceedings of the ACM Conference on Object-Oriented
  Programming Languages, Systems, and Applications (OOPSLA)</i>, October 2014.</font><p>
  This paper presents Rubah, the first <em>dynamic software
    updating</em> system for Java that: is portable, implemented via
  libraries and bytecode rewriting on top of a standard JVM; is
  efficient, imposing essentially no overhead on normal, steady-state execution; is
  flexible, allowing nearly arbitrary changes to classes between updates; and
  is non-disruptive, employing either a novel <em>eager</em> algorithm
  that transforms the program state with multiple threads, or a novel
  <em>lazy</em> algorithm that transforms objects as they are demanded,
  post-update. Requiring little programmer effort, Rubah has been used
  to dynamically update five
  long-running applications: the H2 database, the
  Voldemort key-value store, the Jake2 implementation of the Quake
  2 shooter game, the CrossFTP server, and the JavaEmailServer.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/rubah-oopsla14.pdf">.pdf</a> ]
<a name="pina14rubah"></a><pre>
@INPROCEEDINGS{pina14rubah,
  TITLE = {Rubah: {DSU} for Java on a stock {JVM}},
  AUTHOR = {Lu\'is Pina and Lu\'is Veiga and Michael Hicks},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Object-Oriented Programming Languages, Systems, and Applications (OOPSLA)},
  MONTH = OCT,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Tedsuto: A General Framework for Testing Dynamic Software Updates</b>.
  Luis Pina and Michael Hicks, October 2015.</font><p>
  Dynamic software updating (DSU) is a technique for patching
  <em>running</em> programs, to fix bugs or add new features.
  DSU avoids the downtime of stop-and-restart updates, but creates new
  risks-an incorrect or ill-timed dynamic update could result in a
  crash or misbehavior, defeating the whole purpose of DSU. To
  reduce such risks, dynamic updates should be carefully
  tested before they are deployed.
  This paper presents Tedsuto, a general testing framework for DSU,
  along with a concrete implementation of it for Rubah, a state-of-the-art Java-based
  DSU system. Tedsuto uses system-level tests developed for the old
  and new versions of the updateable software, and systematically
  tests whether a dynamic update might result in a test
  failure. Very often this process is fully automated, while in some
  cases (e.g., to test new-version functionality) some manual
  annotations are required. 
  To evaluate Tedsuto's efficacy, we applied it to dynamic
  updates previously developed (and tested in an ad hoc manner) for
  the H2 SQL database server and the CrossFTP server- two
  real-world, multithreaded systems.  We used three large test suites, totalling
  446 tests, and we found a variety of
  update-related bugs in short order, and at low cost.  
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/tedsuto-submitted.pdf">.pdf</a> ]
<a name="pina15tedsuto"></a><pre>
@MISC{pina15tedsuto,
  AUTHOR = {Luis Pina and Michael Hicks},
  TITLE = {Tedsuto: A General Framework for Testing Dynamic Software Updates},
  SUBMITTED = {yes},
  YEAR = 2015,
  MONTH = OCT
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Tedsuto: A General Framework for Testing Dynamic Software Updates</b>.
  Luis Pina and Michael Hicks.
  In <i>Proceedings of the International Conference on Software
  Testing (ICST)</i>, April 2016.</font><p>
  Dynamic software updating (DSU) is a technique for patching
  <em>running</em> programs, to fix bugs or add new features.
  DSU avoids the downtime of stop-and-restart updates, but creates new
  risks-an incorrect or ill-timed dynamic update could result in a
  crash or misbehavior, defeating the whole purpose of DSU. To
  reduce such risks, dynamic updates should be carefully
  tested before they are deployed.
  This paper presents Tedsuto, a general testing framework for DSU,
  along with a concrete implementation of it for Rubah, a state-of-the-art Java-based
  DSU system. Tedsuto uses system-level tests developed for the old
  and new versions of the updateable software, and systematically
  tests whether a dynamic update might result in a test
  failure. Very often this process is fully automated, while in some
  cases (e.g., to test new-version functionality) some manual
  annotations are required. 
  To evaluate Tedsuto's efficacy, we applied it to dynamic
  updates previously developed (and tested in an ad hoc manner) for
  the H2 SQL database server and the CrossFTP server- two
  real-world, multithreaded systems.  We used three large test suites, totalling
  446 tests, and we found a variety of
  update-related bugs in short order, and at low cost.  
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/tedsuto.pdf">.pdf</a> ]
<a name="pina16tedsuto"></a><pre>
@INPROCEEDINGS{pina16tedsuto,
  AUTHOR = {Luis Pina and Michael Hicks},
  BOOKTITLE = {Proceedings of the International Conference on Software Testing (ICST)},
  TITLE = {Tedsuto: A General Framework for Testing Dynamic Software Updates},
  YEAR = 2016,
  MONTH = APR
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Transparent Proxies for Java Futures</b>.
  Polyvios Pratikakis, Jaime Spacco, and Michael Hicks.
  In <i>Proceedings of the ACM Conference on Object-Oriented
  Programming Languages, Systems, and Applications (OOPSLA)</i>, pages 206-223,
  October 2004.</font><p>
A <em>proxy</em> object is a surrogate or placeholder that controls access to
another target object.  Proxies can be used to support distributed
programming, lazy or parallel evaluation, access control, and other simple
forms of behavioral reflection.  However, <em>wrapper proxies</em>
(like <em>futures</em> or <em>suspensions</em> for yet-to-be-computed results)
can require significant code changes to be used in statically-typed
languages, while proxies more generally can inadvertently violate
assumptions of transparency, resulting in subtle bugs.<P>
To solve these problems, we have designed and implemented a simple framework
for proxy programming that employs a static analysis based on qualifier
inference, but with additional novelties.  Code for
using wrapper proxies is automatically introduced via a
classfile-to-classfile transformation, and potential violations of
transparency are signaled to the programmer.  We have formalized our
analysis and proven it sound.  Our framework has a variety of applications,
including support for asynchronous method calls returning futures.
Experimental results demonstrate the benefits of our framework: programmers
are relieved of managing and/or checking proxy usage, analysis times are
reasonably fast, overheads introduced by added dynamic checks are
negligible, and performance improvements can be significant.  For example,
changing two lines in a simple RMI-based peer-to-peer application and then
using our framework resulted in a large performance gain.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/transparent-proxies.pdf">.pdf</a> ]
<a name="pratikakis04transparent"></a><pre>
@INPROCEEDINGS{pratikakis04transparent,
  AUTHOR = {Polyvios Pratikakis and Jaime Spacco and Michael Hicks},
  TITLE = {Transparent Proxies for {Java} Futures},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Object-Oriented Programming Languages, Systems, and Applications (OOPSLA)},
  MONTH = {October},
  YEAR = 2004,
  WHERE = {Vancouver, Canada},
  PAGES = {206--223}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Transparent Proxies for Java Futures (Extended version)</b>.
  Polyvios Pratikakis, Jaime Spacco, and Michael Hicks.
  Technical Report CS-TR-4574, University of Maryland, Department of
  Computer Science, October 2004.</font><p>
A <em>proxy</em> object is a surrogate or placeholder that controls access to
another target object.  Proxies can be used to support distributed
programming, lazy or parallel evaluation, access control, and other simple
forms of behavioral reflection.  However, <em>wrapper proxies</em>
(like <em>futures</em> or <em>suspensions</em> for yet-to-be-computed results)
can require significant code changes to be used in statically-typed
languages, while proxies more generally can inadvertently violate
assumptions of transparency, resulting in subtle bugs.<P>
To solve these problems, we have designed and implemented a simple framework
for proxy programming that employs a static analysis based on qualifier
inference, but with additional novelties.  Code for
using wrapper proxies is automatically introduced via a
classfile-to-classfile transformation, and potential violations of
transparency are signaled to the programmer.  We have formalized our
analysis and proven it sound.  Our framework has a variety of applications,
including support for asynchronous method calls returning futures.
Experimental results demonstrate the benefits of our framework: programmers
are relieved of managing and/or checking proxy usage, analysis times are
reasonably fast, overheads introduced by added dynamic checks are
negligible, and performance improvements can be significant.  For example,
changing two lines in a simple RMI-based peer-to-peer application and then
using our framework resulted in a large performance gain.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/proxies-tr.pdf">.pdf</a> ]
<a name="pratikakis04transparentTR"></a><pre>
@TECHREPORT{pratikakis04transparentTR,
  AUTHOR = {Polyvios Pratikakis and Jaime Spacco and Michael Hicks},
  TITLE = {Transparent Proxies for {Java} Futures (Extended version)},
  MONTH = {October},
  YEAR = 2004,
  WHERE = {Vancouver, Canada},
  NUMBER = {CS-TR-4574},
  INSTITUTION = {University of Maryland, Department of Computer Science}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Existential Label Flow Inference via CFL Reachability (Extended
  Version)</b>.
  Polyvios Pratikakis, Michael Hicks, and Jeffrey&nbsp;S. Foster.
  Technical Report CS-TR-4700, Department of Computer Science,
  University of Maryland, July 2005.</font><p>
  Label flow analysis is a fundamental static analysis problem with a
  wide variety of applications.  Previous work by Mossin developed a
  polynomial time subtyping-based label flow inference that supports
  Hindley-Milner style polymorphism with polymorphic recursion.  Rehof
  et al have developed an efficient <EM>O</EM>(<EM>n</EM><sup>3</sup>) inference algorithm for
  Mossin's system based on context-free language (CFL) reachability.
  In this paper, we extend these results to a system that also
  supports existential polymorphism, which is important for precisely
  describing correlations among members of a structured type, even
  when values of that type are part of dynamic data structures.  We
  first develop a provably sound checking system based on
  polymorphically-constrained types.  As usual, we restrict universal
  quantification to the top level of a type, but existential
  quantification is first class, with subtyping allowed between
  existentials with the same binding structure.  We then develop a
  CFL-based inference system.  Programmers specify which positions in
  a type are existentially quantified, and the algorithm infers the
  constraints bound in the type, or rejects a program if the
  annotations are inconsistent.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/existsflow-tr.pdf">.pdf</a> ]
<a name="pratikakis05existstr"></a><pre>
@TECHREPORT{pratikakis05existstr,
  AUTHOR = {Polyvios Pratikakis and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Existential Label Flow Inference via {CFL} Reachability (Extended Version)},
  INSTITUTION = {Department of Computer Science, University of Maryland},
  NUMBER = {CS-TR-4700},
  YEAR = 2005,
  MONTH = JUL
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Existential Label Flow Inference via CFL Reachability</b>.
  Polyvios Pratikakis, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  In Kwangkeun Yi, editor, <i>Proceedings of the Static Analysis
  Symposium (SAS)</i>, volume 4134 of <i>Lecture Notes in Computer Science</i>,
  pages 88-106. Springer-Verlag, August 2006.</font><p>
  In programming languages, existential quantification is useful for
  describing relationships among members of a structured type.  For
  example, we may have a list in which there <em>exists</em> some
  mutual exclusion lock <EM>l</EM> in each list element such that <EM>l</EM>
  protects the data stored in that element.
  With this information, a static analysis can reason
  about the relationship between locks and locations in the list even
  when the precise identity of the lock and/or location is unknown.
  To facilitate the construction of such static analyses, this paper
  presents a context-sensitive <em>label flow analysis</em> algorithm with
  support
  for existential quantification.  Label flow analysis is a core part
  of many static analysis systems.  Following Rehof et al, we use context-free
  language (CFL) reachability to develop an efficient <EM>O</EM>(<EM>n</EM><sup>3</sup>)
  label flow inference algorithm.  We prove the algorithm sound by reducing its
  derivations to those in a system based on
  polymorphically-constrained types, in the style of Mossin.  We have
  implemented a variant of our analysis as part of a data race detection
  tool for C programs.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/existsflow.pdf">.pdf</a> ]
<a name="pratikakis06exists"></a><pre>
@INPROCEEDINGS{pratikakis06exists,
  AUTHOR = {Polyvios Pratikakis and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Existential Label Flow Inference via {CFL} Reachability},
  BOOKTITLE = {Proceedings of the Static Analysis Symposium (SAS)},
  YEAR = 2006,
  MONTH = AUG,
  PUBLISHER = {Springer-Verlag},
  EDITOR = {Kwangkeun Yi},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = {4134},
  PAGES = {88--106}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Context-sensitive Correlation Analysis for Detecting Races</b>.
  Polyvios Pratikakis, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  In <i>Proceedings of the ACM Conference on Programming Language
  Design and Implementation (PLDI)</i>, pages 320-331, June 2006.</font><p>
One common technique for preventing data races in multi-threaded
programs is to ensure that all accesses to shared locations are
consistently protected by a lock.  We present a tool called Locksmith
for detecting data races in C programs by looking for violations of
this pattern.  We call the relationship between locks and the
locations they protect consistent correlation, and the core of our
technique is a novel constraint-based analysis that infers
consistent correlation context-sensitively, using the results to check that
locations are properly guarded by locks.  We present the core of
our algorithm for a simple formal language <em>lambda-corr</em> which we have
proven sound, and discuss how we scale it up to an algorithm that
aims to be sound for all of C.
We develop several techniques to improve the precision and
performance of the analysis, including a sharing analysis for
inferring thread locality; existential quantification for modeling
locks in data structures; and heuristics for modeling unsafe
features of C such as type casts.  When applied to several
benchmarks, including multi-threaded servers and Linux device
drivers, Locksmith found several races while producing a modest
number of false alarms.
<p>[ <a href="http://www.cs.umd.edu/~polyvios/locksmith/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/locksmith.pdf">.pdf</a> ]
<a name="pratikakis06locksmith"></a><pre>
@INPROCEEDINGS{pratikakis06locksmith,
  TITLE = {Context-sensitive Correlation Analysis for Detecting Races},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Programming Language Design and Implementation (PLDI)},
  AUTHOR = {Polyvios Pratikakis and Jeffrey S. Foster and Michael Hicks},
  PAGES = {320--331},
  LOCATION = {Ottawa, Canada},
  HTTP = {<a href="http://www.cs.umd.edu/~polyvios/locksmith/">http://www.cs.umd.edu/~polyvios/locksmith/</a>},
  MONTH = {June},
  YEAR = 2006
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Context-sensitive Correlation Analysis for Detecting Races (Extended
  version)</b>.
  Polyvios Pratikakis, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  Technical Report CS-TR-4789, Department of Computer Science,
  University of Maryland, June 2006.
  Extends PLDI 2006 paper with full formal development.</font><p>
One common technique for preventing data races in multi-threaded
programs is to ensure that all accesses to shared locations are
consistently protected by a lock.  We present a tool called Locksmith
for detecting data races in C programs by looking for violations of
this pattern.  We call the relationship between locks and the
locations they protect consistent correlation, and the core of our
technique is a novel constraint-based analysis that infers
consistent correlation context-sensitively, using the results to check that
locations are properly guarded by locks.  We present the core of
our algorithm for a simple formal language <em>lambda-corr</em> which we have
proven sound, and discuss how we scale it up to an algorithm that
aims to be sound for all of C.
We develop several techniques to improve the precision and
performance of the analysis, including a sharing analysis for
inferring thread locality; existential quantification for modeling
locks in data structures; and heuristics for modeling unsafe
features of C such as type casts.  When applied to several
benchmarks, including multi-threaded servers and Linux device
drivers, Locksmith found several races while producing a modest
number of false alarms.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/locksmith-tr.pdf">.pdf</a> ]
<a name="pratikakis06locksmithtr"></a><pre>
@TECHREPORT{pratikakis06locksmithtr,
  TITLE = {Context-sensitive Correlation Analysis for Detecting Races (Extended version)},
  AUTHOR = {Polyvios Pratikakis and Jeffrey S. Foster and Michael Hicks},
  INSTITUTION = {Department of Computer Science, University of Maryland},
  NUMBER = {CS-TR-4789},
  NOTE = {Extends PLDI 2006 paper with full formal development},
  MONTH = {June},
  YEAR = 2006
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Formalizing Soundness of Contextual Effects</b>.
  Polyvios Pratikakis, Jeffrey&nbsp;S. Foster, Michael Hicks, and Iulian
  Neamtiu.
  In Otmane&nbsp;At Mohamed, Csar Munoz, and Sofine Tahar,
  editors, <i>Proceedings of the International Conference on Theorem Proving
  in Higher Order Logics (TPHOLs)</i>, volume 5170 of <i>Lecture Notes in
  Computer Science</i>, pages 262-277. Springer, August 2008.</font><p>
  A <em>contextual effects</em> system generalizes standard type
  and effect systems: where a standard effects system computes the
  effect of an expression <EM>e</EM>, a contextual effects system
  additionally computes the <em>prior</em> and <em>future</em> effect of
  <EM>e</EM>, which characterize the behavior of computation prior to, and
  following, respectively, the evaluation of <EM>e</EM>.  This paper
  describes the formalization and proof of soundness of contextual
  effects, which we mechanized using the Coq proof assistant.
  Contextual effect soundness is an unusual property because the prior
  and future effect of a term <EM>e</EM> depends not on <EM>e</EM> itself (or its
  evaluation), but rather on the evaluation of the context in which
  <EM>e</EM> appears.  Therefore, to state and prove soundness we must
  ``match up'' a subterm in the original typing derivation with the
  possibly-many evaluations of that subterm during the evaluation of
  the program, in a way that is robust under substitution.  We do this
  using a novel typed operational semantics.  We conjecture that our
  approach could prove useful for approaching other properties of
  derivations that rely on the context in which that derivation
  appears.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/contextproof.pdf">.pdf</a> ]
<a name="pratikakis08context"></a><pre>
@INPROCEEDINGS{pratikakis08context,
  AUTHOR = {Polyvios Pratikakis and Jeffrey S. Foster and Michael Hicks and Iulian Neamtiu},
  TITLE = {Formalizing Soundness of Contextual Effects},
  BOOKTITLE = {Proceedings of the International Conference on Theorem Proving in Higher Order Logics (TPHOLs)},
  EDITOR = {Otmane A\"it Mohamed and C\'esar Mu\={n}oz and Sofi\`ene Tahar},
  PAGES = {262--277},
  PUBLISHER = {Springer},
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = {5170},
  MONTH = AUG,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Locksmith: Practical Static Race Detection for C</b>.
  Polyvios Pratikakis, Jeffrey&nbsp;S. Foster, and Michael Hicks, July 2008.</font><p>
  Locksmith is a static analysis tool for automatically detecting
  data races in C programs.  In this paper, we describe each of
  Locksmith's component analyses precisely, and present systematic
  measurements that isolate interesting tradeoffs between precision
  and efficiency in each analysis.  Using a benchmark suite comprising
  standalone applications and Linux device drivers totaling more than
  200,000 lines of code, we found that a simple no-worklist strategy
  yielded the most efficient interprocedural dataflow analysis; that
  our sharing analysis was able to determine that most locations are
  thread-local, and therefore need not be protected by locks; that
  modeling C structs and void pointers precisely is key to both
  precision and efficiency; and that context-sensitivity yields a much
  more precise analysis, though with decreased scalability.  Put
  together, our results illuminate some of the key engineering
  challenges in building Locksmith and data race detection analyses
  in particular, and constraint-based program analyses in general.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/locksmith-journal-sub.pdf">.pdf</a> ]
<a name="pratikakis08locksmith"></a><pre>
@MISC{pratikakis08locksmith,
  TITLE = {Locksmith: Practical Static Race Detection for {C}},
  AUTHOR = {Polyvios Pratikakis and Jeffrey S. Foster and Michael Hicks},
  MONTH = JUL,
  YEAR = 2008,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Locksmith: Practical Static Race Detection for C</b>.
  Polyvios Pratikakis, Jeffrey&nbsp;S. Foster, and Michael Hicks, October
  2009.</font><p>
  Locksmith is a static analysis tool for automatically detecting
  data races in C programs.  In this paper, we describe each of
  Locksmith's component analyses precisely, and present systematic
  measurements that isolate interesting tradeoffs between precision
  and efficiency in each analysis.  Using a benchmark suite comprising
  standalone applications and Linux device drivers totaling more than
  200,000 lines of code, we found that a simple no-worklist strategy
  yielded the most efficient interprocedural dataflow analysis; that
  our sharing analysis was able to determine that most locations are
  thread-local, and therefore need not be protected by locks; that
  modeling C structs and void pointers precisely is key to both
  precision and efficiency; and that context-sensitivity yields a much
  more precise analysis, though with decreased scalability.  Put
  together, our results illuminate some of the key engineering
  challenges in building Locksmith and data race detection analyses
  in particular, and constraint-based program analyses in general.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/locksmith-journal-sub.pdf">.pdf</a> ]
<a name="pratikakis09locksmith"></a><pre>
@MISC{pratikakis09locksmith,
  TITLE = {Locksmith: Practical Static Race Detection for {C}},
  AUTHOR = {Polyvios Pratikakis and Jeffrey S. Foster and Michael Hicks},
  MONTH = OCT,
  YEAR = 2009,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Locksmith: Practical Static Race Detection for C</b>.
  Polyvios Pratikakis, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  <i>ACM Transactions on Programming Languages and Systems
  (TOPLAS)</i>, March 2010.
  Accepted for publication.</font><p>
  Locksmith is a static analysis tool for automatically detecting
  data races in C programs.  In this paper, we describe each of
  Locksmith's component analyses precisely, and present systematic
  measurements that isolate interesting tradeoffs between precision
  and efficiency in each analysis.  Using a benchmark suite comprising
  standalone applications and Linux device drivers totaling more than
  200,000 lines of code, we found that a simple no-worklist strategy
  yielded the most efficient interprocedural dataflow analysis; that
  our sharing analysis was able to determine that most locations are
  thread-local, and therefore need not be protected by locks; that
  modeling C structs and void pointers precisely is key to both
  precision and efficiency; and that context-sensitivity yields a much
  more precise analysis, though with decreased scalability.  Put
  together, our results illuminate some of the key engineering
  challenges in building Locksmith and data race detection analyses
  in particular, and constraint-based program analyses in general.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/locksmith-journal.pdf">.pdf</a> ]
<a name="pratikakis10locksmith"></a><pre>
@ARTICLE{pratikakis10locksmith,
  TITLE = {Locksmith: Practical Static Race Detection for {C}},
  AUTHOR = {Polyvios Pratikakis and Jeffrey S. Foster and Michael Hicks},
  JOURNAL = {{ACM} Transactions on Programming Languages and Systems (TOPLAS)},
  MONTH = MAR,
  YEAR = 2010,
  NOTE = {Accepted for publication}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69mod</em>
<font size="+1"><b>Locksmith: Practical Static Race Detection for C</b>.
  Polyvios Pratikakis, Jeffrey&nbsp;S. Foster, and Michael Hicks.
  <i>ACM Transactions on Programming Languages and Systems
  (TOPLAS)</i>, 33(1):Article 3, January 2011.</font><p>
  Locksmith is a static analysis tool for automatically detecting
  data races in C programs.  In this paper, we describe each of
  Locksmith's component analyses precisely, and present systematic
  measurements that isolate interesting tradeoffs between precision
  and efficiency in each analysis.  Using a benchmark suite comprising
  standalone applications and Linux device drivers totaling more than
  200,000 lines of code, we found that a simple no-worklist strategy
  yielded the most efficient interprocedural dataflow analysis; that
  our sharing analysis was able to determine that most locations are
  thread-local, and therefore need not be protected by locks; that
  modeling C structs and void pointers precisely is key to both
  precision and efficiency; and that context-sensitivity yields a much
  more precise analysis, though with decreased scalability.  Put
  together, our results illuminate some of the key engineering
  challenges in building Locksmith and data race detection analyses
  in particular, and constraint-based program analyses in general.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/locksmith-journal.pdf">.pdf</a> ]
<a name="pratikakis11locksmith"></a><pre>
@ARTICLE{pratikakis11locksmith,
  TITLE = {Locksmith: Practical Static Race Detection for {C}},
  AUTHOR = {Polyvios Pratikakis and Jeffrey S. Foster and Michael Hicks},
  JOURNAL = {{ACM} Transactions on Programming Languages and Systems (TOPLAS)},
  MONTH = JAN,
  YEAR = 2011,
  VOLUME = {33},
  NUMBER = 1,
  PAGES = {Article 3}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Knowledge Inference for Optimizing Secure Multi-party Computation</b>.
  Aseem Rastogi, Piotr Mardziel, Matthew Hammer, and Michael Hicks.
  In <i>Proceedings of the ACM SIGPLAN Workshop on Programming
  Languages and Analysis for Security (PLAS)</i>, June 2013.</font><p>
In secure multi-party computation, mutually distrusting parties
cooperatively compute functions of their private data; in the process,
they only learn certain results as per the protocol (e.g., the final
output).
The realization of these protocols uses cryptographic techniques to
avoid leaking information between the parties.
A protocol for a secure computation can sometimes be optimized without
changing its security guarantee:
when the parties can use their private data and the revealed output to
infer the values of other data, then this other data need not be
concealed from them via cryptography.<P>
In the context of automatically optimizing secure multi-party
computation, we define two related problems, <em>knowledge
  inference</em> and <em>constructive knowledge inference</em>.
In both problems, we attempt to automatically discover when and if
intermediate variables used in a protocol will (eventually) be known
to the parties involved in the computation.
Provably-known variables offer optimization opportunities.<P>
We formally state the problem of knowledge inference (and its
constructive variant); we describe our solutions, which are built atop
existing, standard technology such as SMT solvers.
We show that our approach is sound, and further, we
characterize the completeness properties enjoyed by our approach.
We have implemented our approach, and present a preliminary experimental evaluation.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/smc-knowledge.pdf">.pdf</a> ]
<a name="rastogi13knowledge"></a><pre>
@INPROCEEDINGS{rastogi13knowledge,
  AUTHOR = {Aseem Rastogi and Piotr Mardziel and Matthew Hammer and Michael Hicks},
  TITLE = {Knowledge Inference for Optimizing Secure Multi-party Computation},
  BOOKTITLE = {Proceedings of the {ACM SIGPLAN} Workshop on Programming Languages and Analysis for Security (PLAS)},
  MONTH = JUN,
  YEAR = 2013
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A Core Calculus for Mixed-Mode Secure Multiparty Computation</b>.
  Aseem Rastogi, Matthew&nbsp;A. Hammer, and Michael Hicks, March 2013.</font><p>
  In a Secure Multi-party Computation (SMC), mutually-distrusting
  parties cooperate to compute over their private data; parties only
  learn information that is explicitly revealed as per the agreed
  protocol.  Standard implementations of SMC, e.g., using <em>garbled
  circuits</em>, can be very slow, so researchers have begun to explore
  what we call <em>mixed-mode</em> secure computations that combine
  standard SMCs with local computations, resulting in orders of
  magnitude speedups. Ultimately, we would like to produce a compiler
  that takes ``ordinary code'' and compiles it into mixed-mode
  SMC. As a step in this direction, this paper presents a core
  calculus that aims to capture the essence of mixed-mode SMCs, and
  their compilation to realizable protocols. Our approach builds on
  Levy's call-by-push-value calculus, and permits one to specify where
  a computation occurs, which computations are done locally versus
  securely, and also which state is carried over from one secure
  computation to another.  We show that a well-typed program in core
  calculus is sound (it does not get stuck), compiles properly to a target
  protocol, and that the operational semantics of the source program
  corresponds to the operational semantics of the target protocol.  We
  show that our framework is elegant, expressive, and practical by
  showing how it elucidates several recently published optimized
  protocols, and that it naturally supports reasoning about even more
  general compositions of such protocols.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/m3pc-lang.pdf">.pdf</a> ]
<a name="rastogi13m3pc"></a><pre>
@MISC{rastogi13m3pc,
  TITLE = {A Core Calculus for Mixed-Mode Secure Multiparty Computation},
  AUTHOR = {Aseem Rastogi and Matthew A. Hammer and Michael Hicks},
  YEAR = 2013,
  MONTH = MAR,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty
  Computations</b>.
  Aseem Rastogi, Matthew&nbsp;A. Hammer, and Michael Hicks.
  In <i>Proceedings of the IEEE Symposium on Security and Privacy
  (Oakland)</i>, May 2014.</font><p>
  In a Secure Multiparty Computation (SMC), mutually distrusting
  parties use cryptographic techniques to cooperatively compute over
  their private data; in the process each party learns only explicitly
  revealed outputs. In this paper, we present Wysteria, a high-level
  programming language for writing SMCs. As with past languages, like
  Fairplay, Wysteria compiles secure computations to circuits that
  are executed by an underlying engine. Unlike past work, Wysteria
  provides support for <em>mixed-mode</em> programs, which combine
  local, private computations with synchronous SMCs. Wysteria
  complements a standard feature set with built-in support for secret
  shares and with <em>wire bundles</em>, a new abstraction that supports
  generic <EM>n</EM>-party computations.  We have formalized Wysteria, its
  refinement type system, and its operational semantics. We
  show that Wysteria programs have an easy-to-understand
  single-threaded interpretation and prove that this view corresponds
  to the actual multi-threaded semantics. We also prove type
  soundness, a property we show has security ramifications, namely
  that information about one party's data can only be revealed to
  another via (agreed upon) secure computations. We have implemented
  Wysteria, and used it to program a variety of interesting SMC
  protocols from the literature, as well as several new ones. We find
  that Wysteria's performance
  is competitive with prior approaches while making
  programming far easier, and more trustworthy.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/wysteria.pdf">.pdf</a> ]
<a name="rastogi14wysteria"></a><pre>
@INPROCEEDINGS{rastogi14wysteria,
  AUTHOR = {Aseem Rastogi and Matthew A. Hammer and Michael Hicks},
  TITLE = {Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty Computations},
  BOOKTITLE = {Proceedings of the {IEEE} Symposium on Security and Privacy (Oakland)},
  MONTH = MAY,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty
  Computations (extended version)</b>.
  Aseem Rastogi, Matthew&nbsp;A. Hammer, and Michael Hicks.
  Technical Report CS-TR-5034, Department of Computer Science, the
  University of Maryland, College Park, May 2014.</font><p>
In a Secure Multiparty Computation (SMC), mutually distrusting parties use cryptographic techniques to cooperatively compute over their private data; in the process each party learns only explicitly revealed outputs. In this paper, we present Wysteria, a high-level programming language for writing SMCs. As with past languages, like Fairplay, Wysteria compiles secure computations to circuits that are executed by an underlying engine. Unlike past work, Wysteria provides support for mixed-mode programs, which combine local, private computations with synchronous SMCs. Wysteria complements a standard feature set with built-in support for secret shares and with wire bundles, a new abstraction that supports generic n-party computations. We have formalized Wysteria, its refinement type system, and its operational semantics. We show that Wysteria programs have an easy-to-understand single-threaded interpretation and prove that this view corresponds to the actual multi-threaded semantics. We also prove type soundness, a property we show has security ramifications, namely that information about one party's data can only be revealed to another via (agreed upon) secure computations. We have implemented Wysteria, and used it to program a variety of interesting SMC protocols from the literature, as well as several new ones. We find that Wysteria's performance is competitive with prior approaches while making programming far easier, and more trustworthy.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/wysteria-tr.pdf">.pdf</a> ]
<a name="rastogi14wysteriaTR"></a><pre>
@TECHREPORT{rastogi14wysteriaTR,
  AUTHOR = {Aseem Rastogi and Matthew A. Hammer and Michael Hicks},
  TITLE = {Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty Computations (extended version)},
  INSTITUTION = {Department of Computer Science, the University of Maryland, College Park},
  NUMBER = {CS-TR-5034},
  MONTH = MAY,
  YEAR = 2014
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Wys<sup>*</sup>: A Verified Language Extension for Secure Multi-Party
  Computations</b>.
  Aseem Rastogi, Nikhil Swamy, and Michael Hicks, August 2016.</font><p>
  Secure multi-party computation (MPC) enables a set of mutually
distrusting parties to cooperatively compute, using a cryptographic
protocol, a function over their private data.
This paper presents Wys<sup>*</sup>, a new domain-specific language (DSL)
implementation for
writing MPCs. Wys<sup>*</sup> is a
<em>Verified, Domain-Specific Integrated Language Extension</em>
(VDSILE), a new kind of embedded DSL hosted in F<sup>*</sup>, a
full-featured, verification-oriented programming language.
Wys<sup>*</sup> source programs are
essentially F<sup>*</sup> programs written against an MPC library, meaning
that the programmers can use F<sup>*</sup>'s logic to verify the correctness
and security properties of their programs. To reason about the
distributed semantics of these programs, we formalize a deep
embedding of Wys<sup>*</sup>, also in F<sup>*</sup>. We mechanize the necessary
metatheory to prove that the properties verified for the Wys<sup>*</sup>
source programs carry over to the distributed, multi-party
semantics. Finally, we use F<sup>*</sup>'s extraction mechanism to
extract an interpreter that we have proved matches this semantics,
yielding a verified implementation. Indeed, Wys<sup>*</sup> is the first
DSL to enable formal verification of source MPC programs, and also the
first MPC DSL to provide a verified implementation.
With Wys<sup>*</sup> we have implemented several MPC protocols, including
private set intersection, joint median, and an MPC-based card dealing
application, and have verified their security and correctness.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/wysstar-submitted.pdf">.pdf</a> ]
<a name="rastogi16wysstar"></a><pre>
@MISC{rastogi16wysstar,
  AUTHOR = {Aseem Rastogi and Nikhil Swamy and Michael Hicks},
  TITLE = {Wys$^*$: A Verified Language Extension for Secure Multi-Party Computations},
  MONTH = AUG,
  YEAR = 2016,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Inference of Polymorphic Lock Types</b>.
  James Rose, Nikhil Swamy, and Michael Hicks.
  In <i>Proceedings of the ACM Conference on Principles of
  Distributed Computing (PODC) Workshop on Concurrency and Synchronization in
  Java Programs (CSJP)</i>, pages 18-25, July 2004.</font><p>
We present an approach for automatically proving the absence of race
conditions in multi-threaded Java programs, using a combination of
dynamic and static analysis.  The program in question is instrumented
so that when executed it will gather information about locking
relationships.  This information is then fed to our tool, FindLocks,
that generates annotations needed to type check the program using the
Race-Free Java type system.  Our approach
extends existing inference algorithms by being fully
context-sensitive.  We describe the design and implementation of our
approach, and our experience applying the tool to a variety of Java
programs.  In general, we have found the approach works well, but has
trouble scaling to large programs, which require extensive testing for
full coverage.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dynamic-locktypes.pdf">.pdf</a> ]
<a name="rose04dynamic"></a><pre>
@INPROCEEDINGS{rose04dynamic,
  AUTHOR = {James Rose and Nikhil Swamy and Michael Hicks},
  TITLE = {Dynamic Inference of Polymorphic Lock Types},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Principles of Distributed Computing (PODC) Workshop on Concurrency and Synchronization in Java Programs (CSJP)},
  PAGES = {18--25},
  MONTH = {July},
  YEAR = 2004
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Inference of Polymorphic Lock Types</b>.
  James Rose, Nikhil Swamy, and Michael Hicks.
  <i>Science of Computer Programming (SCP)</i>, 58(3):366-383, December
  2005.
  Special Issue on Concurrency and Synchronization in Java programs.
  Supercedes 2004 CSJP paper of the same name.</font><p><p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dynamic-locktypes-scp.pdf">.pdf</a> ]
<a name="rose05scp"></a><pre>
@ARTICLE{rose05scp,
  AUTHOR = {James Rose and Nikhil Swamy and Michael Hicks},
  TITLE = {Dynamic Inference of Polymorphic Lock Types},
  JOURNAL = {Science of Computer Programming (SCP)},
  VOLUME = 58,
  NUMBER = 3,
  PAGES = {366--383},
  MONTH = {December},
  YEAR = 2005,
  NOTE = {Special Issue on Concurrency and Synchronization in Java programs.  Supercedes 2004 CSJP paper of the same name.},
  PUBLISHER = {Elsevier}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Build It Break It: Measuring and Comparing Development Security</b>.
  Andrew Ruef, Michael Hicks, James Parker, Dave Levin, Atif Memon,
  Jandelyn Plane, and Piotr Mardziel.
  In <i>Proceedings of the USENIX Workshop on Cyber Security
  Instrumentation and Test (CSET)</i>, August 2015.</font><p>
There is currently little evidence about what tools, methods, processes, 
and languages lead to secure software. We present the experimental design 
of the Build it Break it secure programming contest as an aim to provide 
such evidence. The contest also provides education value to participants 
where they gain experience developing programs in an adversarial settings. 
We show preliminary results from previous runs of the contest that 
demonstrate the contest works as designed, and provides the data desired. 
We are in the process of scaling the contest to collect larger data sets 
with the goal of making statistically significant correlations between 
various factors of development and software security.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/bibifi-cset15.pdf">.pdf</a> ]
<a name="ruef15bibifi"></a><pre>
@INPROCEEDINGS{ruef15bibifi,
  TITLE = {Build It Break It: Measuring and Comparing Development Security},
  AUTHOR = {Andrew Ruef and Michael Hicks and James Parker and Dave Levin and Atif Memon and Jandelyn Plane and Piotr Mardziel},
  BOOKTITLE = {Proceedings of the USENIX Workshop on Cyber Security Instrumentation and Test (CSET)},
  MONTH = AUG,
  YEAR = 2015
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Build it, break it, fix it: Competing to build secure systems</b>.
  Andrew Ruef and Michael Hicks.
  <i>The Next Wave</i>, 21(1):19-23, 2015.</font><p> We have a long legacy of failing to build secure
                  systems; can a coding competition give us insight
                  into what we can do better? This article presents an
                  overview of the Build-it, Break-it, Fix-it
                  Security-oriented programming competition.  <p>[ <a href="https://www.nsa.gov/resources/everyone/digital-media-center/publications/the-next-wave/assets/files/TNW-21-1.pdf">.pdf</a> ]
<a name="ruef15bibifiNW"></a><pre>
@ARTICLE{ruef15bibifiNW,
  AUTHOR = {Andrew Ruef and Michael Hicks},
  JOURNAL = {The Next Wave},
  TITLE = {Build it, break it, fix it: Competing to build secure systems},
  VOLUME = 21,
  NUMBER = 1,
  PAGES = {19--23},
  YEAR = 2015,
  MON = OCT
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Build It, Break It, Fix It: Contesting Secure Development</b>.
  Andrew Ruef, Michael Hicks, James Parker, Dave Levin, Michelle&nbsp;L.
  Mazurek, and Piotr Mardziel.
  In <i>Proceedings of the ACM Conference on Computer and
  Communications Security (CCS)</i>, October 2016.</font><p>
  Typical security contests focus on breaking or mitigating the impact
  of buggy systems. We present the Build-it, Break-it, Fix-it
  (BIBIFI) contest, which aims to assess the ability to securely
  build software, not just break it. In BIBIFI, teams build specified
  software with the goal of maximizing correctness, performance, and
  security. The latter is tested when teams attempt to break other
  teams' submissions. Winners are chosen from among the best builders
  and the best breakers. BIBIFI was designed to be open-ended-teams
  can use any language, tool, process, etc.&nbsp;that they like. As such,
  contest outcomes shed light on factors that correlate with
  successfully building secure software and breaking insecure
  software. During 2015, we ran three contests involving a total of 116
  teams and two different programming problems. Quantitative analysis
  from these contests found that the most efficient build-it
  submissions used C/C++, but submissions coded in other statically-typed
  languages were less likely to have a security flaw; build-it teams
  with diverse programming-language knowledge also produced more
  secure code. Shorter programs correlated with better
  scores. Break-it teams that were also successful build-it teams were
  significantly better at finding security bugs.
  <p>[ <a href="http://arxiv.org/abs/1606.01881">http</a> ]
<a name="ruef2016bibifi"></a><pre>
@INPROCEEDINGS{ruef2016bibifi,
  AUTHOR = {Andrew Ruef and Michael Hicks and James Parker and Dave Levin and Michelle L. Mazurek and Piotr Mardziel},
  TITLE = {Build It, Break It, Fix It: Contesting Secure Development},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Computer and Communications Security (CCS)},
  OPTJOURNAL = {CoRR},
  OPTVOLUME = {abs/1606.01881},
  YEAR = {2016},
  OPTMONTH = MAY,
  MONTH = OCT
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>C-Strider: Type-Aware Heap Traversal for C</b>.
  Karla Saur, Edward&nbsp;K. Smith, Michael Hicks, and Jeffrey&nbsp;S. Foster,
  March 2013.</font><p>
  A range of C application services work by traversing
  the heap, including checkpointing systems, heap profilers, heap
  assertion checkers, and program state transformers for dynamic
  software updating. Existing implementations all reimplement heap
  traversal in an ad hoc manner.  In this paper, we present , a
  general framework for writing heap traversals such as those just
  mentioned.  takes the
  source files of a program as input and, based on the type
  information found, generates versatile, type-aware heap
  traversal code. This generated traversal can be specialized in two
  ways. First, service-writers (e.g., a developer implementing a
  serialization service) can write <em>action code</em> invoked by the
  traversal API to implement their service. Second,
  programmers can customize both the traversal and the actions of a
  service for their particular program, e.g., a programmer could
  customize a heap checker to check program-specific properties. We
  have implemented  and evaluated its utility by building several
  services-including serialization, heap checking, and dynamic
  software updating-and applied them to several real
  applications. We find that these services are both efficient and
  effective.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/cstrider.pdf">.pdf</a> ]
<a name="saur13strider"></a><pre>
@MISC{saur13strider,
  AUTHOR = {Karla Saur and  Edward K. Smith and Michael Hicks and Jeffrey S. Foster},
  TITLE = {C-Strider: Type-Aware Heap Traversal for {C}},
  MONTH = MAR,
  YEAR = 2013,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>C-Strider: Type-Aware Heap Traversal for C</b>.
  Karla Saur, Michael Hicks, and Jeffrey&nbsp;S. Foster.
  <i>Software, Practice, and Experience</i>, December 2014.
  To appear.</font><p>
  Researchers have proposed many tools and techniques that work by
  traversing the heap, including checkpointing systems, heap
  profilers, heap assertion checkers, and dynamic software updating
  systems. Yet building a heap traversal for C remains difficult, and
  to our knowledge extant services have used their own application-specific
  traversals.  This paper presents C-strider, a framework for
  writing C heap traversals and transformations.  Writing a basic C-strider
  service requires implementing only four callbacks; C-strider then
  generates a program-specific traversal that invokes the callbacks as
  each heap location is visited.  Critically, C-strider is <em>type aware</em>-it
  tracks types as it walks the heap, so every callback is supplied
  with the exact type of the associated location. We used C-strider to
  implement heap serialization, dynamic software
  updating, heap checking, and profiling,
  and then applied the resulting traversals to several
  programs.  We found C-strider requires little programmer
  effort, and the resulting services are efficient and effective.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/cstrider.pdf">.pdf</a> ]
<a name="saur14strider"></a><pre>
@ARTICLE{saur14strider,
  AUTHOR = {Karla Saur and Michael Hicks and Jeffrey S. Foster},
  TITLE = {C-Strider: Type-Aware Heap Traversal for {C}},
  JOURNAL = {Software, Practice, and Experience},
  MONTH = DEC,
  YEAR = 2014,
  NOTE = {To appear}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Boombox: A Dynamically-Updateable Network OS</b>.
  Karla Saur, Joseph Collard, Nate Foster, Arjun Guha, Laurent
  Vanbever, and Michael Hicks, March 2015.</font><p>
Like any non-trivial software system, SDNs periodically need to be updated to
fix bugs, add features, and improve performance. A strawman approach would be
to stop the controller, wipe the rules on the switches, and restart the
controller, which then repopulates the switches with appropriate rules. But
this approach loses any state maintained by the controller (and encoded in the
switch rules), and worse, may cause the SDN to behave incorrectly; e.g., for
stateful firewalls (whose policies are based in part on observed behavior), a
previously blocked hosts packets may be let through.<P>
This paper presents Boombox, a new SDN controller designed with network updates
in mind. Unlike prior approaches based on recording controller events, and
replaying them post-update to restore the controller state, Boombox allows the
programmer to update the state directly, as kept in a persistent network
information base (NIB). This approach, inspired by work on dynamic software
updates, is both flexible and efficient. We demonstrate Boombox's effectiveness
with experiments that show that existing flows' operation is only marginally
disrupted during updates to several services, include a stateful firewall, a
topology discovery engine, and a router.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/boombox-submitted.pdf">.pdf</a> ]
<a name="saur15boombox"></a><pre>
@MISC{saur15boombox,
  AUTHOR = {Karla Saur and Joseph Collard and Nate Foster and Arjun Guha and Laurent Vanbever and Michael Hicks},
  TITLE = {Boombox: A Dynamically-Updateable Network OS},
  SUBMITTED = {yes},
  YEAR = 2015,
  MONTH = MAR
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evolving NoSQL Databases Without Downtime</b>.
  Karla Saur, Tudor Dumitras, and Michael Hicks, October 2015.</font><p> 
  NoSQL
  databases like Redis, Cassandra, and MongoDB are
  increasingly popular because they are flexible, lightweight, and
  easy to work with. Applications that use these databases
  will evolve over time, sometimes necessitating (or preferring) a change
  to the format or organization of the data. The problem we address in this paper is:
  How can we support the evolution of high-availability applications
  and their NoSQL data <em>online</em>, without excessive delays or
  interruptions, even in the presence of backward-incompatible
  data format changes?<P>
We present KVolve, an extension to the popular Redis NoSQL database, as a
  solution to this problem. KVolve permits a developer to
  submit an upgrade specification that defines how to
  transform existing data to the newest version. This transformation
  is applied <em>lazily</em> as applications interact with the
  database, thus avoiding long pause times. We demonstrate that KVolve is
  expressive enough to support substantial practical updates,
  including format changes to RedisFS, a Redis-backed file system,
  while imposing essentially no overhead in general use and minimal
  pause times during updates.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/kvolve-submitted.pdf">.pdf</a> ]
<a name="saur15kvolve"></a><pre>
@MISC{saur15kvolve,
  TITLE = {Evolving NoSQL Databases Without Downtime},
  AUTHOR = {Karla Saur and Tudor Dumitra\c{s} and Michael Hicks},
  MONTH = OCT,
  YEAR = 2015,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Safe and Flexible Controller Upgrades for SDNs</b>.
  Karla Saur, Joseph Collard, Nate Foster, Arjun Guha, Laurent
  Vanbever, and Michael Hicks.
  In <i>Proceedings of the Symposium on SDN Research (SOSR)</i>, March
  2016.</font><p>
    SDN controllers must be periodically upgraded to add features,
  improve performance, and fix bugs, but current techniques for
  implementing <em>dynamic updates</em>-i.e., without disrupting
  ongoing network functions-are inadequate. Simply halting the old
  controller and bringing up the new one can cause state to be lost,
  leading to incorrect behavior. For example, if the state represents
  flows blacklisted by a firewall, then traffic that should be blocked
  may be allowed to pass through. Techniques based on record and
  replay can reconstruct controller state automatically, but they are
  expensive to deploy and do not work in all scenarios.<P>
  This paper presents a new approach to implementing dynamic updates
  for SDN controllers. We present the design and implementation of a
  new controller platform called Morpheus that uses <em>explicit state
  transfer</em> to implement dynamic updates. Morpheus enables programmers to
  directly initialize the upgraded controller's state as a function of
  its existing state, using a domain-specific language that is
  designed to be easy to use. Morpheus also offers a distributed protocol
  for safely deploying updates across multiple nodes. Experiments
  confirm that Morpheus provides correct behavior and good performance.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/sdnupdate.pdf">.pdf</a> ]
<a name="saur15morpheus"></a><pre>
@INPROCEEDINGS{saur15morpheus,
  AUTHOR = {Karla Saur and Joseph Collard and Nate Foster and Arjun Guha and Laurent Vanbever and Michael Hicks},
  TITLE = {Safe and Flexible Controller Upgrades for {SDNs}},
  BOOKTITLE = {Proceedings of the Symposium on SDN Research (SOSR)},
  YEAR = 2016,
  MONTH = MAR
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>C-Strider: Type-Aware Heap Traversal for C</b>.
  Karla Saur, Michael Hicks, and Jeffrey&nbsp;S. Foster.
  <i>Software, Practice, and Experience</i>, May 2015.</font><p>
  Researchers have proposed many tools and techniques that work by
  traversing the heap, including checkpointing systems, heap
  profilers, heap assertion checkers, and dynamic software updating
  systems. Yet building a heap traversal for C remains difficult, and
  to our knowledge extant services have used their own application-specific
  traversals.  This paper presents C-strider, a framework for
  writing C heap traversals and transformations.  Writing a basic C-strider
  service requires implementing only four callbacks; C-strider then
  generates a program-specific traversal that invokes the callbacks as
  each heap location is visited.  Critically, C-strider is <em>type aware</em>-it
  tracks types as it walks the heap, so every callback is supplied
  with the exact type of the associated location. We used C-strider to
  implement heap serialization, dynamic software
  updating, heap checking, and profiling,
  and then applied the resulting traversals to several
  programs.  We found C-strider requires little programmer
  effort, and the resulting services are efficient and effective.
<p>[ <a href="http://dx.doi.org/10.1002/spe.2332">http</a> ]
<a name="saur15strider"></a><pre>
@ARTICLE{saur15strider,
  AUTHOR = {Karla Saur and Michael Hicks and Jeffrey S. Foster},
  TITLE = {C-Strider: Type-Aware Heap Traversal for {C}},
  JOURNAL = {Software, Practice, and Experience},
  MONTH = MAY,
  YEAR = 2015,
  ISSN = {1097-024X},
  DOI = {10.1002/spe.2332},
  OPTURL = {<a href="http://www.cs.umd.edu/~mwh/papers/cstrider.pdf">http://www.cs.umd.edu/~mwh/papers/cstrider.pdf</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evolving NoSQL Databases Without Downtime</b>.
  Karla Saur, Tudor Dumitras, and Michael Hicks.
  In <i>Proceedings of the International Conference on Software
  Maintenance and Evolution (ICSME)</i>, October 2016.</font><p> 
  NoSQL
  databases like Redis, Cassandra, and MongoDB are
  increasingly popular because they are flexible, lightweight, and
  easy to work with. Applications that use these databases
  will evolve over time, sometimes necessitating (or preferring) a change
  to the format or organization of the data. The problem we address in this paper is:
  How can we support the evolution of high-availability applications
  and their NoSQL data <em>online</em>, without excessive delays or
  interruptions, even in the presence of backward-incompatible
  data format changes?<P>
We present KVolve, an extension to the popular Redis NoSQL database, as a
  solution to this problem. KVolve permits a developer to
  submit an upgrade specification that defines how to
  transform existing data to the newest version. This transformation
  is applied <em>lazily</em> as applications interact with the
  database, thus avoiding long pause times. We demonstrate that KVolve is
  expressive enough to support substantial practical updates,
  including format changes to RedisFS, a Redis-backed file system,
  while imposing essentially no overhead in general use and minimal
  pause times during updates.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/kvolve.pdf">.pdf</a> ]
<a name="saur16kvolve"></a><pre>
@INPROCEEDINGS{saur16kvolve,
  TITLE = {Evolving {NoSQL} Databases Without Downtime},
  BOOKTITLE = {Proceedings of the International Conference on Software Maintenance and Evolution (ICSME)},
  AUTHOR = {Karla Saur and Tudor Dumitra\c{s} and Michael Hicks},
  MONTH = OCT,
  YEAR = 2016
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Towards Standardized Benchmarks for Dynamic Software Updating Systems</b>.
  Edward&nbsp;K. Smith, Michael Hicks, and Jeffrey&nbsp;S. Foster.
  In <i>Proceedings of the Workshop on Hot Topics in Software
  Upgrades (HotSWUp)</i>, pages 11-15, June 2012.</font><p>
  Dynamic Software Updating (DSU) has been an active topic of research
  for at least the last 30 years. However, despite many recent
  advances, DSU has yet to see widespread adoption and deployment in
  practice. In this paper, we review a slice of the history of DSU
  research to study how DSU for C has evolved over the last two
  decades. We examine the ways DSU systems are
  evaluated in the research literature. We identify several
  shortcomings of the evaluation criteria that have been used, and
  propose key improvements. We believe that using better evaluation
  criteria can guide DSU research to produce systems that will
  be more practical, flexible, and usable.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/dsubench.pdf">.pdf</a> ]
<a name="smith12benchmark"></a><pre>
@INPROCEEDINGS{smith12benchmark,
  TITLE = {Towards Standardized Benchmarks for Dynamic Software Updating Systems},
  AUTHOR = {Edward K. Smith and Michael Hicks and Jeffrey S. Foster},
  BOOKTITLE = {Proceedings of the Workshop on Hot Topics in Software Upgrades (HotSWUp)},
  MONTH = JUN,
  YEAR = 2012,
  PAGES = {11--15}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Defining and Enforcing C's Module System</b>.
  Saurabh Srivastava, Michael Hicks, Jeffrey&nbsp;S. Foster, and Bhargav
  Kanagal.
  Technical Report CS-4816, Department of Computer Science, University
  of Maryland, July 2006.</font><p>
  Programming language module systems are an important tool for
  managing the complexity of large software systems.  The C
  programming language is used to build many such systems, yet it
  lacks a proper module system.  Instead, C programmers typically
  follow a convention that treats <tt>.h</tt> header files as
  interfaces and <tt>.c</tt> source files as modules.  This
  convention can be effective, but there are many subtleties in using
  it correctly, and the compiler and linker provide no enforcement
  mechanism.  As a result, misuse of the convention can lead to
  hard-to-find bugs, can make reasoning about code in isolation more
  difficult, and can complicate future code maintenance.<P>
  This paper presents CMod, a module system for C that ensures
  abstraction via information hiding and type-safe separate compilation.  Our
  approach is to identify and enforce the circumstances under
  which C's current modular programming convention is sound.  The result is
  four rules that, using an operational semantics for an
  idealized preprocessor, we have proven are sufficient to guarantee
  the desired modularity properties.  We have implemented CMod for the
  full C language and applied it to a number of benchmarks.  We found
  that most of the time legacy programs obey CMod's rules, or can be
  made to with minimal effort, and rule violations often result in
  type errors or brittle code.  Thus CMod brings the benefits of
  modular programming to C while still supporting
  legacy systems.
<p>[ <a href="http://www.cs.umd.edu/~saurabhs/CMod/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/cmod-tr.pdf">.pdf</a> ]
<a name="srivastava06cmodtr"></a><pre>
@TECHREPORT{srivastava06cmodtr,
  TITLE = {Defining and Enforcing {C}'s Module System},
  AUTHOR = {Saurabh Srivastava and Michael Hicks and Jeffrey S. Foster and Bhargav Kanagal},
  INSTITUTION = {Department of Computer Science, University of Maryland},
  NUMBER = {CS-4816},
  MONTH = {July},
  YEAR = 2006,
  HTTP = {<a href="http://www.cs.umd.edu/~saurabhs/CMod/">http://www.cs.umd.edu/~saurabhs/CMod/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Modular Information Hiding and Type Safety for C</b>.
  Saurabh Srivastava, Michael Hicks, and Jeffrey&nbsp;S. Foster.
  In <i>Proceedings of the ACM Workshop on Types in Language Design
  and Implementation (TLDI)</i>, pages 3-14, January 2007.</font><p>
  This paper presents CMod, a novel tool that provides a sound
  module system for C.  CMod works by enforcing a set of four rules
  that are based on principles of modular reasoning and on current
  programming practice.  CMod's rules flesh out the convention that
  <tt>.h</tt> header files are module interfaces and <tt>.c</tt>
  source files are module implementations.  Although this convention
  is well-known, developing CMod's rules revealed there are many
  subtleties in applying the basic pattern correctly.  We have proven
  formally that CMod's rules enforce both information hiding and
  type-safe linking.
  We evaluated CMod on a number of benchmarks, and found
  that most programs obey CMod's rules, or can be made to with
  minimal effort, while rule violations reveal brittle coding practices
  including numerous information hiding violations and occasional type errors.
<p>[ <a href="http://www.cs.umd.edu/~saurabhs/CMod/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/cmod.pdf">.pdf</a> ]
<a name="srivastava07cmod"></a><pre>
@INPROCEEDINGS{srivastava07cmod,
  TITLE = {Modular Information Hiding and Type Safety for {C}},
  AUTHOR = {Saurabh Srivastava and Michael Hicks and Jeffrey S. Foster},
  BOOKTITLE = {Proceedings of the {ACM} Workshop on Types in Language Design and Implementation (TLDI)},
  PAGES = {3--14},
  MONTH = {January},
  YEAR = 2007,
  HTTP = {<a href="http://www.cs.umd.edu/~saurabhs/CMod/">http://www.cs.umd.edu/~saurabhs/CMod/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Modular Information Hiding and Type Safe Linking for C</b>.
  Saurabh Srivastava, Michael Hicks, Jeffrey&nbsp;S. Foster, and Patrick
  Jenkins, June 2007.
  Submitted to IEEE Transactions on Software Engineering. Full version
  of TLDI 07 paper.</font><p>
  This paper presents CMod, a novel tool that provides a sound
  module system for C.  CMod works by enforcing a set of four
  rules that are based on principles of modular reasoning and on
  current programming practice.  CMod's rules flesh out the
  convention that <tt>.h</tt> header files are module interfaces and
  <tt>.c</tt> source files are module implementations.  Although this
  convention is well-known, existing explanations of it are
  incomplete, omitting important subtleties needed for soundness.  In
  contrast, we have proven formally that CMod's rules enforce both
  information hiding and type-safe linking.<P>
  To use CMod, the programmer develops and builds their software as
  usual, redirecting the compiler and linker to CMod's wrappers.  We
  evaluated CMod by applying it to 30 open source
  programs, totaling more than one million lines of code.  Violations to
  CMod's rules revealed more than a thousand information hiding errors,
  dozens of typing errors, and hundreds of cases that, although  not
  currently bugs, make programming mistakes more likely as the code
  evolves.  At the same time, programs generally adhere
  to the assumptions underlying CMod's rules, and so we could fix rule violations
  with a modest effort.  We conclude that CMod can effectively support
  modular programming in C: it soundly enforces type-safe linking and
  information hiding while being largely compatible with existing practice.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/cmod-journal.pdf">.pdf</a> ]
<a name="srivastava07cmodjournal"></a><pre>
@MISC{srivastava07cmodjournal,
  AUTHOR = {Saurabh Srivastava and Michael Hicks and Jeffrey S. Foster and Patrick Jenkins},
  TITLE = {Modular Information Hiding and Type Safe Linking for {C}},
  NOTE = {Submitted to IEEE Transactions on Software Engineering.  Full version of {TLDI} 07 paper},
  MONTH = JUN,
  YEAR = 2007
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Appendix to CMod: Modular Information Hiding and Type-Safe Linking for
  C</b>.
  Saurabh Srivastava, Michael Hicks, and Jeffrey&nbsp;S. Foster.
  Technical Report CS-TR-4874, Department of Computer Science,
  University of Maryland, June 2007.</font><p>
This brief note is an appendix to <em>CMod: Modular
  Information Hiding and Type-Safe Linking for C</em> (Srivastava et al., June 2007).
It consists of the proof of soundness for the formal language presented in that paper.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/appendix-proof.pdf">.pdf</a> ]
<a name="srivastava07cmodjournaltr"></a><pre>
@TECHREPORT{srivastava07cmodjournaltr,
  AUTHOR = {Saurabh Srivastava and Michael Hicks and Jeffrey S. Foster},
  TITLE = {Appendix to {CMod}: Modular Information Hiding and Type-Safe Linking for {C}},
  INSTITUTION = {Department of Computer Science, University of Maryland},
  MONTH = JUN,
  YEAR = 2007,
  NUMBER = {CS-TR-4874}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Modular Information Hiding and Type Safe Linking for C</b>.
  Saurabh Srivastava, Michael Hicks, Jeffrey&nbsp;S. Foster, and Patrick
  Jenkins.
  <i>IEEE Transactions on Software Engineering</i>, 34(3):1-20, May
  2008.
  Full version of TLDI 07 paper.</font><p>
  This paper presents CMod, a novel tool that provides a sound
  module system for C.  CMod works by enforcing a set of four
  rules that are based on principles of modular reasoning and on
  current programming practice.  CMod's rules flesh out the
  convention that <tt>.h</tt> header files are module interfaces and
  <tt>.c</tt> source files are module implementations.  Although this
  convention is well-known, existing explanations of it are
  incomplete, omitting important subtleties needed for soundness.  In
  contrast, we have proven formally that CMod's rules enforce both
  information hiding and type-safe linking.<P>
  To use CMod, the programmer develops and builds their software as
  usual, redirecting the compiler and linker to CMod's wrappers.  We
  evaluated CMod by applying it to 30 open source
  programs, totaling more than one million lines of code.  Violations to
  CMod's rules revealed more than a thousand information hiding errors,
  dozens of typing errors, and hundreds of cases that, although  not
  currently bugs, make programming mistakes more likely as the code
  evolves.  At the same time, programs generally adhere
  to the assumptions underlying CMod's rules, and so we could fix rule violations
  with a modest effort.  We conclude that CMod can effectively support
  modular programming in C: it soundly enforces type-safe linking and
  information hiding while being largely compatible with existing practice.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/cmod-journal.pdf">.pdf</a> ]
<a name="srivastava08cmodjournal"></a><pre>
@ARTICLE{srivastava08cmodjournal,
  AUTHOR = {Saurabh Srivastava and Michael Hicks and Jeffrey S. Foster and Patrick Jenkins},
  TITLE = {Modular Information Hiding and Type Safe Linking for {C}},
  JOURNAL = {IEEE Transactions on Software Engineering},
  VOLUME = 34,
  NUMBER = 3,
  NOTE = {Full version of {TLDI} 07 paper},
  MONTH = MAY,
  YEAR = 2008,
  PAGES = {1--20}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Deanonymizing Mobility Traces: Using a Social Network as a Side-Channel</b>.
  Mudhakar Srivatsa and Michael Hicks.
  In <i>Proceedings of the ACM Conference on Computer and
  Communications Security (CCS)</i>, October 2012.</font><p>
  Location-based services, which employ data from
  smartphones, vehicles, etc., are growing in popularity.  
  To reduce the threat that shared location data poses to a user's
  privacy, some services anonymize or obfuscate this data.
  In this paper, we show these methods can be effectively defeated: a
  set of location traces can be deanonymized given an easily
  obtained social network graph.
  The key idea of our approach is that a user may be identified by those she
  meets: a <em>contact graph</em> identifying meetings between
  anonymized users in a set of traces can be structurally correlated
  with a social network graph, thereby identifying anonymized
  users. We demonstrate the effectiveness of our approach using three
  real world datasets: University of St Andrews mobility trace and
  social network (27 nodes each), SmallBlue contact trace and Facebook
  social network (125 nodes), and Infocom 2006 bluetooth contact
  traces and conference attendees' DBLP social network (78 nodes). Our
  experiments show that 80% of users are identified
  precisely, while only 8% are identified incorrectly, with the
  remainder mapped to a small set of users.    
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/GraphInfoFlow.CCS2012.pdf">.pdf</a> ]
<a name="srivatsa12mobility"></a><pre>
@INPROCEEDINGS{srivatsa12mobility,
  AUTHOR = {Mudhakar Srivatsa and Michael Hicks},
  TITLE = {Deanonymizing Mobility Traces: Using a Social Network as a Side-Channel},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Computer and Communications Security (CCS)},
  MONTH = OCT,
  YEAR = 2012
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Software Updates for Java: A VM-Centric Approach</b>.
  Suriya Subramanian, Michael Hicks, and Kathryn&nbsp;S. McKinley, May 2008.</font><p>
Software evolves to fix bugs and add features, but stopping and
restarting existing programs to take advantage of these changes can be
inconvenient and costly.  Dynamic software updating (DSU) addresses
these problems by updating programs while they run.  The challenge is
to develop DSU infrastructure that is flexible, safe, and
efficient-DSU should enable updates that are likely to occur in
practice, and updated programs should be as reliable and as efficient
as those started from scratch.
  
This paper presents the design and implementation of a JVM we call
Jvolve that is enhanced with DSU support.  The paper's key insight is
that flexible, safe, and efficient DSU can be supported by naturally
extending existing VM services.  By piggybacking on classloading and
garbage collection, Jvolve can flexibly support additions and
replacements of fields and methods anywhere within the class
hierarchy, and in a manner that may alter class signatures.  By
utilizing bytecode verification and thread synchronization support,
Jvolve can ensure that an applied update will never violate type
safety.  Finally, by employing JIT compilation, all DSU-related
overhead before or after an update can be effectively eliminated.
Using Jvolve, we successfully applied dynamic continuous updates
corresponding to 20 of the 22 releases that occurred over nearly two
years' time, one update per release, for three open-source programs,
Jetty web server, JavaEmailServer, and CrossFTP server.  Our results
indicate that the VM is well-suited to support practical DSU services.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/jvolve.pdf">.pdf</a> ]
<a name="subramanian08jvolve"></a><pre>
@MISC{subramanian08jvolve,
  AUTHOR = {Suriya Subramanian and Michael Hicks and Kathryn S. McKinley},
  TITLE = {Dynamic Software Updates for {Java}: A {VM}-Centric Approach},
  MONTH = MAY,
  YEAR = 2008
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Dynamic Software Updates: A VM-Centric Approach</b>.
  Suriya Subramanian, Michael Hicks, and Kathryn&nbsp;S. McKinley.
  In <i>Proceedings of the ACM Conference on Programming Language
  Design and Implementation (PLDI)</i>, pages 1-12, June 2009.</font><p>
Software evolves to fix bugs and add features. Stopping and restarting
programs to apply changes is inconvenient and often costly.  Dynamic
software updating (DSU) addresses this problem by updating programs while
they execute, but existing DSU systems for managed languages do not support
many updates that occur in practice and are inefficient.  This paper
presents the design and implementation of Jvolve, a DSU-enhanced Java VM.
Updated programs may add, delete, and replace fields and methods anywhere
within the class hierarchy. Jvolve implements these updates by adding to
and coordinating VM classloading, just-in-time compilation, scheduling,
return barriers, on-stack replacement, and garbage collection. Jvolve is
safe: its use of bytecode verification and VM thread synchronization
ensures that an update will always produce type-correct executions. Jvolve
is flexible: it can support 20 of 22 updates to three open-source
programs-Jetty web server, JavaEmailServer, and CrossFTP server-based
on actual releases occurring over 1 to 2 years.  Jvolve is efficient:
performance experiments show that incurs no overhead during steady-state
execution.  These results demonstrate that this work is a significant step
towards practical support for dynamic updates in virtual machines for
managed languages.<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/jvolve.pdf">.pdf</a> ]
<a name="subramanian09jvolve"></a><pre>
@INPROCEEDINGS{subramanian09jvolve,
  AUTHOR = {Suriya Subramanian and Michael Hicks and Kathryn S. McKinley},
  TITLE = {Dynamic Software Updates: A {VM}-Centric Approach},
  BOOKTITLE = {Proceedings of the {ACM} Conference on Programming Language Design and Implementation (PLDI)},
  MONTH = JUN,
  YEAR = 2009,
  PAGES = {1--12}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Safe Manual Memory Management in Cyclone</b>.
  Nikhil Swamy, Michael Hicks, Greg Morrisett, Dan Grossman, and Trevor
  Jim.
  <i>Science of Computer Programming (SCP)</i>, 62(2):122-144, October
  2006.
  Special issue on memory management. Expands ISMM conference paper of
  the same name.</font><p>
  The goal of the Cyclone project is to investigate how to make a
  low-level C-like language safe.  Our most difficult challenge has
  been providing programmers control over memory management while
  retaining safety.  This paper describes our experience trying
  to integrate and use effectively two previously-proposed, safe
  memory-management mechanisms: statically-scoped regions and tracked
  pointers.  We found that these typing mechanisms can be combined to
  build alternative memory-management abstractions, such as reference
  counted objects and arenas with dynamic lifetimes, and thus provide
  a flexible basis.  Our experience-porting C programs and device
  drivers, and building new applications for resource-constrained
  systems-confirms that experts can use these features to improve
  memory footprint and sometimes to improve throughput when used
  instead of, or in combination with, conservative garbage collection.
  <p>[ <a href="http://cyclone.thelanguage.org">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/cyc-mm-scp.pdf">.pdf</a> ]
<a name="swamy05experience"></a><pre>
@ARTICLE{swamy05experience,
  AUTHOR = {Nikhil Swamy and Michael Hicks and Greg Morrisett and Dan Grossman and Trevor Jim},
  TITLE = {Safe Manual Memory Management in {Cyclone}},
  JOURNAL = {Science of Computer Programming (SCP)},
  VOLUME = 62,
  NUMBER = 2,
  MONTH = OCT,
  PAGES = {122--144},
  YEAR = 2006,
  NOTE = {Special issue on memory management. Expands ISMM conference paper of the same name},
  PUBLISHER = {Elsevier},
  HTTP = {<a href="http://cyclone.thelanguage.org">http://cyclone.thelanguage.org</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Managing Policy Updates in Security-Typed Languages</b>.
  Nikhil Swamy, Michael Hicks, Stephen Tse, and Steve Zdancewic.
  In <i>Proceedings of the Computer Security Foundations Workshop
  (CSFW)</i>, pages 202-216, July 2006.</font><p>
This paper presents RX, a new security-typed
programming language with features intended to make the management of
information-flow policies more practical.  Security labels in RX,
in contrast to prior approaches, are defined in terms of <em>owned
roles</em>, as found in the RT role-based trust-management framework.
Role-based security policies allows flexible delegation, and our
language RX provides constructs through which programs can robustly
update policies and react to policy updates dynamically.  Our dynamic
semantics use statically verified <em>transactions</em> to eliminate
illegal information flows across updates, which we call
<em>transitive flow</em>.  Because policy updates can be observed
through dynamic queries, policy updates can potentially reveal
sensitive information.  As such, RX considers policy statements
themselves to be potentially confidential information and subject to
information-flow <em>metapolicies</em>.
<p>[ <a href="http://www.cs.umd.edu/projects/PL/rx/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/rx.pdf">.pdf</a> ]
<a name="swamy06rx"></a><pre>
@INPROCEEDINGS{swamy06rx,
  TITLE = {Managing Policy Updates in Security-Typed Languages},
  AUTHOR = {Nikhil Swamy and Michael Hicks and Stephen Tse and Steve Zdancewic},
  BOOKTITLE = {Proceedings of the Computer Security Foundations Workshop (CSFW)},
  MONTH = {July},
  PAGES = {202--216},
  YEAR = 2006,
  HTTP = {<a href="http://www.cs.umd.edu/projects/PL/rx/">http://www.cs.umd.edu/projects/PL/rx/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Managing Policy Updates in Security-Typed Languages (Extended version)</b>.
  Nikhil Swamy, Michael Hicks, Stephen Tse, and Steve Zdancewic.
  Technical Report CS-TR-4793, Department of Computer Science,
  University of Maryland, August 2006.
  Extends CSFW version to include full proofs and additional discussion
  about metapolicies.</font><p>
This paper presents RX, a new security-typed
programming language with features intended to make the management of
information-flow policies more practical.  Security labels in RX,
in contrast to prior approaches, are defined in terms of <em>owned
roles</em>, as found in the RT role-based trust-management framework.
Role-based security policies allows flexible delegation, and our
language RX provides constructs through which programs can robustly
update policies and react to policy updates dynamically.  Our dynamic
semantics use statically verified <em>transactions</em> to eliminate
illegal information flows across updates, which we call
<em>transitive flow</em>.  Because policy updates can be observed
through dynamic queries, policy updates can potentially reveal
sensitive information.  As such, RX considers policy statements
themselves to be potentially confidential information and subject to
information-flow <em>metapolicies</em>.
<p>[ <a href="http://www.cs.umd.edu/projects/PL/rx/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/rx-tr.pdf">.pdf</a> ]
<a name="swamy06rxtr"></a><pre>
@TECHREPORT{swamy06rxtr,
  TITLE = {Managing Policy Updates in Security-Typed Languages (Extended version)},
  AUTHOR = {Nikhil Swamy and Michael Hicks and Stephen Tse and Steve Zdancewic},
  INSTITUTION = {Department of Computer Science, University of Maryland},
  NUMBER = {CS-TR-4793},
  MONTH = {August},
  YEAR = 2006,
  NOTE = {Extends CSFW version to include full proofs and additional
discussion about metapolicies},
  HTTP = {<a href="http://www.cs.umd.edu/projects/PL/rx/">http://www.cs.umd.edu/projects/PL/rx/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Fable: A Language for Enforcing User-defined Security Policies</b>.
  Nikhil Swamy and Michael Hicks, July 2007.</font><p>
An increasing number of applications have need to enforce some kind of
security policy.  A variety of language-based techniques have been proposed
toward assuring that particular sorts of security policy are properly
enforced.  However, these approaches typically fix the style of security
policy and overall security goal, e.g., information flow policies with a
goal of noninterference.  This limits the programmer's ability to combine
policy styles and to apply customized enforcement techniques while still
being assured the system is secure.<P>
As a step to addressing this problem, this paper presents Fable, a core
formalism for a programming language in which programmers may specify 
security policies and reason that these policies are properly
enforced.  In Fable, security policies are expressed by associating
<em>security labels</em> with the data or actions they protect via dependent
types.  Programmers define the semantics of labels in a separate part of the
program called the <em>enforcement policy</em>.  Labeled terms may only be
constructed and destructed within the enforcement policy, ensuring that it
cannot be circumvented.  Fable uses substructural types to track effects
in labels so that a policy whose enforcement must consider effects (e.g.,
due to references) or is itself effectful (e.g., a reference monitor) is
still assured of complete mediation.  Fable is flexible enough to
implement a wide variety of security policies.  As examples, we show how
Fable can be used to express policies for access control, information flow
(which we prove enforces noninterference), trusted declassification,
and security automata.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/fable.pdf">.pdf</a> ]
<a name="swamy07fable"></a><pre>
@MISC{swamy07fable,
  AUTHOR = {Nikhil Swamy and Michael Hicks},
  TITLE = {Fable: A Language for Enforcing User-defined Security Policies},
  MONTH = JUL,
  YEAR = 2007
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Fable: A Language for Enforcing User-defined Security Policies</b>.
  Nikhil Swamy, Brian&nbsp;J. Corcoran, and Michael Hicks.
  Technical Report CS-TR-4895, University of Maryland, Department of
  Computer Science, November 2007.
  Full version of Oakland 08 paper.</font><p>
This paper presents Fable, a core formalism for a programming language
in which programmers may specify security policies and reason that
these policies are properly enforced. In Fable,
security policies can be expressed by associating <em>security
labels</em> with the data or actions they protect. Programmers define the
semantics of labels in a separate part of the program called the
<em>enforcement policy</em>. Fable prevents a policy from being circumvented
by allowing labeled terms to be manipulated only within the enforcement
policy; application code must treat labeled values abstractly.
Together, these features
facilitate straightforward proofs that programs implementing a
particular policy achieve their high-level security goals.  Fable is
flexible enough to implement a wide variety of security policies,
including access control, information flow, provenance, and security
automata. We have implemented Fable as part of the Links web
programming language; we call the resulting language SELinks.  We
report on our experience using SElinks to build two substantial
applications, a wiki and an on-line store, equipped with a combination of
access control and provenance policies.
 To our knowledge, no existing framework enables
the enforcement of such a wide variety of security policies with an
equally high level of assurance.
        <p>[ <a href="http://www.cs.umd.edu/~nswamy/papers/fable-tr.pdf">.pdf</a> ]
<a name="swamy07fableTR"></a><pre>
@TECHREPORT{swamy07fableTR,
  AUTHOR = {Nikhil Swamy and Brian J. Corcoran and Michael Hicks},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  NUMBER = {CS-TR-4895},
  TITLE = {Fable: A Language for Enforcing User-defined Security Policies},
  YEAR = 2007,
  MONTH = NOV,
  NOTE = {Full version of Oakland 08 paper}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Verified Enforcement of Security Policies for Cross-Domain Information
  Flows</b>.
  Nikhil Swamy, Michael Hicks, and Simon Tsang.
  In <i>Proceedings of the 2007 Military Communications Conference
  (MILCOM)</i>, October 2007.</font><p>
We describe work in progress that uses program analysis to show that
security-critical programs, such as cross-domain guards, correctly
enforce cross-domain security policies.
We are enhancing existing techniques from the field of
security-oriented programming languages to construct a new language
for the construction of secure networked applications, <em>SELinks</em>.
In order to specify and enforce expressive and fine-grained policies,
we advocate dynamically associating security labels with sensitive
entities.
Programs written in <em>SELinks</em> are statically guaranteed to
correctly manipulate an entity's security labels and to ensure that
the appropriate policy checks mediate all operations that are
performed on the entity.
We discuss the design of our main case study: a web-based
collaborative planning application that will permit a collection
of users, with varying security requirements and clearances, to access
sensitive data sources and collaboratively create documents based on
these sources.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/selinks-cpa.pdf">.pdf</a> ]
<a name="swamy07milcom"></a><pre>
@INPROCEEDINGS{swamy07milcom,
  AUTHOR = {Nikhil Swamy and Michael Hicks and Simon Tsang},
  TITLE = {Verified Enforcement of Security Policies for Cross-Domain
Information Flows},
  MONTH = OCT,
  YEAR = 2007,
  BOOKTITLE = {Proceedings of the 2007 Military Communications Conference (MILCOM)}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Verified Enforcement of Stateful Information Release Policies</b>.
  Nikhil Swamy and Michael Hicks.
  In <i>Proceedings of the ACM SIGPLAN Workshop on Programming
  Languages and Analysis for Security (PLAS)</i>, pages 21-32, June 2008.</font><p>
  Many organizations specify <em>information release</em> policies to
  describe the terms under which sensitive information may be released
  to other organizations.  This paper presents a new approach for
  ensuring that security-critical software correctly enforces its
  information release policy.  Our approach has two parts.  First, an
  information release policy is specified as a security automaton
  written in a new language called AIR.  Second, we enforce an AIR
  policy by translating it into an API for programs written in Lair,
  a core formalism for a functional programming language. Lair uses
  a novel combination of dependent, affine, and singleton types to
  ensure that the API is used correctly. As a consequence we can
  certify that programs written in Lair meet the requirements of
  the original AIR policy specification.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/air.pdf">.pdf</a> ]
<a name="swamy08air"></a><pre>
@INPROCEEDINGS{swamy08air,
  AUTHOR = {Nikhil Swamy and Michael Hicks},
  TITLE = {Verified Enforcement of Stateful Information Release Policies},
  BOOKTITLE = {Proceedings of the {ACM SIGPLAN} Workshop on Programming Languages and Analysis for Security (PLAS)},
  MONTH = JUN,
  YEAR = 2008,
  PAGES = {21--32}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Verified Enforcement of Automaton-based Information Release Policies</b>.
  Nikhil Swamy and Michael Hicks.
  Technical Report CS-TR-4906, University of Maryland, Department of
  Computer Science, 2008.
  Full version of PLAS 08 paper.</font><p>
  Many organizations specify <em>information release</em> policies to
  describe the terms under which sensitive information may be released
  to other organizations.  This paper presents a new approach for
  ensuring that security-critical software correctly enforces its
  information release policy.  Our approach has two parts.  First, an
  information release policy is specified as a security automaton
  written in a new language called AIR.  Second, we enforce an AIR
  policy by translating it into an API for programs written in Lair,
  a core formalism for a functional programming language. Lair uses
  a novel combination of dependent, affine, and singleton types to
  ensure that the API is used correctly. As a consequence we can
  certify that programs written in Lair meet the requirements of
  the original AIR policy specification.
  <p>[ <a href="http://www.cs.umd.edu/~nswamy/papers/lair-tr.pdf">.pdf</a> ]
<a name="swamy08airTR"></a><pre>
@TECHREPORT{swamy08airTR,
  AUTHOR = {Nikhil Swamy and Michael Hicks},
  INSTITUTION = {University of Maryland, Department of Computer Science},
  NUMBER = {CS-TR-4906},
  TITLE = {Verified Enforcement of Automaton-based Information Release Policies},
  MON = JUN,
  YEAR = 2008,
  NOTE = {Full version of PLAS 08 paper}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Fable: A Language for Enforcing User-defined Security Policies</b>.
  Nikhil Swamy, Brian Corcoran, and Michael Hicks.
  In <i>Proceedings of the IEEE Symposium on Security and Privacy
  (Oakland)</i>, pages 369-383, May 2008.</font><p>
This paper presents Fable, a core formalism for a programming language
in which programmers may specify security policies and reason that
these policies are properly enforced. In Fable,
security policies can be expressed by associating <em>security
labels</em> with the data or actions they protect. Programmers define the
semantics of labels in a separate part of the program called the
<em>enforcement policy</em>. Fable prevents a policy from being circumvented
by allowing labeled terms to be manipulated only within the enforcement
policy; application code must treat labeled values abstractly.
Together, these features
facilitate straightforward proofs that programs implementing a
particular policy achieve their high-level security goals.  Fable is
flexible enough to implement a wide variety of security policies,
including access control, information flow, provenance, and security
automata. We have implemented Fable as part of the Links web
programming language; we call the resulting language SELinks.  We
report on our experience using SElinks to build two substantial
applications, a wiki and an on-line store, equipped with a combination of
access control and provenance policies.
 To our knowledge, no existing framework enables
the enforcement of such a wide variety of security policies with an
equally high level of assurance.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/fable.pdf">.pdf</a> ]
<a name="swamy08fable"></a><pre>
@INPROCEEDINGS{swamy08fable,
  AUTHOR = {Nikhil Swamy and Brian Corcoran and Michael Hicks},
  TITLE = {Fable: A Language for Enforcing User-defined Security Policies},
  BOOKTITLE = {Proceedings of the {IEEE} Symposium on Security and Privacy (Oakland)},
  MONTH = MAY,
  YEAR = 2008,
  PAGES = {369--383}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>A Theory of Typed Coercions and its Applications</b>.
  Nikhil Swamy, Michael Hicks, and Gavin&nbsp;S. Bierman.
  In <i>Proceedings of the ACM International Conference on
  Functional Programming (ICFP)</i>, pages 329-340, August 2009.</font><p>
  A number of important program rewriting scenarios can be recast as
  type-directed coercion insertion. These range from more theoretical
  applications such as coercive subtyping and supporting overloading
  in type theories, to more practical applications such as integrating
  static and dynamically typed code using gradual typing, and inlining
  code to enforce security policies such as access control and
  provenance tracking.  In this paper we give a general theory of
  type-directed coercion insertion.
  We specifically explore the inherent tradeoff between
  expressiveness and ambiguity-the more powerful the strategy for
  generating coercions, the greater the possibility of several,
  semantically distinct rewritings for a given program.  We consider
  increasingly powerful coercion generation strategies, work out
  example applications supported by the increased power (including
  those mentioned above), and identify the inherent ambiguity problems
  of each setting, along with various techniques to tame the
  ambiguities.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/coercions.pdf">.pdf</a> ]
<a name="swamy09coercion"></a><pre>
@INPROCEEDINGS{swamy09coercion,
  AUTHOR = {Nikhil Swamy and Michael Hicks and Gavin S. Bierman},
  TITLE = {A Theory of Typed Coercions and its Applications},
  PAGES = {329--340},
  BOOKTITLE = {Proceedings of the {ACM} International Conference on Functional Programming (ICFP)},
  MONTH = AUG,
  YEAR = 2009
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Lightweight Monadic Programming in ML</b>.
  Nikhil Swamy, Nataliya Guts, Daan Leijen, and Michael Hicks.
  In <i>Proceedings of the ACM International Conference on
  Functional Programming (ICFP)</i>, pages 15-27, September 2011.</font><p>
  Many useful programming constructions can be expressed as monads.
  Examples include probabilistic modeling,
  functional reactive programming, parsing, and information flow tracking,
  not to mention effectful functionality like state and I/O.  In this
  paper, we present a type-based rewriting algorithm to make
  programming with arbitrary monads as easy as using ML's built-in
  support for state and I/O.  Developers write programs using monadic
  values of type <EM>M</EM>&nbsp;<EM>t</EM> as if they were of type <EM>t</EM>, and our algorithm
  inserts the necessary binds, units, and monad-to-monad morphisms so
  that the program type checks.  Our algorithm, based on Jones'
  qualified types, produces principal types.  But principal
  types are sometimes 
  problematic: the program's semantics could depend on the choice of
  instantiation when more than one instantiation is valid.  In such 
  situations we are able to simplify the types to remove
  any ambiguity but without adversely affecting typability; thus we can
  accept strictly more programs.  Moreover, we have proved that this
  simplification is <em>efficient</em> (linear in the number of constraints)
  and <em>coherent</em>: while our algorithm induces a particular rewriting,
  all related rewritings will have the same semantics.
  We have implemented our approach for a core functional
  language and applied it successfully to simple examples from the
  domains listed above, which are used as illustrations throughout the
  paper.
  <p>[ <a href="http://research.microsoft.com/en-us/projects/coco/">http</a> | 
<a href="http://www.cs.umd.edu/~mwh/papers/monadic.pdf">.pdf</a> ]
<a name="swamy11monad"></a><pre>
@INPROCEEDINGS{swamy11monad,
  TITLE = {Lightweight Monadic Programming in {ML}},
  AUTHOR = {Nikhil Swamy and Nataliya Guts and Daan Leijen and Michael Hicks},
  BOOKTITLE = {Proceedings of the {ACM} International Conference on Functional Programming (ICFP)},
  YEAR = 2011,
  MONTH = SEP,
  PAGES = {15--27},
  HTTP = {<a href="http://research.microsoft.com/en-us/projects/coco/">http://research.microsoft.com/en-us/projects/coco/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Lightweight Monadic Programming in ML</b>.
  Nikhil Swamy, Nataliya Guts, Daan Leijen, and Michael Hicks.
  Technical Report MSR-TR-2011-039, Microsoft Research, May 2011.</font><p>
  Many useful programming constructions can be expressed as monads.
  Examples include probabilistic computations,
  time-varying expressions, parsers, and information flow tracking,
  not to mention effectful features like state and I/O.  In this
  paper, we present a type-based rewriting algorithm to make
  programming with arbitrary monads as easy as using ML's built-in
  support for state and I/O.  Developers write programs using monadic
  values of type <EM>M</EM>&nbsp;<EM>t</EM> as if they were of type <EM>t</EM>, and our algorithm
  inserts the necessary binds, units, and monad-to-monad morphisms so
  that the program typechecks.  Our algorithm is based on Jones'
  qualified types and enjoys three useful properties: (1) principal
  types, i.e., the rewriting we perform is the most general; (2)
  coherence, i.e., thanks to the monad and morphism laws, all
  instances of the principal rewriting have the same semantics; (3)
  decidability; i.e., the solver for generated constraints will always
  terminate.  Throughout the paper we present simple examples from the
  domains listed above.  Our most complete example, which illustrates
  the expressive power of our system, proves that ML programs
  rewritten by our algorithm to use the information flow monad are
  equivalent to programs in FlowCaml, a domain-specific information
  flow tracking language.
  <p>[ <a href="http://research.microsoft.com/en-us/projects/coco/">http</a> | 
<a href="http://research.microsoft.com/pubs/147003/monadic.pdf">.pdf</a> ]
<a name="swamy11monadTR"></a><pre>
@TECHREPORT{swamy11monadTR,
  TITLE = {Lightweight Monadic Programming in {ML}},
  AUTHOR = {Nikhil Swamy and Nataliya Guts and Daan Leijen and Michael Hicks},
  NUMBER = {MSR-TR-2011-039},
  INSTITUTION = {Microsoft Research},
  YEAR = 2011,
  MONTH = MAY,
  HTTP = {<a href="http://research.microsoft.com/en-us/projects/coco/">http://research.microsoft.com/en-us/projects/coco/</a>}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Polymonadic Programming</b>.
  Michael Hicks, Gavin Bierman, Nataliya Guts, Daan Leijen, and Nikhil
  Swamy, October 2013.</font><p>
  Monads are a popular tool for the working functional programmer to
  structure effectful computations. This paper presents
  <em>polymonads</em>, a generalization of monads. Polymonads give the
  familiar monadic bind the more general type 
  for all <EM>a</EM>,<EM>b</EM>. <EM>L</EM> <EM>a</EM> -&gt; (<EM>a</EM> -&gt; <EM>M</EM> <EM>b</EM>) -&gt; <EM>N</EM> <EM>b</EM>, to
  compose computations with three different kinds of effects, rather
  than just one. Polymonads subsume monads and parameterized monads,
  and can express other constructions, including precise
  type-and-effect systems and information flow tracking; more
  generally, polymonads correspond to Tate's <em>productoid</em>
  semantic model. We show how to equip a core language (called <EM>lambda</EM><sub>PM</sub>)
  with syntactic support for programming with polymonads. Type
  inference and elaboration in <EM>lambda</EM><sub>PM</sub> allows programmers to write
  polymonadic code directly in an ML-like syntax-our algorithms
  compute principal types and produce elaborated programs wherein
  the binds appear explicitly. Furthermore, we prove that the
  elaboration is <em>coherent</em>: no matter which (type-correct) binds
  are chosen, the elaborated program's semantics will be the
  same. Pleasingly, the inferred types are easy to read: the polymonad
  laws justify (sometimes dramatic) simplifications, but with no
  effect on a type's generality.<P>
<a href="http://www.cs.umd.edu/~mwh/polymonads-impl.tgz">A prototype implementation of <EM>lambda</EM><sub>PM</sub></a> is available.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/polymonads.pdf">.pdf</a> ]
<a name="swamy13polymonad"></a><pre>
@MISC{swamy13polymonad,
  TITLE = {Polymonadic Programming},
  AUTHOR = {Michael Hicks and Gavin Bierman and Nataliya Guts and Daan Leijen and Nikhil Swamy},
  MONTH = OCT,
  YEAR = 2013,
  SUBMITTED = {yes}
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>What's the Over/Under? Probabilistic Bounds on Information Leakage</b>.
  Ian Sweet, Jos Manuel&nbsp;Caldern Trilla, Chad Scherrer, Michael
  Hicks, and Stephen Magill, February 2017.</font><p>
  Quantitative information flow (QIF) is concerned with measuring the
  knowledge about secret data that is gained by observing the result
  of a computation over that data. QIF has important applications in
  the domain of privacy, as an increase in attacker knowledge
  corresponds to a decrease in the privacy of a user's data. In this
  paper, we consider techniques for computing the Bayes Vulnerability
  of secret data due to answering a query. Our approach augments a
  baseline probabilistic abstract interpretation with both sampling
  and symbolic execution. The approach first computes a sound but
  imprecise upper bound on the vulnerability and then refines it. We
  prove this approach retains the soundness of the abstract
  interpretation. We also present detailed experimental results that
  quantify the precision and performance improvements of our
  techniques. We find augmenting imprecise abstract interpretation
  with our techniques can match the precision of precise abstract
  interpretation but with with orders of magnitude better performance.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/prob-paper-submit.pdf">.pdf</a> ]
<a name="sweet17prob"></a><pre>
@MISC{sweet17prob,
  TITLE = {What's the Over/Under? Probabilistic Bounds on Information Leakage},
  AUTHOR = {Ian Sweet and Jos\'e Manuel Calder\'on Trilla and
  Chad Scherrer and Michael Hicks and Stephen Magill},
  SUBMITTED = {yes},
  MONTH = FEB,
  YEAR = 2017
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>MultiOtter: Multiprocess Symbolic Execution</b>.
  Jonathan Turpie, Elnatan Reisner, Jeffrey&nbsp;S. Foster, and Michael
  Hicks.
  Technical Report CS-TR-4982, University of Maryland Department of
  Computer Science, August 2011.</font><p>
  Symbolic execution can be an effective technique for exploring large numbers
  of program paths, but it has generally been applied to programs running in
  isolation, whose inputs are files or command-line arguments. Programs that
  take inputs from other programs-servers, for example-have been
  beyond the reach of symbolic execution. To address this, we developed a
  multiprocess symbolic
  executor called MultiOtter, along with an implementation of many of the POSIX functions, such as
  <tt>socket</tt> and <tt>select</tt>, that interactive programs usually rely on.
  However, that is just a first step. Next, we must determine what symbolic inputs
  to feed to an interactive program to make multiprocess symbolic execution effective.
  Providing completely unconstrained symbolic values causes symbolic execution
  to spend too much time exploring uninteresting paths, such as paths to handle
  invalid inputs. MultiOtter allows us to generate inputs that conform to a
  context-free grammar, similar to previous work, but it also enables new input
  generation capabilities because we can now run arbitrary programs concurrently
  with the program being studied. As examples, we symbolically executed a
  key-value store server, redis, and an FTP server, vsftpd, each with a variety
  of inputs, including symbolic versions of tests from redis's test suite
  and wget as a client for vsftpd. We report the coverage provided by symbolic
  execution with various forms of symbolic input, showing that different testing
  goals require different degrees of symbolic inputs.
  <p>[ <a href="http://www.cs.umd.edu/~mwh/papers/multiotter.pdf">.pdf</a> ]
<a name="turpie11multiotter"></a><pre>
@TECHREPORT{turpie11multiotter,
  TITLE = {MultiOtter: Multiprocess Symbolic Execution},
  AUTHOR = {Jonathan Turpie and Elnatan Reisner and Jeffrey S. Foster and Michael Hicks},
  NUMBER = {CS-TR-4982},
  INSTITUTION = {University of Maryland Department of Computer Science},
  YEAR = 2011,
  MONTH = AUG
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evaluating Design Tradeoffs in Numeric Static Analysis for Java</b>.
  Shiyi Wei, Piotr Mardziel, Andrew Ruef, Jeffrey&nbsp;S. Foster, and
  Michael Hicks, November 2016.</font><p>
  Static analysis techniques for reasoning about numeric data are important for applications such as array bounds checking and resource usage estimation.
Applying these techniques to real-world Java programs also requires handling important language features such as dynamic memory allocation and method calls.
However, designing a scalable analysis that handles such features presents a multitude of choices, each of which may interact with the others. For example, we could use top-down or a bottom-up interprocedural analysis, and this choice could interact with how we choose to represent aliasing in the heap and/or whether we use a relational numeric domain, e.g., convex polyhedra.
In this paper, we present a family of static numeric analyses for Java and systematically evaluate the impact 216 analysis configurations on a small benchmark suite considering precision, performance, and their tradeoff.
The core of our analysis family-the combination handling numeric data, a heap abstraction, and method calls-is new, while the remaining configuration options are drawn from the literature.
We find that the best overall precision/performance tradeoff is made by bottom-up analysis with a hybrid relational/non-relational numeric domain and special handling of strings. However, other configurations offer advantages in particular cases.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/eval-analysis-submit.pdf">.pdf</a> ]
<a name="wei16evaluating"></a><pre>
@MISC{wei16evaluating,
  AUTHOR = {Shiyi Wei and Piotr Mardziel and Andrew Ruef and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Evaluating Design Tradeoffs in Numeric Static Analysis for Java},
  SUBMITTED = {yes},
  MONTH = NOV,
  YEAR = 2016
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
<font size="+1"><b>Evaluating Design Tradeoffs in Numeric Static Analysis for Java</b>.
  Shiyi Wei, Piotr Mardziel, Andrew Ruef, Jeffrey&nbsp;S. Foster, and
  Michael Hicks, April 2017.</font><p>
  Static analysis techniques for reasoning about numeric data are important for applications such as array bounds checking and resource usage estimation.
Applying these techniques to real-world Java programs also requires handling important language features such as dynamic memory allocation and method calls.
However, designing a scalable analysis that handles such features presents a multitude of choices, each of which may interact with the others. For example, we could use top-down or a bottom-up interprocedural analysis, and this choice could interact with how we choose to represent aliasing in the heap and/or whether we use a relational numeric domain, e.g., convex polyhedra.
In this paper, we present a family of static numeric analyses for Java and systematically evaluate the impact 216 analysis configurations on a small benchmark suite considering precision, performance, and their tradeoff.
The core of our analysis family-the combination handling numeric data, a heap abstraction, and method calls-is new, while the remaining configuration options are drawn from the literature.
We find that the best overall precision/performance tradeoff is made by bottom-up analysis with a hybrid relational/non-relational numeric domain and special handling of strings. However, other configurations offer advantages in particular cases.
<p>[ <a href="http://www.cs.umd.edu/~mwh/papers/eval-analysis-submit.pdf">.pdf</a> ]
<a name="wei17evaluating"></a><pre>
@MISC{wei17evaluating,
  AUTHOR = {Shiyi Wei and Piotr Mardziel and Andrew Ruef and Jeffrey S. Foster and Michael Hicks},
  TITLE = {Evaluating Design Tradeoffs in Numeric Static Analysis for Java},
  SUBMITTED = {yes},
  MONTH = APR,
  YEAR = 2017
}
</pre>

<hr><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.69</em>
